<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NFX</name>
    </assembly>
    <members>
        <member name="T:NFX.App">
            <summary>
            Provides a shortcut access to app-global context NFX.ApplicationModel.ExecutionContext.Application.*
            </summary>
        </member>
        <member name="M:NFX.App.UniversalTimeToLocalizedTime(System.DateTime)">
            <summary>
            Converts universal time to local time as of TimeLocation property
            </summary>
        </member>
        <member name="M:NFX.App.LocalizedTimeToUniversalTime(System.DateTime)">
            <summary>
            Converts localized time to universal time as of TimeLocation property
            </summary>
        </member>
        <member name="P:NFX.App.InstanceID">
            <summary>
            Returns unique identifier of this running instance
            </summary>
        </member>
        <member name="P:NFX.App.StartTime">
            <summary>
            Returns timestamp when application started as localized app time 
            </summary>
        </member>
        <member name="P:NFX.App.Available">
            <summary>
            Returns true when application container is active non-NOPApplication instance
            </summary>
        </member>
        <member name="P:NFX.App.Active">
            <summary>
            Returns true when application instance is active and working. This property returns false as soon as application finalization starts on shutdown
            Use to exit long-running loops and such
            </summary>
        </member>
        <member name="P:NFX.App.Log">
            <summary>
            References app log
            </summary>
        </member>
        <member name="P:NFX.App.Instrumentation">
            <summary>
            References instrumentation for this application instance
            </summary>
        </member>
        <member name="P:NFX.App.Throttling">
            <summary>
            References throttling for this application instance
            </summary>
        </member>
        <member name="P:NFX.App.ConfigRoot">
            <summary>
            References application configuration root
            </summary>
        </member>
        <member name="P:NFX.App.DataStore">
            <summary>
            References application data store
            </summary>
        </member>
        <member name="P:NFX.App.ObjectStore">
            <summary>
            References object store that may be used to persist object graphs between volatile application shutdown cycles  
            </summary>
        </member>
        <member name="P:NFX.App.Glue">
            <summary>
            References glue implementation that may be used to "glue" remote instances/processes/contracts together
            </summary>
        </member>
        <member name="P:NFX.App.SecurityManager">
            <summary>
            References security manager that performs user authentication based on passed credentials and other security-related global tasks
            </summary>
        </member>
        <member name="P:NFX.App.TimeSource">
            <summary>
            References time source - an entity that supplies local and UTC times. The concrete implementation
             may elect to get accurate times from the network or other external precision time sources (i.e. NASA atomic clock)
            </summary>
        </member>
        <member name="P:NFX.App.EventTimer">
            <summary>
            References event timer that maintains and runs scheduled Event instances
            </summary>
        </member>
        <member name="P:NFX.App.Name">
            <summary>
            Returns application name
            </summary>
        </member>
        <member name="P:NFX.App.TimeLocation">
            <summary>
            Returns the location
            </summary>
        </member>
        <member name="P:NFX.App.LocalizedTime">
            <summary>
            Returns current time localized per TimeLocation
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.BaseSession">
            <summary>
            Implements base ISession  functionality
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.ISession">
            <summary>
            Describes user session 
            </summary>
        </member>
        <member name="T:NFX.IEndableInstance">
            <summary>
            Describes an entity that can request some hosting container to end its lifetime by calling End() method 
            </summary>
        </member>
        <member name="M:NFX.IEndableInstance.End">
            <summary>
            Requests container that hosts.runs this entity to end its instance
            </summary>
        </member>
        <member name="P:NFX.IEndableInstance.IsEnded">
            <summary>
            Indicates whether this instance was requested to be ended and will get destoyed by the hosting container
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.ISession.Acquire">
            <summary>
            Acquires session for use
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.ISession.Release">
            <summary>
            Releases session after use
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.ISession.HasJustLoggedIn">
            <summary>
            Sets IsJustLoggedIn to true to indicate that user has supplied credentials/got checked via security manager.
            The caller of this method is implementation-specific and depends on what is considered to be "proof of users' identity"
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.ISession.RegenerateID">
            <summary>
            Generates new GUID and stores it in ID storing old ID value in OldID property which is not serializable.
            The implementations may elect to re-stow the existing session under the new ID.
            This method is usefull for security, i.e. when user logs-in we may want to re-generate ID
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ISession.ID">
            <summary>
            Gets unique session identifier 
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ISession.User">
            <summary>
            References a user this session is for
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ISession.IsNew">
            <summary>
            Indicates that session object was just created with current request processing cycle
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ISession.IsJustLoggedIn">
            <summary>
            Indicates that user login happened in current request processing cycle. This flag is 
            useful for long term token assignment on release
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ISession.LastLoginUTC">
            <summary>
            Returns the UTC DateTime of the last login/when HasJustLoggedIn() was called for the last time within the lifetime of this session object or NULL
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ISession.Items">
            <summary>
            References item dictionary that may be used to persist object graphs per session  
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ISession.Item(System.Object)">
            <summary>
            Shortcut to this.Items.TryGetValue(...). Returns null if key is not found
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ISession.OldID">
            <summary>
            When this parameter is not null then RegenerateID() was called and session provider may need to re-stow session object under a new ID
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.BaseSession.HasJustLoggedIn">
            <summary>
            Called from business code when user supplies login credentals and/or performs another action
            that can be qualified as a reliable user identity proof
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.BaseSession.RegenerateID">
            <summary>
            Generates new GUID and stores it in ID storing old ID value in OldID property which is not serializable.
            The implementations may elect to re-stow the existing session under the new ID.
            This method is usefull for security, i.e. when user logs-in we may want to re-generate ID
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.BaseSession.End">
            <summary>
            Ends session
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.BaseSession.ID">
            <summary>
            Returns Session ID
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.BaseSession.OldID">
            <summary>
            When this parameter is not null then RegenerateID() was called and session provider may need to re-stow session object under a new ID
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.BaseSession.IsNew">
            <summary>
            Indicates that session object was just created with current request processing cycle
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.BaseSession.IsJustLoggedIn">
            <summary>
            Indicates that user login happened in current request processing cycle. This flag is 
            useful for long term token assignment on release
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.BaseSession.LastLoginUTC">
            <summary>
            Returns the UTC DateTime of the last login/when HasJustLoggedIn() was called for the last time within the lifetime of this session object or NULL
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.BaseSession.IsEnded">
            <summary>
            Indicates whether this session was ended and will be destroyed after current request processing cycle
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.BaseSession.User">
            <summary>
            Returns session user
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.BaseSession.Items">
            <summary>
            Provides a thread-safe dictionary of items
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.BaseSession.Item(System.Object)">
            <summary>
            Shortcut to .Items. Getter return null instead of throwing if key is not found
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.CommonApplicationLogic">
            <summary>
            Provides base implementation of IApplication for various application kinds
            </summary>
        </member>
        <member name="T:NFX.DisposableObject">
            <summary>
            General-purpose base class for objects that need to be disposed
            </summary>
        </member>
        <member name="M:NFX.DisposableObject.Destructor">
            <summary>
            Override this method to do actual destructor work
            </summary>
        </member>
        <member name="M:NFX.DisposableObject.EnsureObjectNotDisposed">
            <summary>
            Checks to see whether object has been disposed and throws an exception if it has
            </summary>
        </member>
        <member name="M:NFX.DisposableObject.Dispose">
            <summary>
            Deterministically disposes object. DO NOT OVERRIDE this method, override Destructor() instead UNLESS
             you need to achive special thread-safe dispose behavior
            </summary>
        </member>
        <member name="P:NFX.DisposableObject.Disposed">
            <summary>
            Indicates whether this object was already disposed
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.IApplication">
            <summary>
            Describes general application model - usually a dependency injection container 
             that governs application initialization, state management, logging etc...
            An applications is usually implemented with a singleton class that has static
             conduits to instance properties. Applications may be passed by reference (hence this interface)
              to simplify mocking that otherwise (in case of static-only class) would have been impossible
            </summary>
        </member>
        <member name="T:NFX.INamed">
            <summary>
            Denotes an entity that has a Name property. 
            This interface is primarily used with Registry[INamed] class that allows for 
             string-based addressing (getting instances by object instance name).
            The names are ideal for many system functions, like naming components in configs and admin tools 
            </summary>
        </member>
        <member name="T:NFX.Time.ILocalizedTimeProvider">
            <summary>
            Describes an entity that provides the localized time
            </summary>
        </member>
        <member name="M:NFX.Time.ILocalizedTimeProvider.UniversalTimeToLocalizedTime(System.DateTime)">
            <summary>
            Converts universal time to local time as of TimeLocation property
            </summary>
        </member>
        <member name="M:NFX.Time.ILocalizedTimeProvider.LocalizedTimeToUniversalTime(System.DateTime)">
            <summary>
            Converts localized time to UTC time as of TimeLocation property
            </summary>
        </member>
        <member name="P:NFX.Time.ILocalizedTimeProvider.TimeLocation">
            <summary>
            Returns the location
            </summary>
        </member>
        <member name="P:NFX.Time.ILocalizedTimeProvider.LocalizedTime">
            <summary>
            Returns current time localized per TimeLocation
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.IApplication.Stop">
            <summary>
            Initiates the stop of the application by setting its Stopping to true and Active to false so dependent services may start to terminate 
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.IApplication.MakeNewSessionInstance(System.Guid,NFX.Security.User)">
            <summary>
            Factory method that creates new session object suitable for partcular application type
            </summary>
            <param name="sessionID">Session identifier</param>
            <param name="user">Optional user object that the session is for</param>
            <returns>New session object</returns>
        </member>
        <member name="M:NFX.ApplicationModel.IApplication.RegisterConfigSettings(NFX.Environment.IConfigSettings)">
            <summary>
            Registers an instance of IConfigSettings with application container to receive a call when
             underlying app configuration changes
            </summary>
            <returns>True if settings instance was not found and was added</returns>
        </member>
        <member name="M:NFX.ApplicationModel.IApplication.UnregisterConfigSettings(NFX.Environment.IConfigSettings)">
            <summary>
            Removes the registration of IConfigSettings from application container
            </summary>
            <returns>True if settings instance was found and removed</returns>
        </member>
        <member name="M:NFX.ApplicationModel.IApplication.NotifyAllConfigSettingsAboutChange">
            <summary>
            Forces notification of all registered IConfigSettings-implementers about configuration change
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.IApplication.RegisterAppFinishNotifiable(NFX.ApplicationModel.IApplicationFinishNotifiable)">
            <summary>
            Registers an instance of IApplicationFinishNotifiable with application container to receive a call when
             underlying application instance will finish its lifecycle.
            </summary>
            <returns>True if notifiable instance was not found and was added</returns>
        </member>
        <member name="M:NFX.ApplicationModel.IApplication.UnregisterAppFinishNotifiable(NFX.ApplicationModel.IApplicationFinishNotifiable)">
            <summary>
            Removes the registration of IApplicationFinishNotifiable from application container
            </summary>
            <returns>True if notifiable instance was found and removed</returns>
        </member>
        <member name="P:NFX.ApplicationModel.IApplication.InstanceID">
            <summary>
            Returns unique identifier of this running instance
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.IApplication.StartTime">
            <summary>
            Returns timestamp when application started as localized app time 
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.IApplication.Active">
            <summary>
            Returns true when application instance is active and working. This property returns false as soon as application finalization starts on shutdown or Stop() was called
            Use to exit long-running loops and such
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.IApplication.Stopping">
            <summary>
            Returns true after Stop() was called
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.IApplication.ShutdownStarted">
            <summary>
            Returns true after Dispose() was called to indicate that application is shutting down
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.IApplication.Log">
            <summary>
            References app log
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.IApplication.Instrumentation">
            <summary>
            References instrumentation for this application instance
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.IApplication.Throttling">
            <summary>
            References throttling for this application instance
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.IApplication.ConfigRoot">
            <summary>
            References application configuration root
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.IApplication.DataStore">
            <summary>
            References application data store
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.IApplication.ObjectStore">
            <summary>
            References object store that may be used to persist object graphs between volatile application shutdown cycles  
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.IApplication.Glue">
            <summary>
            References glue implementation that may be used to "glue" remote instances/processes/contracts together
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.IApplication.SecurityManager">
            <summary>
            References security manager that performs user authentication based on passed credentials and other security-related global tasks
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.IApplication.TimeSource">
            <summary>
            References time source - an entity that supplies local and UTC times. The concrete implementation
             may elect to get accurate times from the network or other external precision time sources (i.e. NASA atomic clock)
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.IApplication.EventTimer">
            <summary>
            References event timer - an entity that maintains and runs scheduled instances of Event
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.Stop">
            <summary>
            Initiates the stop of the application by setting its Stopping to true and Active to false so dependent services may start to terminate 
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.UniversalTimeToLocalizedTime(System.DateTime)">
            <summary>
            Converts universal time to local time as of TimeLocation property
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.LocalizedTimeToUniversalTime(System.DateTime)">
            <summary>
            Converts localized time to UTC time as of TimeLocation property
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.MakeNewSessionInstance(System.Guid,NFX.Security.User)">
            <summary>
            Makes BaseSession instance
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.RegisterConfigSettings(NFX.Environment.IConfigSettings)">
            <summary>
            Registers an instance of IConfigSettings with application container to receive a call when
             underlying app configuration changes
            </summary>
            <returns>True if settings instance was not found and was added</returns>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.UnregisterConfigSettings(NFX.Environment.IConfigSettings)">
            <summary>
            Removes the registration of IConfigSettings from application container
            </summary>
            <returns>True if settings instance was found and removed</returns>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.NotifyAllConfigSettingsAboutChange">
            <summary>
            Forces notification of all registered IConfigSettings-implementers about configuration change
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.RegisterAppFinishNotifiable(NFX.ApplicationModel.IApplicationFinishNotifiable)">
            <summary>
            Registers an instance of IApplicationFinishNotifiable with application container to receive a call when
             underlying application instance will finish its lifecycle
            </summary>
            <returns>True if notifiable instance was not found and was added</returns>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.UnregisterAppFinishNotifiable(NFX.ApplicationModel.IApplicationFinishNotifiable)">
            <summary>
            Removes the registration of IConfigSettings from application container
            </summary>
            <returns>True if notifiable instance was found and removed</returns>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.PreloadAssemblies(System.Boolean)">
            <summary>
            RESERVED for future use. Loads assemblies specified in 'preload-assemblies' section from disk optionally checking the 'enabled' flag.
            This method is called on application startup by the framework
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.GetDefaultConfigFileName">
            <summary>
            Tries to find a configuration file name looping through various supported estensions
            </summary>
            <returns>File name that exists or empty string</returns>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.NotifyAllConfigSettingsAboutChange(NFX.Environment.IConfigSectionNode)">
            <summary>
            Forces notification of all registered IConfigSettings-implementers about configuration change
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.BeforeLogStart(NFX.Log.ILogImplementation)">
            <summary>
            Override to prep log implementation i.e. inject log destinations programmaticaly 
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.BeforeInstrumentationStart(NFX.Instrumentation.IInstrumentationImplementation)">
            <summary>
            Override to prep instr implementation i.e. inject something programmaticaly 
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.BeforeThrottlingStart(NFX.Throttling.IThrottlingImplementation)">
            <summary>
            Override to prep throttling implementation i.e. inject something programmaticaly 
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.BeforeDataStoreStart(NFX.DataAccess.IDataStoreImplementation)">
            <summary>
            Override to prep data store implementation i.e. inject something programmaticaly 
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.BeforeObjectStoreStart(NFX.ApplicationModel.Volatile.IObjectStoreImplementation)">
            <summary>
            Override to prep object store implementation i.e. inject something programmaticaly 
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.BeforeGlueStart(NFX.Glue.IGlueImplementation)">
            <summary>
            Override to prep glue implementation i.e. inject something programmaticaly 
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.BeforeSecurityManagerStart(NFX.Security.ISecurityManagerImplementation)">
            <summary>
            Override to prep security manager implementation i.e. inject something programmaticaly 
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.BeforeTimeSourceStart(NFX.Time.ITimeSourceImplementation)">
            <summary>
            Override to prep time source implementation i.e. inject something programmaticaly 
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.BeforeEventTimerStart(NFX.Time.IEventTimerImplementation)">
            <summary>
            Override to prep event timer implementation i.e. inject something programmaticaly 
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.CommonApplicationLogic.InstanceID">
            <summary>
            Returns unique identifier of this running instance 
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.CommonApplicationLogic.StartTime">
            <summary>
            Returns timestamp when application started as localized app time 
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.CommonApplicationLogic.Name">
            <summary>
            Returns the name of this application
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.CommonApplicationLogic.Active">
            <summary>
            Returns true when application instance is active and working. This property returns false as soon as application finalization starts on shutdown
            Use to exit long-running loops and such
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.CommonApplicationLogic.Stopping">
            <summary>
            Returns true to indicate that Stop() was called
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.CommonApplicationLogic.ShutdownStarted">
            <summary>
            Returns true to indicate that Dispose() has been called and shutdown has started
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.CommonApplicationLogic.Log">
            <summary>
            References application logger
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.CommonApplicationLogic.Instrumentation">
            <summary>
            References application instrumentation
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.CommonApplicationLogic.Throttling">
            <summary>
            References application throttling
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.CommonApplicationLogic.ConfigRoot">
            <summary>
            Provides access to configuration root for the whole application
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.CommonApplicationLogic.DataStore">
            <summary>
            References application data store
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.CommonApplicationLogic.ObjectStore">
            <summary>
            References application object store. Objects will survive application termination 
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.CommonApplicationLogic.Glue">
            <summary>
            References glue that can be used to interconnect remote instances
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.CommonApplicationLogic.SecurityManager">
            <summary>
            References security manager that performs user authentication based on passed credentials and other security-related global tasks
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.CommonApplicationLogic.TimeSource">
            <summary>
            References time source - an entity that supplies local and UTC times. The concrete implementation
             may elect to get accurate times from the network or other external precision time sources (i.e. NASA atomic clock)
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.CommonApplicationLogic.EventTimer">
            <summary>
            References event timer which maintains and runs scheduled Event instances
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.CommonApplicationLogic.TimeLocation">
            <summary>
            Returns time location of this LocalizedTimeProvider implementation
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.CommonApplicationLogic.LocalizedTime">
            <summary>
            Returns current time localized per TimeLocation
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.CommonApplicationLogic.LogTopic">
            <summary>
            Provides log topic name
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.IApplicationComponent">
            <summary>
            Provides marker contract requirement for an ApplicationComponent.
            This interface must be implemented only by ApplicationComponent class
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.IApplicationComponent.ComponentSID">
            <summary>
            Returns process/instance unique app component system id
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.IApplicationComponent.ComponentDirector">
            <summary>
            Returns a reference to an object that this app component services/operates under, or null
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.IApplicationComponent.ComponentCommonName">
            <summary>
            Returns the common name used to identify the component, for example "Glue" for various IGlue implementations.
            This name is searched-by some management tools that allow to find component by this name that does not change between
            application restarts like ComponentSID does. Subordinate (non-root) components return null
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.ApplicationComponent">
            <summary>
            An abstraction of a disposable application component - major implementation/functionality part of an app.
            Components logically subdivide application container so their instances may be discovered
             by other parties, for example: one may iterate over all components in an application that support instrumentation and logging.
             Services are sub-types of components.
            Use "ApplicationComponent.AllComponents" to access all components in the container 
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.ApplicationComponent.GetAppComponentBySID(System.UInt64)">
            <summary>
            Looks-up an existing application component instance by its ComponentSID or null
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.ApplicationComponent.GetAppComponentByCommonName(System.String)">
            <summary>
            Looks-up an existing application component instance by its ComponentCommonName or null. The search is case-insensitive
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ApplicationComponent.AllComponents">
            <summary>
            Returns a thread-safe enumerable( a snapshot) of all known component instances
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ApplicationComponent.ComponentSID">
            <summary>
            Returns process/instance unique app component system id
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ApplicationComponent.ComponentStartTime">
            <summary>
            Returns local computer time of component start (not from application container time)
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ApplicationComponent.ComponentCommonName">
            <summary>
            Returns the common name used to identify the component, for example "Glue" for various IGlue implementations.
            This name is searched-by some management tools that allow to find component by this name that does not change between
            application restarts like ComponentSID does. Subordinate (non-root) components return null
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ApplicationComponent.ComponentDirector">
            <summary>
            Returns a reference to an object that this app component services/operates under, or null
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.ExecutionContext">
            <summary>
            Provides access to execution context - an entity that groups Request, Response and Session object.
            This class has nothing to do with Web. Execution contexts are supported as easily in console, service, web,  and Windows forms apps.
             All objects may be either application-global or thread level. This class is useful for technology-agnostic implementations
            of Record Models i.e. in a Record class one may write:  " if (ExecutionContext.Session.User.Kind==UserKind.Administrator)..."
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.ExecutionContext.__SetApplicationLevelContext(NFX.ApplicationModel.IApplication,System.Object,System.Object,NFX.ApplicationModel.ISession)">
            <summary>
            Internal framework-only method to bind application-level context
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.ExecutionContext.__SetThreadLevelContext(System.Object,System.Object,NFX.ApplicationModel.ISession)">
            <summary>
            Internal framework-only method to bind thread-level context
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.ExecutionContext.__SetThreadLevelSessionContext(NFX.ApplicationModel.ISession)">
            <summary>
            Internal framework-only method to bind thread-level context
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ExecutionContext.Application">
            <summary>
            Returns global application context
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ExecutionContext.Request">
            <summary>
            Returns Request object for current thread, or if it is null, app-global-level object is returned
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ExecutionContext.Response">
            <summary>
            Returns Response object for current thread, or if it is null, app-global-level object is returned
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ExecutionContext.Session">
            <summary>
            Returns Session object for current thread, or if it is null, app-global-level object is returned
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ExecutionContext.HasThreadContextSession">
            <summary>
            Returns true when thread-level session object is available and not a NOPSession instance 
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.IApplicationStarter">
            <summary>
            Represents an entity that performs work on application start.
            This entity must be either invoked directly or declared in config file under "starters" section
            </summary>
        </member>
        <member name="T:NFX.Environment.IConfigurable">
            <summary>
            Designates entities that may be configured
            </summary>
        </member>
        <member name="M:NFX.Environment.IConfigurable.Configure(NFX.Environment.IConfigSectionNode)">
            <summary>
            Configures an entity from supplied config node
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.IApplicationStarter.ApplicationStartBreakOnException">
            <summary>
            Indicates whether an exception that leaks from starter method invocation should break the application start,
             or just get logged
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.IApplicationFinishNotifiable">
            <summary>
            Represents an entity that can get notified about application finish
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.NOPSession">
            <summary>
            Represents a session that does nothing and returns fake user
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.NOPSession.Instance">
            <summary>
            Returns a singlelton instance of the NOPSession
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.DefaultPile">
            <summary>
            Provides default implementation of IPile which stores objects on a local machine.
            Use Instance static property to lazily allocated the default instance
            </summary>
        </member>
        <member name="T:NFX.ServiceModel.Service">
            <summary>
            Represents a lightweight service that can be controlled by Start/SignalStop-like commands.
            This class serves a a base for various implementations (i.e. LogService) including their composites.
            This class is thread-safe
            </summary>
        </member>
        <member name="T:NFX.ServiceModel.IService">
            <summary>
            Defines abstraction for an entity that is controlled by Start/Stop commands and has a status
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.IService.Start">
            <summary>
            Blocking call that starts the service instance
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.IService.SignalStop">
            <summary>
            Non-blocking call that initiates the stopping of the service
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.IService.CheckForCompleteStop">
            <summary>
            Non-blocking call that returns true when the service instance has completely stopped after SignalStop()
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.IService.WaitForCompleteStop">
            <summary>
            Blocks execution of current thread until this service has completely stopped
            </summary>
        </member>
        <member name="P:NFX.ServiceModel.IService.Status">
            <summary>
            Current service status
            </summary>
        </member>
        <member name="P:NFX.ServiceModel.IService.Running">
            <summary>
            Returns true when service is active or about to become active.
            Check in service implementation loops/threads/tasks
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.Service.Configure(NFX.Environment.IConfigSectionNode)">
            <summary>
            Configures service from configuration node (and possibly it's sub-nodes)
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.Service.Start">
            <summary>
            Blocking call that starts the service instance
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.Service.SignalStop">
            <summary>
            Non-blocking call that initiates the stopping of the service
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.Service.CheckForCompleteStop">
            <summary>
            Non-blocking call that returns true when the service instance has completely stopped after SignalStop()
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.Service.WaitForCompleteStop">
            <summary>
            Blocks execution of current thread until this service has completely stopped
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.Service.AcceptManagerVisit(System.Object,System.DateTime)">
            <summary>
            Accepts a visit of a manager entity - this call is useful for periodic updates of service status, 
            i.e.  when service does not have a thread of its own it can be periodically managed by some other service through this method.
            The default implementation of DoAcceptManagerVisit(object, DateTime) does nothing
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.Service.UniversalTimeToLocalizedTime(System.DateTime)">
            <summary>
            Converts universal time to local time as of TimeLocation property
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.Service.LocalizedTimeToUniversalTime(System.DateTime)">
            <summary>
            Converts localized time to UTC time as of TimeLocation property
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.Service.AbortStart">
            <summary>
            Allows to abort unsuccessful DoStart() overridden implementation.
            This method must be called from within DoStart()
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.Service.DoStart">
            <summary>
            Provides implementation that starts the service
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.Service.DoSignalStop">
            <summary>
            Provides implementation that signals service to stop. This is expected not to block
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.Service.DoCheckForCompleteStop">
            <summary>
            Provides implementation for checking whether the service has completely stopped
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.Service.DoWaitForCompleteStop">
            <summary>
            Provides implementation for a blocking call that returns only after a complete service stop
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.Service.DoConfigure(NFX.Environment.IConfigSectionNode)">
            <summary>
            Provides implementation that configures service from configuration node (and possibly it's sub-nodes)
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.Service.CheckServiceInactive">
            <summary>
            Checks for service inactivity and throws exception if service is running (started, starting or stopping)
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.Service.DoAcceptManagerVisit(System.Object,System.DateTime)">
            <summary>
            Accepts a visit from external manager. Base implementation does nothing. 
             Override in services that need external management calls
              to update their state periodically, i.e. when they don't have a thread on their own
            </summary>
        </member>
        <member name="P:NFX.ServiceModel.Service.Status">
            <summary>
            Current service status
            </summary>
        </member>
        <member name="P:NFX.ServiceModel.Service.Running">
            <summary>
            Returns true when service is active or about to become active.
            Check in service implementation loops/threads/tasks
            </summary>
        </member>
        <member name="P:NFX.ServiceModel.Service.Name">
            <summary>
            Provides textual name for the service
            </summary>
        </member>
        <member name="P:NFX.ServiceModel.Service.TimeLocation">
            <summary>
            Returns time location of this LocalizedTimeProvider implementation
            </summary>
        </member>
        <member name="P:NFX.ServiceModel.Service.LocalizedTime">
            <summary>
            Returns current time localized per TimeLocation
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.IPile">
            <summary>
            Represents a pile of objects - a custom memory heap that can store native CLR objects in a tightly-serialized form.
            Piles can be either local (allocate local RAM on the server), or distributed (allocate RAM on many servers).
            This class is designed primarily for applications that need to store/cache very many (100s of millions on local, billions on distributed) of objects in RAM
            (and/or possibly on disk) without causing the local CLR's GC scans of huge object graphs.
            Implementors of this interface are custom memory managers that favor the GC performance in apps with many objects at the cost of higher CPU usage.
            The implementor must be thread-safe for all operations unless stated otherwise on a member level.
            The memory represented by this class as a whole is not synchronizable, that is - it does not support functions like Interlocked-family, Lock, MemoryBarriers and the like
             that regular RAM supports. Should a need arise to interlock within the pile - a custom CLR-based lock must be used to syncronize access to pile as a whole, for example:
              a Get does not impose a lock on ALL concurrent writes throught the pile (a write does not block all gets either).
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.IPileStatus">
            <summary>
            Provides information about the pile - number of objects, allocated bytes, etc.
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.IPileStatus.Locality">
            <summary>
            Returns whether pile is local or distributed
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.IPileStatus.Persistence">
            <summary>
            Returns the model of object persistence that this pile supports
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.IPileStatus.SupportsObjectExpiration">
            <summary>
            Returns whether this instance supports object expiration
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.IPileStatus.ObjectCount">
            <summary>
            Returns the number of allocated objects in this pile
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.IPileStatus.AllocatedMemoryBytes">
            <summary>
            Returns the number of bytes allocated by this pile from system memory
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.IPileStatus.MemoryCapacityBytes">
            <summary>
            Returns an approximate capacity of free memory that the system has left
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.IPileStatus.UtilizedBytes">
            <summary>
            Returns the number of bytes allocated for object storage within AllocatedMemoryBytes
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.IPileStatus.OverheadBytes">
            <summary>
            Returns the number of extra bytes used by pile metadata currently occupied by object stored in this pile
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.IPileStatus.SegmentCount">
            <summary>
            Returns the number of segments allocated
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.IPileStatus.NodeCount">
            <summary>
            Returns the number of nodes(servers) that service this distributed pile.
            If this pile locality is local then returns 1
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.IPile.Put(System.Object,System.UInt32)">
            <summary>
            Puts a CLR object into the pile and returns a newly-allocated pointer.
            Throws out-of-space if there is not enough space in the pile and limits are set.
            Optional lifeSpanSec will auto-delete object after the interval elapses if 
             the pile SupportsObjectExpiration and SweepExpireObjects is set to true
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.IPile.Get(NFX.ApplicationModel.Pile.PilePointer)">
            <summary>
            Returns a CLR object by its pointer or throws access violation if pointer is invalid 
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.IPile.Delete(NFX.ApplicationModel.Pile.PilePointer,System.Boolean)">
            <summary>
            Deletes object from pile by its pointer returning true if there is no access violation
            and pointer is pointing to the valid object, throws otherwise unless
            throwInvalid is set to false
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.IPile.Rejuvenate(NFX.ApplicationModel.Pile.PilePointer)">
            <summary>
            If pile supports expiration, resets object age to zero.
            Returns true if object was found and reset. N/A for pile that do not support expiration
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.IPile.SizeOf(NFX.ApplicationModel.Pile.PilePointer)">
            <summary>
            Returns the size of pointed-to object in bytes or throws access violation if pointer is invalid.
            The serialized object size is returned, not the CLR object size.
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.IPile.Purge">
            <summary>
            Deletes all objects freeing all segment memory buffers.
            This method may require the caller to have special rights
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.IPile.Compact">
            <summary>
            Tries to delete extra capacity which is allocated but not currently needed.
            Returns the number of bytes freed back to the system
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.IInstrumentable">
            <summary>
            Denotes an entity that can be instrumented
            </summary>
        </member>
        <member name="T:NFX.IExternallyParameterized">
            <summary>
            Denotes an entity that has external parameters that can be get/set
            </summary>
        </member>
        <member name="M:NFX.IExternallyParameterized.ExternalParametersForGroups(System.String[])">
            <summary>
            Gets names of supported external parameters or null if parameters are not supported in principle
            </summary>
        </member>
        <member name="M:NFX.IExternallyParameterized.ExternalGetParameter(System.String,System.Object@,System.String[])">
            <summary>
            Gets external parameter value returning true if parameter was found
            </summary>
        </member>
        <member name="M:NFX.IExternallyParameterized.ExternalSetParameter(System.String,System.Object,System.String[])">
            <summary>
            Sets external parameter value, true if parameter name was found and set succeeded
            </summary>
        </member>
        <member name="P:NFX.IExternallyParameterized.ExternalParameters">
            <summary>
            Gets names/types of supported external parameters or null if parameters are not supported in principle
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.IInstrumentable.InstrumentationEnabled">
            <summary>
            Turns on/off instrumentation
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.IPileImplementation.AllocMode">
            <summary>
            Defines modes of allocation: space/time tradeoff
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.IPileImplementation.SweepExpiredObjects">
            <summary>
            Control whether the instance respects object life spans
            if they are set
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.IPileImplementation.MaxMemoryLimit">
            <summary>
            Imposes a limit on maximum number of bytes that a pile can allocate of the system heap.
            The default value of 0 means no limit, meaning - the pile will keep allocating objects
            until the system allows
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.IPileImplementation.MaxSegmentLimit">
            <summary>
            Gets the maximum count of segments that this pile can have.
            The property is not thread-safe for set and can only be set if pile is inactive.
            The value of zero means no limit
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.IPileImplementation.SegmentSize">
            <summary>
            Gets the segment size in bytes, up to (2^31)-1
            The property is not thread-safe for set and can only be set if pile is inactive
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.DefaultPile.Crawl(System.Boolean)">
            <summary>
            Analyzes all segments scanning for free spaces. Returns number of uncovered free bytes.
            This is a full-blocking long operation that may take around 8 seconds on a 64Gb heaps in non-parallel mode
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.DefaultPile.Put(System.Object,System.UInt32)">
            <summary>
            Puts a CLR object into the pile and returns a newly-allocated pointer.
            Throws out-of-space if there is not enough space in the pile and limits are set.
            Optional lifeSpanSec is ignored by this implementation
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.DefaultPile.Get(NFX.ApplicationModel.Pile.PilePointer)">
            <summary>
            Returns a CLR object by its pointer or throws access violation if pointer is invalid 
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.DefaultPile.Delete(NFX.ApplicationModel.Pile.PilePointer,System.Boolean)">
            <summary>
            Deletes object from pile by its pointer returning true if there is no access violation
            and pointer is pointing to the valid object, throws otherwise unless
            throwInvalid is set to false
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.DefaultPile.ExternalParametersForGroups(System.String[])">
            <summary>
            Returns named parameters that can be used to control this component
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.DefaultPile.ExternalGetParameter(System.String,System.Object@,System.String[])">
            <summary>
            Gets external parameter value returning true if parameter was found
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.DefaultPile.ExternalSetParameter(System.String,System.Object,System.String[])">
            <summary>
            Sets external parameter value returning true if parameter was found and set
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPile.InstrumentationEnabled">
            <summary>
            Implements IInstrumentable
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPile.Locality">
            <summary>
            Returns PileLocality.Local
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPile.Persistence">
            <summary>
            Returns PilePersistence.Memory
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPile.SupportsObjectExpiration">
            <summary>
            Returns false
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPile.NodeCount">
            <summary>
            Returns 1 as this pile is not distributed
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPile.AllocMode">
            <summary>
            Defines modes of allocation: space/time tradeoff
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPile.FreeChunkSizes">
            <summary>
            Sets the sizes of free chunks that free lists group by.
            Must be an array of FREE_LST_COUNT(16) of consequitively increasing integers
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPile.FreeListSize">
            <summary>
            Determines the size of free chunk list. Every segment has FREE_LST_COUNT=16 lists each of this size.
            This property may only be set on an inactive service instance
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPile.MaxSegmentLimit">
            <summary>
            Gets the maximum count of segments tha this pile can have.
            The property is not thread-safe for set and can only be set if pile is inactive.
            The value of zero means no limit
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPile.SegmentSize">
            <summary>
            Gets the maximum segment size in bytes, up to (2^31)-1
            The property is not thread-safe for set and can only be set if pile is inactive
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPile.MaxMemoryLimit">
            <summary>
            Imposes a limit on maximum number of bytes that a pile can allocate of the system heap.
            The default value of 0 means no limit, meaning - the pile will keep allocating objects
            until the system allows. The value may not be less than minimum 1 seg size (64 mb).
            May set on an active instance, however no existing objects will be removed if the limit is exceeded
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPile.ObjectCount">
            <summary>
            Returns the total number of objects allocated at this point in time
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPile.AllocatedMemoryBytes">
            <summary>
            Returns the number of bytes allocated by this pile from the system memory heap.
            As pile pre-allocates memory in segments, it is absolutely normal to have this property return 100s of megabytes even when pile is almost empty.
            This property may return close to all physical memory available
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPile.UtilizedBytes">
            <summary>
            Returns the number of bytes currently occupied by object stored in this pile.
            This number is always less than AllocatedMemoryBytes
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPile.OverheadBytes">
            <summary>
            Returns the number of extra bytes used by pile metadata currently occupied by object stored in this pile
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPile.SegmentCount">
            <summary>
            Returns the total number of segments allocated at this point in time
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPile.MemoryCapacityBytes">
            <summary>
            Returns an approximate capacity of free memory that the system has left
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPile.SegmentTotalCount">
            <summary>
            Returns the total number of total segments - allocated and empty at this point in time.
            This number is greater or equal to SegmentCount
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPile.SweepExpiredObjects">
            <summary>
            Returns false and does nothing on set in this implementation
            if they are set
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPile.ExternalParameters">
            <summary>
            Returns named parameters that can be used to control this component
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.DefaultPile.SegmentCrawlStatus">
            <summary>
            Holds information obtained after a segment crawl
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.LocalityKind">
            <summary>
            Indicates where pile implementation stores data: local vs distributed
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.LocalityKind.Local">
            <summary>
            The pile resides on this machine and is limited by the RAM on the local server
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.LocalityKind.Distributed">
            <summary>
            The pile is distributed - it runs across many machines
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.LocalityKind.AumCluster">
            <summary>
            The pile is distributed - it runs across many machines using Aum Cluster
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.ObjectPersistence">
            <summary>
            Denotes modes of object persistence
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.ObjectPersistence.Memory">
            <summary>
            The data is kept in memory in a format that prohibits the preservation of data between object layout changes,
             for example, the Slim serializer does not support versioning, hence this mode is beneficial for maximum performance
             of local in-process heaps
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.ObjectPersistence.UpgreadableMemory">
            <summary>
            The data is kept in memory in a format that allows to change the object structure (serialization versioning), i.e.
             a distributed node may keep objects usable even after client's software changes
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.ObjectPersistence.Disk">
            <summary>
            The data is kept on disk. The data is in object-upgreadable format (support changes of object structure)
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.ObjectPersistence.MemoryDisk">
            <summary>
            The data is kept on disk and cached in memory (i.e. memory-mapped file).
            The data is in object-upgreadable format (support changes of object structure)
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.AllocationMode">
            <summary>
            Defines modes of allocation: space/time tradeoff
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.AllocationMode.ReuseSpace">
            <summary>
            The pile will try to reuse ram at the cost of possibly slower allocations
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.AllocationMode.FavorSpeed">
            <summary>
            The pile may use more ram in some cases but allocate faster
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.PileException">
            <summary>
            Thrown by pile memory manager
            </summary>
        </member>
        <member name="T:NFX.NFXException">
            <summary>
            Base exception thrown by the framework
            </summary>
        </member>
        <member name="P:NFX.NFXException.Code">
            <summary>
            Provides general-purpose error code
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.PileAccessViolationException">
            <summary>
            Thrown by pile memory manager when a supplied PilePointer is not pointing to a valid buffer
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.PileOutOfSpaceException">
            <summary>
            Thrown by pile memory manager when there is not anough room in the pile to perform the requested operation
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.PileCacheException">
            <summary>
            Thrown by pile cache
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CacheLongGauge">
            <summary>
            Provides base for cache long gauges
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.PileLongGauge">
            <summary>
            Provides base for pile long gauges
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.LongGauge">
            <summary>
            Represents a general-purpose long integer measurement datum
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Gauge">
            <summary>
            Represents a base for gauges - events of measurement of some values
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Datum">
            <summary>
            Base class for single measurement events (datums) reported to instrumentation
            </summary>
        </member>
        <member name="T:NFX.Serialization.JSON.IJSONWritable">
            <summary>
            Denotes a CLR type-safe entity (class or struct) that can directly write itself as JSON content string. 
            This mechanism bypasses all of the reflection/dynamic code.
            This approach may be far more performant for some classes that need to serialize their state/data in JSON format, 
            than relying on general-purpose JSON serializer that can serialize any type but is slower
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.IJSONWritable.WriteAsJSON(System.IO.TextWriter,System.Int32,NFX.Serialization.JSON.JSONWritingOptions)">
             <summary>
             Writes entitie's data/state as JSON string
             </summary>
            <param name="wri">
            TextWriter to write JSON content into
            </param>
             <param name="nestingLevel">
             A level of nesting that this instance is at, relative to the graph root.
             Implementations may elect to use this parameter to control indenting or ignore it
             </param>
             <param name="options">
             Writing options, such as indenting.
             Implementations may elect to use this parameter to control text output or ignore it
             </param>
        </member>
        <member name="M:NFX.Instrumentation.Datum.GetViewGroupInterfaces(System.Type)">
            <summary>
            Returns Datum classification interfaces marked with InstrumentViewGroup attribute. The implementation is cached fr efficiency
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Datum.Aggregate(System.Collections.Generic.IEnumerable{NFX.Instrumentation.Datum})">
            <summary>
            Aggregates events, for example from multiple threads into one
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Datum.ReduceSourceDetail(System.Int32)">
            <summary>
            Override to set a new source value which is less-specific than existing source.
            ReductionLevel specifies how much detail should be lost. The function is idempotent, that is - calling more than once with the same arg does not 
            change the state of the object.
            The default implementation removes all source details (unspecified source) when reductionLevel less than zero.
            Example:
             TotalBytesSent("mpx://45.12.123.19:7823 -> MySystem.Contracts.IDoSomething.SomeMethod1()")
             ReduceSourceDetail(0) -> yields original string
             ReduceSourceDetail(1) - > "MySystem.Contracts.IDoSomething.SomeMethod1()"
             ReduceSourceDetail(2) - > "MySystem.Contracts.IDoSomething"
             ReduceSourceDetail(3) - > ""
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Datum.UTCTime">
            <summary>
            Returns UTC time stamp when event happened
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Datum.UTCEndTime">
            <summary>
            Returns UTC time stamp when event happened. This property may be gotten only if IsAggregated==true, otherwise UTCTime value is returned
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Datum.IsAggregated">
            <summary>
            Indicates whether this instance represents a rollup/aggregation of multiple events
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Datum.Count">
            <summary>
            Returns count of measurements. This property may be gotten only if IsAggregated==true, otherwise zero is returned
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Datum.Source">
            <summary>
            Returns datum source. Data are rolled-up by type of recorded datum instances and source
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Datum.Rate">
            <summary>
            Returns rate of occurrence string
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Datum.Description">
            <summary>
            Returns description for data that this datum represents. Base implementation returns full type name of this instance
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Datum.ValueAsObject">
            <summary>
            Provides access to value polymorphically
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Datum.PlotValue">
            <summary>
            Provides numeric value used for charts
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Datum.ValueUnitName">
            <summary>
            Provides name for units that value is measured in
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Datum.ViewGroupInterfaces">
            <summary>
            Returns Datum classification interfaces marked with InstrumentViewGroup attribute. The implementation is cached fr efficiency
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.LongGauge.Value">
            <summary>
            Gets gauge value
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.ICacheInstrument">
            <summary>
            Cache-related operations
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.IOperationClass">
            <summary>
            A class of operations that instrument measures
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.IInstrumentClass">
            <summary>
            Root marker interface for instrumentation data classification.
            Instruments are primarily classified by their derivation from Datum ancestor, however this interface-based
             scheme allows for alternate classification (a la multiple inheritance)
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.IMemoryInstrument">
            <summary>
            Memory-related operations
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CacheDoubleGauge">
            <summary>
            Provides base for cache double gauges
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.PileDoubleGauge">
            <summary>
            Provides base for pile double gauges
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.DoubleGauge">
            <summary>
            Represents a general-purpose double measurement datum
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.DoubleGauge.Value">
            <summary>
            Gets gauge value
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CacheEvent">
            <summary>
            Provides base for cache events
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Event">
            <summary>
            Represents a base for events that happen so instrumentation can calculate event counts and rates of occurence
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CacheTableCount">
            <summary>
            Provides table count in the cache instance
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CacheCount">
            <summary>
            Provides object count in the cache instance
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CacheCapacity">
            <summary>
            Provides entry/slot count in the cache instance
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CacheLoadFactor">
            <summary>
            Provides load factor percentage
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CachePut">
            <summary>
            How many times put resulted in new object insertion in cache with or without overwriting the existing item
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CachePutCollision">
            <summary>
            How many times put could not insert new object in cache because there was no room and existing data could not be overwritten
             due to higher priority
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CachePutOverwrite">
            <summary>
            How many times put inserted new object in cache by overwriting existing value with lower priority
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CachePutReplace">
            <summary>
            How many times put replaced existing object in cache 
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CacheRemoveHit">
            <summary>
            How many times key was found and object removed
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CacheRemoveMiss">
            <summary>
            How many times key was not found and object not removed
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CacheSweep">
            <summary>
            How many entries/objects were removed by sweep
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CacheSweepDuration">
            <summary>
            How long the sweeping took (examination + removal of expired) 
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CacheTableSwept">
            <summary>
            Cache table was swept
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CacheRejuvenateHit">
            <summary>
            How many times key entry was found and its age reset to zero
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CacheRejuvenateMiss">
            <summary>
            How many times key entry was not found for resetting its age
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CacheGetHit">
            <summary>
            How many times cached object was found and gotten by its key
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CacheGetMiss">
            <summary>
            How many times cached object was tried to be gotten but not found by its key
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CacheGrew">
            <summary>
            How many times cache has to increase its capacity
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CacheShrunk">
            <summary>
            How many times cache has to decrease its capacity
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.ObjectCount">
            <summary>
            Provides object count in the instance
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.SegmentCount">
            <summary>
            Provides segment count in the instance
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.AllocatedMemoryBytes">
            <summary>
            Number of bytes allocated by the instance from system memory
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.MemoryCapacityBytes">
            <summary>
            Average capacity of free memory that the system has left
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.UtilizedBytes">
            <summary>
            Number of bytes allocated for object storage within AllocatedMemoryBytes
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.OverheadBytes">
            <summary>
            Number of extra bytes used by pile metadata currently occupied by object stored in this pile
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.AverageObjectSizeBytes">
            <summary>
            Number of bytes for average object
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.PutCount">
            <summary>
            Count of Put() calls
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.DeleteCount">
            <summary>
            Count of Delete() calls
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.GetCount">
            <summary>
            Count of Get() calls
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.ICache">
            <summary>
            Represents a cache of expiring objects, which are identified by a key and stored in a pile.
            Pile allows to store hundreds of millions of objects without overloading the managed GC.
            The cache may be local or distributed
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.ICache.GetOrCreateTable``1(System.String,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Returns existing table by name, if it does not exist creates a new table.
            For existing table the types must be identical to the ones used at creation
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.ICache.GetOrCreateTable``1(System.String,System.Boolean@,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Returns existing table by name, if it does not exist creates a new table.
            For existing table the types must be identical to the ones used at creation
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.ICache.GetTable``1(System.String)">
            <summary>
            Returns existing table by name, if it does not exist thorws.
            The TKey must correspond to existing table
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.ICache.PurgeAll">
            <summary>
            Removes all data from all tables stored in the cache
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.ICache.Locality">
            <summary>
            Returns whether the cache key:value mappings are local or distributed
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.ICache.Persistence">
            <summary>
            Returns the model of key:value mapping persistence that this cache supports
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.ICache.PileStatus">
            <summary>
            Returns the status of the pile where object are stored
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.ICache.Tables">
            <summary>
            Tables that this cache contains
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.ICache.Count">
            <summary>
            Returns how many records are kept in cache
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.ICacheTable.Purge">
            <summary>
            Removes all data from table
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.ICacheTable.Cache">
            <summary>
            References cache that this table is under
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.ICacheTable.Count">
            <summary>
            Returns how many records are kept in a table
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.ICacheTable.Capacity">
            <summary>
            Returns how many slots/entries allocated in a table
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.ICacheTable.LoadFactor">
            <summary>
            Returns the percentage of occupied table slots.
            When this number exceeds high-water-mark threshold the table is grown,
            otheriwse if the number falls below the low-water-mark level then the table is shrunk 
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.ICacheTable.Options">
            <summary>
            Cache table options in effect
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.PutResult">
            <summary>
            Denotes statuses of cache table Put
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.PutResult.Collision">
            <summary>
            The item could not be put because it collides with existing data
            that can not be overwritten because it has higher priority and there is no extra space
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.PutResult.Inserted">
            <summary>
            The item was inserted into cache table anew
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.PutResult.Replaced">
            <summary>
            The item replaced an existing item with the same key
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.PutResult.Overwritten">
            <summary>
            The item was inserted instead of an existing item with lower or equal priority
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.ICacheTable`1.Get(`0,System.Int32)">
            <summary>
            Gets cache object by key, optionally filtering-out objects older than ageSec param if it is &gt; zero.
            Returns null if there is no object with the specified key or it is older than ageSec limit.
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.ICacheTable`1.Put(`0,System.Object,System.Nullable{System.Int32},System.Int32,System.Nullable{System.DateTime})">
            <summary>
            Puts an object identified by a key into cache returning the result of the put.
            For example, put may have added nothing if the table is capped and the space is occupied with data of higher priority
            </summary>
            <param name="key">A table-wide unique obvject key</param>
            <param name="obj">An object to put</param>
            <param name="maxAgeSec">If null then the default maxAgeSec is taken from Options property, otherwise specifies the length of items life in seconds</param>
            <param name="priority">The priority of this item. If there is no space in future the items with lower priorities will not evict existing data with highr priorities</param>
            <param name="absoluteExpirationUTC">Optional UTC timestamp of object eviction from cache</param>
            <returns>The status of put - whether item was inserted/replaced(if key exists)/overwritten or collided with higher-prioritized existing data</returns>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.ICacheTable`1.Remove(`0)">
            <summary>
            Removes data by key returning true if found and removed
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.ICacheTable`1.Rejuvenate(`0)">
            <summary>
            Resets inetrnal object age returning true of object was foubd and rejuvenated
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.ICacheTable`1.GetOrPut(`0,System.Func{NFX.ApplicationModel.Pile.ICacheTable{`0},`0,System.Object,System.Object},System.Object,System.Nullable{NFX.ApplicationModel.Pile.PutResult}@,System.Int32,System.Int32,System.Int32,System.Nullable{System.DateTime})">
            <summary>
            Atomically tries to get object by key if it exists, otherwise calls a factory method under lock and puts the data with the specified parameters.
            'newPutResult' returns the result of the put after factory method call.
            Keep in mind, that even if a factory method created a new object, there may be a case when the value
            could not be physically inserted in the cache because of a collision (data with higher priority occupies space and space is capped), so check for
            'newPutResult' value which is null in case of getting an existing item. 
            Returns object that was gotten or created anew
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.ICacheTable`1.KeyComparer">
            <summary>
            Returns equality comparer for keys, or null to use default Equals
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.ICacheImplementation.PileMaxMemoryLimit">
            <summary>
            Imposes a limit on maximum number of bytes that a pile can allocate of the system heap.
            The default value of 0 means no limit, meaning - the pile will keep allocating objects
            until the system allows. If the limit is reached, then the cache will start deleting
            older objects to releave the memory load even if they are not due for expiration yet
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.ICacheImplementation.PileAllocMode">
            <summary>
            Defines modes of allocation: space/time tradeoff
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.ICacheImplementation.TableOptions">
            <summary>
            Returns table options - used for table creation
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.ICacheImplementation.DefaultTableOptions">
            <summary>
            Sets default options for a table which is not found in TableOptions collection.
            If this property is null then every table assumes the set of constant values defined in Table class
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.LocalCache">
            <summary>
            Provides default implementation of a cache that stores the mapping locally.
            The mapped-to objects may reside in local or distributed pile as configured
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.LocalCache.ExternalParametersForGroups(System.String[])">
            <summary>
            Returns named parameters that can be used to control this component
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.LocalCache.ExternalGetParameter(System.String,System.Object@,System.String[])">
            <summary>
            Gets external parameter value returning true if parameter was found
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.LocalCache.ExternalSetParameter(System.String,System.Object,System.String[])">
            <summary>
            Sets external parameter value returning true if parameter was found and set
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.LocalCache.InstrumentationEnabled">
            <summary>
            Implements IInstrumentable
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.LocalCache.Pile">
            <summary>
            Gets/sets a pile instance that this cache is using.
            Can set on an inactive only.
            If the target pile is directed by this service then it will start/stop the pile,
            otherwise the pile has to be managed externally
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.LocalCache.Tables">
            <summary>
            Tables that this cache contains
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.LocalCache.TableOptions">
            <summary>
            Returns table options - used for table creation
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.LocalCache.DefaultTableOptions">
            <summary>
            Sets default options for a table which is not found in TableOptions collection.
            If this property is null then every table assumes the set of constant values defined in Table class
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.LocalCache.DetailedInstrumentationForAllTables">
            <summary>
            Handy admin property that sets detailed instrumentation flag for all tables at once
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.LocalCache.Count">
            <summary>
            Returns total number of records in cache
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.LocalCache.ExternalParameters">
            <summary>
            Returns named parameters that can be used to control this component
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.LocalCacheTable`1.Count">
            <summary>
            How many records in the instance
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.LocalCacheTable`1.Capacity">
            <summary>
            How many entries are allocated for data
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.LocalCacheTable`1.LoadFactor">
            <summary>
            Load factor for the table
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.PilePointer">
            <summary>
            Represents a pointer to the pile object (object stored in a pile).
            The reference may be local or distributed in which case the NodeID is>=0.
            Distributed pointers are very useful for organizing piles of objects distributed among many servers, for example
             for "Big Memory" implementations or large neural networks where nodes may inter-connect between servers.
            The CLR reference to the IPile is not a part of this struct for performance and practicality reasons, as
             it is highly unlikely that there are going to be more than one instance of a pile in a process, however
             should more than 1 pile be allocated than this pointer would need to be wrapped in some other structure along with source IPile reference
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.PilePointer.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates distributed pointer
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.PilePointer.#ctor(System.Int32,System.Int32)">
            <summary>
            Create local pointer
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.PilePointer.NodeID">
            <summary>
            Distributed Node ID. The local pile sets this to -1 rendering this pointer as !DistributedValid
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.PilePointer.Segment">
            <summary>
            Segment # within pile
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.PilePointer.Address">
            <summary>
            Address within the segment
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.PilePointer.Invalid">
            <summary>
            Returns a -1:-1 non-valid pointer (either local or distributed)
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.PilePointer.Valid">
            <summary>
            Returns true if the pointer has positive segment and address, however this does not mean that pointed-to data exists.
            Even if this is a valid local pointer it may be an invalid distributed pointer
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.PilePointer.DistributedValid">
            <summary>
            Returns true if the pointer has positive distributed NodeID and has a valid local pointer
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.TableOptions">
            <summary>
            Provides config options for cache tables
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.TableOptions.Clone">
            <summary>
            Makes an identical copy of this instance
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.TableOptions.MinimumCapacity">
            <summary>
            How many elements a table may have at minimum, the property is checked at shrinking.
            Zero = no limit.
            The value is dependent on bucket count, so the actual table capacity is bucket-dependent
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.TableOptions.MaximumCapacity">
            <summary>
            How many elements a table may have at maximum, the property is checked at growth.
            Zero = no limit
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.TableOptions.InitialCapacity">
            <summary>
            How many elements an empty table should contain. The value is dependent on bucket count, so the actual table capacity is bucket-dependent
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.TableOptions.GrowthFactor">
            <summary>
            Defines the factor of growth - how much does a table grow when HWM is reached. The number has to be at least 1.2d
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.TableOptions.ShrinkFactor">
            <summary>
            Defines the factor of shrinking - how much does a table shrink when LWM is reached. The number has to be at most 0.7d
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.TableOptions.LoadFactorLWM">
            <summary>
            Defines the load factor below which the shrinking is triggered
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.TableOptions.LoadFactorHWM">
            <summary>
            Defines the load factor above which the growth is triggered
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.TableOptions.DefaultMaxAgeSec">
            <summary>
            Specifies default max age length which is applied to cache items if Put() does not specify particular max age
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.TableOptions.DetailedInstrumentation">
            <summary>
            True to include instrumentation details per table
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.TableOptions.AsExternalParameter">
            <summary>
            Allows to get/set options as external parameters
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.ServiceBaseApplication">
            <summary>
            Provides base implementation of IApplication for applications that have no forms like services and console apps. This class IS thread safe
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.ServiceBaseApplication.#ctor(System.String[],NFX.Environment.ConfigSectionNode)">
            <summary>
            Takes optional args[] and root configuration. If configuration is null then
             application is configured from a file co-located with entry-point assembly and
              called the same name as assembly with '.config' extension, unless args are specified and "/config file"
              switch is used in which case 'file' has to be locatable and readable.
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.ServiceBaseApplication.Destroy">
            <summary>
            Destroys application effectively finalizing all services
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ServiceBaseApplication.Instance">
            <summary>
            References a singleton instance of BaseApplication
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ServiceBaseApplication.ContextAvailable">
            <summary>
            Indicates whether application context was allocated  
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ServiceBaseApplication.AppName">
            <summary>
            Returns application name
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ServiceBaseApplication.IsActive">
            <summary>
            Returns true when application instance is active and working. This property returns false as soon as application finalization starts on shutdown
            Use to exit long-running loops and such
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ServiceBaseApplication.Logger">
            <summary>
            References application logger
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ServiceBaseApplication.Instruments">
            <summary>
            References application instrumentation
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ServiceBaseApplication.Throttles">
            <summary>
            References application throttling
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ServiceBaseApplication.CommandArgs">
            <summary>
            References command line arguments configuration, so one can use it as:
             <code>
              if (ServiceApplication.Instance.CommandArgs["DeleteFiles"].Exists)
              {
                // this will run if process was invoked like so: process.exe /deleteFiles 
              }
             </code>
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ServiceBaseApplication.CmdArgs">
            <summary>
            References command line arguments configuration, so one can use it as:
             <code>
              if (Servicepplication.CmdArgs["DeleteFiles"].Exists)
              {
                // this will run if process was invoked like so: process.exe /deleteFiles 
              }
             </code>
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ServiceBaseApplication.ConfRoot">
            <summary>
            Provides access to configuration root for the whole application
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ServiceBaseApplication.Data">
            <summary>
            References application data store
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ServiceBaseApplication.Objects">
            <summary>
            References application object store. Objects will survive application termination 
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ServiceBaseApplication.Glues">
            <summary>
            References glue that can be used to connect to remote entities
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ServiceBaseApplication.Security">
            <summary>
            References security manager that performs user authentication based on passed credentials and other security-related global tasks
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ServiceBaseApplication.Time">
            <summary>
            References time source - an entity that supplies local and UTC times. The concrete implementation
             may elect to get accurate times from the network or other external precision time sources (i.e. NASA atomic clock)
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ServiceBaseApplication.Timer">
            <summary>
            References event timer which maintains and runs scheduled Event instances
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.NOPApplication">
            <summary>
            Represents an application that consists of pure-nop providers, consequently
             this application does not log, does not store data and does not do anything else
            still satisfying its contract 
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.NOPApplication.Instance">
            <summary>
            Returns a singlelton instance of the NOPApplication
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.TestApplication">
            <summary>
            Application designated for use in various unit test cases.
            This class is not intended for use in production systems!
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.TestApplication.RegisterConfigSettings(NFX.Environment.IConfigSettings)">
            <summary>
            Registers an instance of IConfigSettings with application container to receive a call when
             underlying app configuration changes
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.TestApplication.UnregisterConfigSettings(NFX.Environment.IConfigSettings)">
            <summary>
            Removes the registration of IConfigSettings from application container
            </summary>
            <returns>True if settings instance was found and removed</returns>
        </member>
        <member name="M:NFX.ApplicationModel.TestApplication.NotifyAllConfigSettingsAboutChange">
            <summary>
            Forces notification of all registered IConfigSettings-implementers about configuration change
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.TestApplication.NotifyAllConfigSettingsAboutChange(NFX.Environment.IConfigSectionNode)">
            <summary>
            Forces notification of all registered IConfigSettings-implementers about configuration change
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Volatile.NOPObjectStoreProvider">
            <summary>
            Defines a provider that does not do anything - does not store object anywhere but memory 
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Volatile.ObjectStoreProvider">
            <summary>
            Defines a base provider that stores objects for ObjectStoreService class
            </summary>
        </member>
        <member name="T:NFX.ServiceModel.Service`1">
            <summary>
            Represents service with typed ComponentDirector property
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Volatile.FileObjectFormat">
            <summary>
            Format of files on disk
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Volatile.FileObjectStoreProvider">
            <summary>
            Defines a file-based provider that stores objects for ObjectStoreService class
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Volatile.FileObjectStoreProvider.Format">
            <summary>
            Returns file format used for serialization/deserialization into/from files 
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Volatile.FileObjectStoreProvider.LoadLimit">
            <summary>
            Imposes the limit on number of bytes that can be read from disk on load all.
            Once limit is exceeded the rest of objects will not load.
            Provider loads most recent objects first
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Volatile.FileObjectStoreProvider.LoadSize">
            <summary>
            Returns how many bytes have been loaded from disk
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Volatile.FileObjectStoreProvider.RootPath">
            <summary>
            Gets/sets the root path where objects are stored
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Volatile.IObjectStore">
            <summary>
            Outlines interface for object store
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.IObjectStore.Fetch(System.Guid,System.Boolean)">
            <summary>
            Retrieves an object reference from the store identified by the "key" or returns null if such object does not exist.
            Object is not going to be persisted as this method provides logical read-only access. If touch=true then object timestamp is updated
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.IObjectStore.CheckOut(System.Guid)">
            <summary>
            Retrieves an object reference from the store identified by the "key" or returns null if such object does not exist.
            Object is not going to be persisted until it is checked back in the store.
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.IObjectStore.CheckIn(System.Guid,System.Int32)">
            <summary>
            Puts an object into store identified by the "key"
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.IObjectStore.CheckIn(System.Guid,System.Object,System.Int32)">
            <summary>
            Puts an object reference "value" into store identified by the "key"
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.IObjectStore.CheckInUnderNewKey(System.Guid,System.Guid,System.Object,System.Int32)">
            <summary>
            Puts an object reference "value" into store identified by the "oldKey" under the "newKey".
            If oldKey was not checked in, then checks-in under new key as normally would
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.IObjectStore.Delete(System.Guid)">
            <summary>
            Deletes object identified by key. Returns true when object was found and marked for deletion
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Volatile.IObjectStore.ObjectLifeSpanMS">
            <summary>
            Specifies how long objects live without being touched before becoming evicted from the list
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Volatile.NOPObjectStore">
            <summary>
            Implements ObjectStore service that does nothing
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.NOPObjectStore.CheckOut(System.Guid)">
            <summary>
            Retrieves an object reference from the store identified by the "key" or returns null if such object does not exist.
            Object is not going to be persisted until it is checked back in the store.
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.NOPObjectStore.CheckIn(System.Guid,System.Object,System.Int32)">
            <summary>
            Puts an object reference "value" into store identified by the "key"
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.NOPObjectStore.CheckInUnderNewKey(System.Guid,System.Guid,System.Object,System.Int32)">
            <summary>
            Puts an object reference "value" into store identified by the "oldKey" under the "newKey".
            If oldKey was not checked in, then checks-in under new key as normally would
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.NOPObjectStore.CheckIn(System.Guid,System.Int32)">
            <summary>
            Puts an object reference "value" into store identified by the "key"
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.NOPObjectStore.Delete(System.Guid)">
            <summary>
            Deletes object identified by key. Returns true when object was found and marked for deletion
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Volatile.NOPObjectStore.Instance">
            <summary>
            Returns a singlelton instance of the objectstore that does not do anything
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Volatile.ObjectStoreEntryStatus">
            <summary>
            Represents status of ObjectStoreEntry
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Volatile.ObjectStoreEntry">
            <summary>
            Internal framework class that stores data in ObjectStoreService
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Volatile.ObjectStoreService">
            <summary>
            Implements service that stores object in proccess's memory, asynchronously saving objects to external non-volatile storage 
            upon change and synchronously saving objects upon service stop. This service is useful for scenarious like ASP.NET
            volatile domain that can be torn down at any time.
            Note for ASP.NET uses: the key difference of this approach from .NET session state management is the fact that this service never blocks
             object CheckIn() operations as backing store is being updated asynchronously.
            This class is thread-safe unless specified otherwise on a property/method level 
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.ObjectStoreService.#ctor">
            <summary>
            Creates instance of the store service 
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.ObjectStoreService.#ctor(System.Guid)">
            <summary>
            Creates instance of the store service with the state identified by "storeGUID". Refer to "StoreGUID" property.
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.ObjectStoreService.ExternalParametersForGroups(System.String[])">
            <summary>
            Returns named parameters that can be used to control this component
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.ObjectStoreService.Fetch(System.Guid,System.Boolean)">
            <summary>
            Retrieves an object reference from the store identified by the "key" or returns null if such object does not exist.
            Object is not going to be persisted as this method provides logical read-only access. If touch=true then object timestamp is updated
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.ObjectStoreService.CheckOut(System.Guid)">
            <summary>
            Retrieves an object reference from the store identified by the "key" or returns null if such object does not exist.
            Object is not going to be persisted until it is checked back in the store using the same number of calls to CheckIn() for the same GUID.
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.ObjectStoreService.CheckIn(System.Guid,System.Object,System.Int32)">
            <summary>
            Puts an object reference "value" into store identified by the "key".
            The object is written in the provider when call count to this method equals to CheckOut() 
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.ObjectStoreService.CheckInUnderNewKey(System.Guid,System.Guid,System.Object,System.Int32)">
            <summary>
            Puts an object reference "value" into store identified by the "oldKey" under the "newKey".
            If oldKey was not checked in, then checks-in under new key as normally would
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.ObjectStoreService.CheckIn(System.Guid,System.Int32)">
            <summary>
            Puts an object back into store identified by the "key".
            The object is written in the provider when call count to this method equals to CheckOut().
            Returns true if object with such id exists and was checked-in
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.ObjectStoreService.Delete(System.Guid)">
            <summary>
            Deletes object identified by key. Returns true when object was found and marked for deletion
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.ObjectStoreService.ExternalGetParameter(System.String,System.Object@,System.String[])">
            <summary>
            Gets external parameter value returning true if parameter was found
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.ObjectStoreService.ExternalSetParameter(System.String,System.Object,System.String[])">
            <summary>
            Sets external parameter value returning true if parameter was found and set
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Volatile.ObjectStoreService.StoreGUID">
            <summary>
            Returns unique identifier that identifies this particular store.
            This ID is used to load store's state from external medium upon start-up.
            One may think of this ID as of a "pointer/handle" that survives phisical object destroy/create cycle 
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Volatile.ObjectStoreService.InstrumentationEnabled">
            <summary>
            Implements IInstrumentable
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Volatile.ObjectStoreService.ExternalParameters">
            <summary>
            Returns named parameters that can be used to control this component
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Volatile.ObjectStoreService.BucketCount">
            <summary>
            Specifies how many buckets objects are kept in. Increasing this number improves thread concurrency
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Volatile.ObjectStoreService.ObjectLifeSpanMS">
            <summary>
            Specifies how long objects live without being touched before becoming evicted from the list
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Volatile.ObjectStoreService.Provider">
            <summary>
            References provider that persists objects
            </summary>
        </member>
        <member name="T:NFX.Collections.NamedInterlocked">
            <summary>
            Provides functionality similar to the Interlocked class executed over a named slot.
            All operations are THREAD-SAFE for calling concurrently.
            The name comparison is that of Registry's which is OrdinalIgnoreCase.
            This class was designed to better organize named counters incremented from different threads,
            i.e. this is needed to keep a count of calls to remote host identified by their names.
            This class is NOT designed for frequent additions/deletions of named slots, nor was it designed
            to keep millions of slots. Use it in cases when there are thousands at most slots and new slots
            appear infrequently. You must delete un-needed slots
            </summary>
        </member>
        <member name="M:NFX.Collections.NamedInterlocked.Clear">
            <summary>
            Deletes all state for all slots
            </summary>
        </member>
        <member name="M:NFX.Collections.NamedInterlocked.Clear(System.String)">
            <summary>
            Deletes all state for the named slot returning true if the slot was found and removed
            </summary>
        </member>
        <member name="M:NFX.Collections.NamedInterlocked.Exists(System.String)">
            <summary>
            Returns true when the instance contains the named slot
            </summary>
        </member>
        <member name="M:NFX.Collections.NamedInterlocked.ReadAtomicLong(System.String)">
            <summary>
             Returns a 64-bit value, loaded as an atomic operation even on a 32bit platform
            </summary>
        </member>
        <member name="M:NFX.Collections.NamedInterlocked.VolatileReadInt(System.String)">
            <summary>
            Captures the current value of a named int value. 
            If slot does not exist, creates it and captures the value (which may be non-zero even if the slot was just created)
            </summary>
        </member>
        <member name="M:NFX.Collections.NamedInterlocked.VolatileReadLong(System.String)">
            <summary>
            Captures the current value of a named long value.  
            If slot does not exist, creates it and captures the value (which may be non-zero even if the slot was just created)
            </summary>
        </member>
        <member name="M:NFX.Collections.NamedInterlocked.ExchangeInt(System.String,System.Int32)">
            <summary>
            Captures the current value of a named int value and atomically sets it to the passed value
            </summary>
        </member>
        <member name="M:NFX.Collections.NamedInterlocked.ExchangeLong(System.String,System.Int64)">
            <summary>
            Captures the current value of a named long value and atomically sets it to the passed value
            </summary>
        </member>
        <member name="P:NFX.Collections.NamedInterlocked.Count">
            <summary>
            Returns the current number of named slots in the instance
            </summary>
        </member>
        <member name="P:NFX.Collections.NamedInterlocked.AllNames">
            <summary>
            Enumerates all slot names. This operation is thread-safe, and returns a snapshot of the instance taken at the time of the first call
            </summary>
        </member>
        <member name="P:NFX.Collections.NamedInterlocked.AllInts">
            <summary>
            Enumerates all named integers. This operation is thread-safe, and returns a snapshot of the instance taken at the time of the first call
            </summary>
        </member>
        <member name="P:NFX.Collections.NamedInterlocked.AllLongs">
            <summary>
            Enumerates all named integers. This operation is thread-safe, and returns a snapshot of the instance taken at the time of the first call
            </summary>
        </member>
        <member name="T:NFX.CoreConsts">
            <summary>
            Central non-lozalizable NFX system consts
            </summary>
        </member>
        <member name="T:NFX.ExternalParameterSecurityCheck">
            <summary>
            Specifies when security permissions should be checked while getting/setting extrenal parameters
            </summary>
        </member>
        <member name="T:NFX.ExternalParameterAttribute">
            <summary>
            Decorates properties that may be used as bindable external parameters.
            Provides methods for extraction of parameter names, values and binding of external object values into 
             public read/write properties decorated by this attribute
            </summary>
        </member>
        <member name="M:NFX.ExternalParameterAttribute.#ctor(System.String[])">
            <summary>
            Provides a list of group names where this parameter applies
            </summary>
        </member>
        <member name="M:NFX.ExternalParameterAttribute.#ctor(System.String,NFX.ExternalParameterSecurityCheck,System.String[])">
            <summary>
            Provides a name override with list of groups names where this parameter applies
            </summary>
        </member>
        <member name="F:NFX.ExternalParameterAttribute.Name">
            <summary>
            Provides name override for external parameter. When this value is not set
             the name is taken from the decorated member name
            </summary>
        </member>
        <member name="F:NFX.ExternalParameterAttribute.SecurityCheck">
            <summary>
            Specifies what security check must be done on get/set
            </summary>
        </member>
        <member name="F:NFX.ExternalParameterAttribute.Groups">
            <summary>
            Returns null or a set of group names where parameter is applicable.
            This is needed to disregard parameters that do not belong to things being managed,
            for example, some parameters may be only set for isntrumentation, not for glue etc.
            </summary>
        </member>
        <member name="M:NFX.ExternalParameterAttribute.GetParameters(System.Object,System.String[])">
            <summary>
            Returns external parameter names and type - names for read/write public properties decorated with this attribute.
            If groups is null then all parameters returned, else parameters must intersect in their group sets with the
            supplied value
            </summary>
        </member>
        <member name="M:NFX.ExternalParameterAttribute.GetParameters(System.Type,System.String[])">
            <summary>
            Returns external parameter names and type - names for read/write public properties decorated with this attribute.
            If groups is null then all parameters returned, else parameters must intersect in their group sets with the
            supplied value
            </summary>
        </member>
        <member name="M:NFX.ExternalParameterAttribute.GetParametersWithAttrs(System.Type,System.String[])">
            <summary>
            Returns external parameter names, type and attributes - names for read/write public properties decorated with this attribute.
            If groups is null then all parameters returned, else parameters must intersect in their group sets with the
            supplied value
            </summary>
        </member>
        <member name="M:NFX.ExternalParameterAttribute.GetParameter(System.Object,System.String,System.Object@,System.String[])">
            <summary>
            Gets instrumentation parameter value returning true if parameter was found.
            Parameter names are case-insensitive.
            If groups is null then all parameters are searched, else parameters must intersect in
            their group sets with the supplied value
            </summary>
        </member>
        <member name="M:NFX.ExternalParameterAttribute.SetParameter(System.Object,System.String,System.Object,System.String[])">
            <summary>
            Sets instrumentation parameter value, true if parameter name was found and set succeeded.
            The property is tried to be set directly to the supplied value first, then, in case of assignment error,
             the value is converted into string then tried to be re-converted to target type.
            Returns true for successful set. Parameter names are case-insensitive.
            If groups is null then all parameters are searched, else parameters must intersect in
            their group sets with the supplied value
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Source.StreamSource">
            <summary>
            Represents source code stored in a stream
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Source.ISourceText">
            <summary>
            Represents source code input text (usually text from file)
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Source.ISourceText.Reset">
            <summary>
            Resets source to beginning
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Source.ISourceText.ReadChar">
            <summary>
            Returns next char and advances position
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Source.ISourceText.PeekChar">
            <summary>
            Returns next char without advancing position
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Source.ISourceText.EOF">
            <summary>
            Indicates whether last character has been read
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Source.ISourceText.Language">
            <summary>
            Indicates what language this source is supplied in
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Source.ISourceText.Name">
            <summary>
            Provides a meaningfull name to a source code 
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Source.StreamSource.#ctor(System.IO.Stream,NFX.CodeAnalysis.Language,System.String)">
            <summary>
            Constructs stream source with specified language and default encoding
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Source.StreamSource.#ctor(System.IO.Stream,System.Text.Encoding,NFX.CodeAnalysis.Language,System.String)">
            <summary>
            Constructs stream source with specified language and encoding
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Source.StreamSource.Name">
            <summary>
            Returns source's name
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.XML.XMLLanguage">
            <summary>
            Represents XML language 
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Language">
            <summary>
            Represents and abstraction of the language
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Language.TryFindLanguageByFileExtension(System.String)">
            <summary>
            Tries to find a language by file extension or returns UnspecifiedLanguage 
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Language.MakeLexer(NFX.CodeAnalysis.IAnalysisContext,NFX.CodeAnalysis.Source.SourceCodeRef,NFX.CodeAnalysis.Source.ISourceText,NFX.CodeAnalysis.MessageList,System.Boolean)">
            <summary>
            Makes lexer capable of this language analysis
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Language.All">
            <summary>
            Returns all languages registered in the system
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Language.Family">
            <summary>
            Returns language family categorization
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Language.FileExtensions">
            <summary>
            Returns file extensions without '.'
            </summary>
        </member>
        <member name="T:NFX.Collections.BitList">
            <summary>
            Provides bit array with automatic resizing
            </summary>
        </member>
        <member name="T:NFX.Collections.BitMatrix2D">
            <summary>
            Provides an efficient access to a square 2D bit matrix accessible as boolean values
            </summary>
        </member>
        <member name="T:NFX.Collections.MatrixBase`1">
            <summary>
            Provides base for various matrices
            </summary>
        </member>
        <member name="M:NFX.Collections.BitMatrix2D.FillSubArea(System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Fills homogeneous sub-area of this square with the specified value
            </summary>
        </member>
        <member name="P:NFX.Collections.BitMatrix2D.Item(System.Int32,System.Int32)">
            <summary>
            Provides access to bit values by X,Y matric coordinates
            </summary>
        </member>
        <member name="T:NFX.Collections.EventPhase">
            <summary>
            Specifies the phase of the event i.e. before/after
            </summary>
        </member>
        <member name="T:NFX.Collections.EventedCollectionGetReadOnlyHandler`1">
            <summary>
            Event handler for list changes
            </summary>
        </member>
        <member name="T:NFX.Collections.EventedCollectionBase`1">
            <summary>
            Provides base implementation for some evented collections
            </summary>
        </member>
        <member name="P:NFX.Collections.EventedCollectionBase`1.ContextReadOnly">
            <summary>
            Returns true to indicate that Context property can not be set (was injected in .ctor only
            </summary>
        </member>
        <member name="P:NFX.Collections.EventedCollectionBase`1.Context">
            <summary>
            Context that this structure works in
            </summary>
        </member>
        <member name="P:NFX.Collections.EventedCollectionBase`1.IsReadOnly">
            <summary>
            Indicates whether collection can be modified
            </summary>
        </member>
        <member name="T:NFX.Collections.EventedDictionary`3">
            <summary>
            Represents a dictionary that rises events
            </summary>
        </member>
        <member name="M:NFX.Collections.EventedDictionary`3.#ctor">
            <summary>
             Initializes a new instance that is empty, has the default initial capacity, and uses the default
             equality comparer for the key type.
             </summary>
        </member>
        <member name="M:NFX.Collections.EventedDictionary`3.#ctor(`2,System.Boolean)">
            <summary>
             Initializes a new instance that is empty, has the default initial capacity, and uses the default
             equality comparer for the key type.
             </summary>
        </member>
        <member name="M:NFX.Collections.EventedDictionary`3.#ctor(`2,System.Boolean,System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            Initializes a new instance that contains elements copied from the specified IDictionary[TKey,TValue]
             and uses the default equality comparer for the key type.
            </summary>
        </member>
        <member name="M:NFX.Collections.EventedDictionary`3.#ctor(`2,System.Boolean,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
              Initializes a new instance that is empty, has the default initial capacity, and uses the specified
                IEqualityComparer[T].
            </summary>
        </member>
        <member name="M:NFX.Collections.EventedDictionary`3.#ctor(`2,System.Boolean,System.Int32)">
            <summary>
            Initializes a new instance that is empty, has the specified initial capacity, and uses the default
              equality comparer for the key type.
            </summary>
        </member>
        <member name="M:NFX.Collections.EventedDictionary`3.#ctor(`2,System.Boolean,System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
             Initializes a new instance that contains elements copied from the specified IDictionary[TKey,TValue]
                and uses the specified IEqualityComparer[T].
            </summary>
        </member>
        <member name="M:NFX.Collections.EventedDictionary`3.#ctor(`2,System.Boolean,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the Dictionary[TKey,TValue]
              class that is empty, has the specified initial capacity, and uses the specified IEqualityComparer[T]
            </summary>
        </member>
        <member name="T:NFX.Collections.EventedDictionary`3.ChangeType">
            <summary>
            Describes changes in evented list
            </summary>
        </member>
        <member name="T:NFX.Collections.EventedList`2">
            <summary>
             Represents list that rises change events
            </summary>
        </member>
        <member name="M:NFX.Collections.EventedList`2.#ctor">
            <summary>
             Initializes a new instance that is empty and has the default initial capacity.
            </summary>    
        </member>
        <member name="M:NFX.Collections.EventedList`2.#ctor(`1,System.Boolean)">
            <summary>
             Initializes a new instance that is empty and has the default initial capacity.
            </summary>    
        </member>
        <member name="M:NFX.Collections.EventedList`2.#ctor(`1,System.Boolean,System.Collections.Generic.IEnumerable{`0})">
            <summary>
             Initializes a new instance that contains elements copied from the specified collection and has sufficient
              capacity to accommodate the number of elements copied.
            </summary>
        </member>
        <member name="M:NFX.Collections.EventedList`2.#ctor(`1,System.Boolean,System.Int32)">
            <summary>
             Initializes a new instance that is empty and has the specified initial capacity.
            </summary>
        </member>
        <member name="T:NFX.Collections.EventedList`2.ChangeType">
            <summary>
            Describes changes in evented list
            </summary>
        </member>
        <member name="T:NFX.Collections.Matrix2D`1">
            <summary>
            Represents a two deminsional matrix of T. 
            This class uses jagged arrays for internal implementation ensuring proper array sizing per matrix structure
            </summary>
            <typeparam name="T">Any desired type</typeparam>
        </member>
        <member name="T:NFX.DataAccess.Cache.CacheRec">
            <summary>
            Stores cached item (such as a business object) along with additional caching information about it.
            The instance of this class gets reused for the same Key, so Key is immutable field.
            The instance of this class is returned by table.Get(key...) so the calling thread may see different Value property with time
            as it may be dynamically changed by some other thread (the newer value for the same Key)
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Bucketed">
            <summary>
            Abstraction of an item that can be placed in hashing bucket
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Cache.CacheRec.ReuseCTOR(System.Object,System.Int32,System.Int32,System.Nullable{System.DateTime})">
            <summary>
            Used as a "constructor" that reuses this class instance to lessen GC burden
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.CacheRec.Key">
            <summary>
            Key is immutable because CacheRec is returned by table.Get(key)
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.CacheRec.Metadata">
            <summary>
            Stores arbitrary information about this item
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Cache.CacheRec.ValueAs``1">
            <summary>
            Returns typecasted value
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.CacheRec.AgeSec">
            <summary>
            Returns an approximate age of the item in seconds - an interval since this item was put into the store for the last time
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.CacheRec.MaxAgeSec">
            <summary>
            Returns positive integer that specifies the maximum lifespan duration for this item expressed in seconds, or zero.
            Zero is returned when this item does not have specific lifespan defined and will be evicted from cache
             per lifespan specified on the table level: Table.MaxAgeSec (default)
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.CacheRec.AbsoluteExpirationUTC">
            <summary>
            Returns absolute expiration timestamp for this item or null
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.CacheRec.Priority">
            <summary>
            Returns an integer value that dictates item priority relative to other items in the same table.
            Priorities play a role during cache collision as an item with higher priority is not going to be replaced
             by an item with lower priority
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.CacheRec.HitCount">
            <summary>
            Returns how many times this cache item was hit (resulted in successfull read)
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.CacheRec.Value">
            <summary>
            Returns the value - a reference to cached item such as a business object
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.CacheStore">
            <summary>
            Represents an efficient in-memory cache of expiring optionally-prioritized objects.
            This class is higly optimized for caching of business objects in data store implementations and does not guarantee that
            all hash collisions are handled, that is - some data may be overridden. The implementation relies on 2 stage hashing, where the second collision replaces the
             existing item with the colliding one if items are equal in their priorities. The degree of collisions is controlled by 'bucketSize' and 'recPerPage' parameters that
             are passed to the store per table, so basically the tables are capped at a certain size and can not change (bucketSize*recPerPage).
            The lookup implementation is 100% lock-free, whereas the degree of mutability-related locking is controlled by 'lockCount' per table.  
            This class is thread safe for reading and writing cache items, however it does not guarantee instant read/write consistency between threads.
            </summary>
            <remarks>
            Perfomance testing of this class vs. System.Runtime.Caching.MemoryCache storing a typical database record identified by a long key:  
             NFX is 2.5-5 times faster for concurrent reads and takes 20% less ram.
             NFX is 1.3-2.5 times faster for writes
            </remarks>
        </member>
        <member name="M:NFX.DataAccess.Cache.CacheStore.ExternalParametersForGroups(System.String[])">
            <summary>
            Returns named parameters that can be used to control this component
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Cache.CacheStore.Configure(NFX.Environment.IConfigSectionNode)">
            <summary>
            Configures store from node, if node==null then store will be configured by named node of 'app/cache/store[name=X]' path, if such path 
            is not found the store tries to find 'app/cache/store[!name]' (node without name)
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Cache.CacheStore.ExternalGetParameter(System.String,System.Object@,System.String[])">
            <summary>
            Gets external parameter value returning true if parameter was found
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Cache.CacheStore.ExternalSetParameter(System.String,System.Object,System.String[])">
            <summary>
            Sets external parameter value returning true if parameter was found and set
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Cache.CacheStore.DropTable(System.String)">
            <summary>
            Drops table by name returning true if it was found and removed
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.CacheStore.Name">
            <summary>
            Returns store name which can be used to identify stores in registries and instrumentation/telemetry outputs
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.CacheStore.Tables">
            <summary>
            Returns all tables that this store currently contains
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.CacheStore.TableOptions">
            <summary>
            Returns table options - used for table creation
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.CacheStore.DefaultTableOptions">
            <summary>
            Sets default options for a table which is not found in TableOptions collection.
            If this property is null then every table assumes the set of constant values defined in Table class
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.CacheStore.Item(System.String)">
            <summary>
            Returns a table by its name creating its' instance if such table is not in the set. Table names are case-insensitive
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.CacheStore.Item(System.String,System.UInt64)">
            <summary>
            Returns a cached record from named table identified by the key or null if this item was not found
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.CacheStore.ParallelSweep">
            <summary>
            When enabled, uses parallel execution while sweeping tables, otherwise sweeps sequentially (default behavior)
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.CacheStore.Count">
            <summary>
            Returns total number of records in all tables in the store
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.CacheStore.InstrumentationEnabled">
            <summary>
            When true, emits instrumentation messages
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.CacheStore.ExternalParameters">
            <summary>
            Returns named parameters that can be used to control this component
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.IULongHashProvider">
            <summary>
            Denotes entities that provide ULONG hash code
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.ComplexKeyHashingStrategy">
            <summary>
            Provides hashing strategy for keys that are not scalar uint64.
            This is a companion class for CacheStore which only understands uint64 as keys for efficiency purposes.
            One may extend this class to implement custom resolution of complex keys into uint64 hashes
            and provide collision handling. The base implementation uses object.GetHashCode() with chaining for collision resolution
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.ComplexKeyHashingStrategy.MAX_CACHE_CHAIN_LENGTH">
            <summary>
            How many times hash will be adjusted while chaining
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.ComplexKeyHashingStrategy.Store">
            <summary>
            References cachestore that this strategy works with
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Cache.ComplexKeyHashingStrategy.DefaultComplexKeyToCacheKey(System.Object)">
            <summary>
            Default implementation that converts complex object to uint64 key. 
            The default implementation returns the hashcode of the object unless the key is string
            in which case it calls DefaultStringKeyToCacheKey() or IULongHashProvider(GDID and parcels).
            The function is not deterministic due to the use of .GetHashCode() that may change between release for some objects (depends on object implementation),
            so the returned value should not be persisted
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Cache.ComplexKeyHashingStrategy.DefaultStringKeyToCacheKey(System.String)">
            <summary>
            Provides default implementation for converting string keys into uint64 hash.
            This functions provides the best selectivity for strings that are 8 chars long or less.
            The function is NOT deterministic as it uses .GetHashCode(), so the returned value should not be persisted
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Cache.ComplexKeyHashingStrategy.ComplexKeyToCacheKey(System.Object)">
            <summary>
            Override to convert complex object to uint64 key. 
            The default implementation returns DefaultComplexKeyToCacheKey(key)
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Cache.ComplexKeyHashingStrategy.Put(System.String,System.Object,System.Object,System.Int32,System.Int32,System.Nullable{System.DateTime})">
            <summary>
            Override to put a value keyed on a non-uint64 scalar into cache. Returns table.Put() result
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Cache.ComplexKeyHashingStrategy.Get(System.String,System.Object,System.Int32)">
            <summary>
            Override to get a value keyed on a non-uint64 scalar from cache. Returns null when item does not exist
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Cache.ComplexKeyHashingStrategy.Remove(System.String,System.Object)">
            <summary>
            Override to remove an item keyed on a non-uint64 scalar from cache. Returns true if remove found and removed item from table
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.CacheLongGauge">
            <summary>
            Provides base for cache long gauges
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.CacheDoubleGauge">
            <summary>
            Provides base for cache double gauges
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.RecordCount">
            <summary>
            Provides record count in the instance
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.PageCount">
            <summary>
            Provides page count in the instance
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.BucketPageLoadFactor">
            <summary>
            Provides the ratio of how many buckets are loaded with pages vs. bucket count
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.HitCount">
            <summary>
            How many times Get() resulted in cache hit
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.MissCount">
            <summary>
            How many times Get() resulted in cache miss
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.ValueFactoryCount">
            <summary>
            How many times factory func was called from GetOrPut()
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.SweepTableCount">
            <summary>
            How many times tables were swept
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.SweepPageCount">
            <summary>
            How many pages swept
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.SweepRemoveCount">
            <summary>
            How many records removed by sweep
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.PutCount">
            <summary>
            How many times Put() was called
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.PutInsertCount">
            <summary>
            How many times a call to Put() resulted in insert
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.PutReplaceCount">
            <summary>
            How many times a call to Put() resulted in relacement of existing item by key without collision
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.PutPageCreateCount">
            <summary>
            How many times a call to Put() resulted in bucket collision that created a page
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.PutCollisionCount">
            <summary>
            How many times a call to Put() resulted in new value overriding existing because of collision (old value lost)
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.PutPriorityPreventedCollisionCount">
            <summary>
            How many times a call to Put() could have resulted in new value overriding existing one because of collision, however the situation was prevented 
            because existing item had higher priority than the newer one
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.RemovePageCount">
            <summary>
            How many pages have been deleted, a page gets deleted when there are no records stored in it
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.RemoveHitCount">
            <summary>
            How many records have been found and removed
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.RemoveMissCount">
            <summary>
            How many records have been sought to be removed but were not found
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Page">
            <summary>
            A composite item that stores collection of CacheRecs and can be placed into a hashing bucket
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Table">
            <summary>
            Represents a table that stores cached items identified by keys
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.Table.stat_HitCount">
            <summary>
            how many hits - get was called
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.Table.stat_ComplexHitCount">
            <summary>
            how many complex key hits - get was called
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.Table.stat_MissCount">
            <summary>
            how many misses - get was called
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.Table.stat_ComplexMissCount">
            <summary>
            how many complex key misses - get was called
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.Table.stat_ValueFactoryCount">
            <summary>
            how many times factory called from GetOrPut
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.Table.stat_SweepTableCount">
            <summary>
            how many times swept
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.Table.stat_SweepPageCount">
            <summary>
            how many pages swept
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.Table.stat_SweepRemoveCount">
            <summary>
            how many records removed by sweep
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.Table.stat_PutCount">
            <summary>
            how many times put was called
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.Table.stat_PutInsertCount">
            <summary>
            how many times new value successfully inserted without collision
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.Table.stat_PutReplaceCount">
            <summary>
            how many times new value successfully replaced existing one (by the same key) without collision
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.Table.stat_PutPageCreateCount">
            <summary>
            how many times bucket collision occured that resulted in page creation
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.Table.stat_PutCollisionCount">
            <summary>
            how many times new value overrode existing because of collision
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.Table.stat_PutPriorityPreventedCollisionCount">
            <summary>
            how many times priority prevented collision
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.Table.stat_RemovePageCount">
            <summary>
            how many pages have been deleted, a page gets deleted when there are no records stored in it
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.Table.stat_RemoveHitCount">
            <summary>
            how many records have been found and removed
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.Table.stat_RemoveMissCount">
            <summary>
            how many records have been sought to be removed but were not found
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Cache.Table.Put(System.UInt64,System.Object,System.Int32,System.Int32,System.Nullable{System.DateTime})">
            <summary>
            Puts a key-identified item into this table.
            If item with such key is already in this table then replaces it and returns false, returns true otherwise
            </summary>
            <param name="key">Item's unique key</param>
            <param name="value">Item</param>
            <param name="maxAgeSec">For how long will the item exist in cache before it gets swept out. Pass 0 to use table-level setting (default)</param>
            <param name="priority">Items priority relative to others in the table used during collision resolution, 0 = default</param>
            <param name="absoluteExpirationUTC">Sets absolute UTC time stamp when item should be swept out of cache, null is default</param>
        </member>
        <member name="M:NFX.DataAccess.Cache.Table.Put(System.UInt64,System.Object,NFX.DataAccess.Cache.CacheRec@,System.Int32,System.Int32,System.Nullable{System.DateTime})">
            <summary>
            Puts a key-identified item into this table.
            If item with such key is already in this table then replaces it and returns false, returns true otherwise
            </summary>
            <param name="key">Item's unique key</param>
            <param name="value">Item</param>
            <param name="rec">Returns new or existing CacheRec</param>
            <param name="maxAgeSec">For how long will the item exist in cache before it gets swept out. Pass 0 to use table-level setting (default)</param>
            <param name="priority">Items priority relative to others in the table used during collision resolution, 0 = default</param>
            <param name="absoluteExpirationUTC">Sets absolute UTC time stamp when item should be swept out of cache, null is default</param>
        </member>
        <member name="M:NFX.DataAccess.Cache.Table.Remove(System.UInt64)">
            <summary>
            Removes a key-identified item from the named table returning true when item was deleted
             or false when item was not found
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Cache.Table.GetOrPut``1(System.UInt64,System.Func{System.String,System.UInt64,``0,System.Object},``0,System.Int32,System.Int32,System.Int32,System.Nullable{System.DateTime})">
            <summary>
            Retrieves an item from this table by key where item age is less or equal to requested, or 
             calls the itemFactory function and inserts the value in the store
            </summary>
            <param name="key">Item key</param>
            <param name="valueFactory">A function that returns new value for the specified tableName, key, and context</param>
            <param name="factoryContext">An object to pass into the factory function if it gets invoked</param>
            <param name="ageSec">Age of item in seconds, or 0 for any age</param>
            <param name="putMaxAgeSec">MaxAge for item if Put is called</param>
            <param name="putPriority">Priority for item if Put is called</param>
            <param name="putAbsoluteExpirationUTC">Absolute expiration UTC timestamp for item if Put is called</param>
            <typeparam name="TContext">A type of item factory context</typeparam>
        </member>
        <member name="M:NFX.DataAccess.Cache.Table.Get(System.UInt64,System.Int32)">
            <summary>
            Retrieves an item from this table by key where item age is less or equal to requested, or null if it does not exist
            </summary>
            <param name="key">Item key</param>
            <param name="ageSec">Age of item in seconds, or 0 for any age</param>
        </member>
        <member name="P:NFX.DataAccess.Cache.Table.Store">
            <summary>
            Returns the store instance that this table is a part of
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.Table.Name">
            <summary>
            Returns table name which is a unique string within the cache store
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.Table.Count">
            <summary>
            Returns item count in the table
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.Table.PageCount">
            <summary>
            Returns page count in the table
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.Table.StatHitCount">
            <summary>
            Returns hit count stats
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.Table.StatComplexHitCount">
            <summary>
            Returns hit count stats for using complex keys
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.Table.StatMissCount">
            <summary>
            Returns miss count stats
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.Table.StatComplexMissCount">
            <summary>
            Returns miss count stats for using complex keys
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.Table.BucketPageLoadFactor">
            <summary>
            Returns the ratio of how many buckets are loaded with pages vs. bucket count
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.Table.Capacity">
            <summary>
            Returns the maximum number of items that this table can hold at any given time given that 
             no items will have any key hash collisions
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.Table.LockCount">
            <summary>
            Returns how many locks can be used for thread coordination during table changes
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.Table.BucketCount">
            <summary>
            Returns how many slots/buckets are pre-allocated per table, the higher the number the more memory will be
            reserved at table construction time, every slot is a reference (4 bytes on 32bit systems, 8 bytes on 64bit).
            For optimal performance this number should be around 75% of total record count stored in the table (table load factor).
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.Table.RecPerPage">
            <summary>
            Returns how many slots are pre-allocated per table's bucket(page) when more than one item produces hash collision.
            The higher the number, the more primary hash collisions can be accomodated by re-hashing on pages (secondary hash table within primary buckets)
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.Table.MaxAgeSec">
            <summary>
            Gets/sets maximum age of items in the table expressed in seconds. After this age is exceeded, the system will delete entries.
            The system does not guarantee that items will expire right on time, however it does guarantee that items will be available for at least
             this long.
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.Table.ParallelSweep">
            <summary>
            When enabled, uses parallel execution while sweeping table buckets, otherwise sweeps sequentially (default behavior)
            </summary>
        </member>
        <member name="T:NFX.CollectionUtils">
            <summary>
            Some helpful extensions for standard collections
            </summary>
        </member>
        <member name="M:NFX.CollectionUtils.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Runs some method over each element of src sequence
            </summary>
            <typeparam name="T">Sequence item type</typeparam>
            <param name="src">Source sequence</param>
            <param name="action">Method to run over each element</param>
            <returns>Source sequence (to have ability to chain similar calls)</returns>
        </member>
        <member name="M:NFX.CollectionUtils.AddRange``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>
            Add all values from range sequence to src IDictionary. Source is actually modified.
            </summary>
            <typeparam name="TKey">Type of key</typeparam>
            <typeparam name="TValue">Type of value</typeparam>
            <param name="src">Source IDictionary (where to add range)</param>
            <param name="range">Sequence that should be added to source IDictionary</param>
            <returns>Source with added elements from range (to have ability to chain operations)</returns>
        </member>
        <member name="T:NFX.DataAccess.Cache.TableCapacity">
            <summary>
            Provides cache table capacity classifications
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.TableCapacity.Default">
            <summary>
            25,111 * 7 = 175,777 items * 64(8/ptr + 40/cache rec + 12/obj over) = 11.25 Mb just for storing empty cache items
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.TableCapacity.Large">
            <summary>
            753,001 * 7 = 5,271,007 items * 64(8/ptr + 40/cache rec + 12/obj over) = 337.3 Mb just for storing empty cache items
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.TableCapacity.XLarge">
            <summary>
            3,337,333 * 7 = 23,361,331 items * 64(8/ptr + 40/cache rec + 12/obj over) = 1.39 Gb just for storing empty cache items
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.TableOptions">
            <summary>
            Provides config options for cache tables
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.FormMode">
            <summary>
            Denotes form modes: unspecified | insert | edit
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.FormModel">
            <summary>
            Represents a "model" (in MVC terms) of a data-entry form.
            Form models are statically typed - contain fields and can contain "extra amorphous" data
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.AmorphousTypedRow">
            <summary>
            Represents a type-safe row of data when schema is known at compile-time that also implements IAmorphousData
            interface that allows this row to store "extra" data that does not comply with the current schema.
            Typed rows store data in instance fields, providing better performance and schema definition compile-time checking than DynamicRows
            at the expense of inability to define schema at runtime
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.TypedRow">
            <summary>
            Represents a type-safe row of data when schema is known at compile-time.
            Typed rows store data in instance fields, providing better performance and schema definition compile-time checking than DynamicRows
            at the expense of inability to define schema at runtime
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.Row">
            <summary>
            Base class for any CRUD row. This class has two direct subtypes - DynamicRow and TypedRow.
            Rows are NOT THREAD SAFE by definition
            </summary>
        </member>
        <member name="T:NFX.Environment.IConfigurationPersistent">
            <summary>
            Designates entities that may persist their parameters/state in configuration
            </summary>
        </member>
        <member name="M:NFX.Environment.IConfigurationPersistent.PersistConfiguration(NFX.Environment.ConfigSectionNode)">
            <summary>
            Persists relevant entities parameters/state into configuration
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.IValidatable">
            <summary>
            Denotes an entity that supports validation
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.IValidatable.Validate(System.String)">
            <summary>
            Validates entity state per particular named target, for performance reasons returns validation exception (instead of throwing)
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.MakeRow(NFX.DataAccess.CRUD.Schema,System.Type)">
            <summary>
            Factory method that makes an appropriate row type.For performance purposes,
             this method does not check passed type for Row-derivation and returns null instead if type was invalid
            </summary>
            <param name="schema">Schema, which is used for creation of DynamicRows and their derivatives</param>
            <param name="tRow">
            A type of row to create, if the type is TypedRow-descending then a parameterless .ctor is called, 
            otherwise a type must have a .ctor that takes schema as a sole argument
            </param>
            <returns>
            Row instance or null if wrong type was passed. For performance purposes,
             this method does not check passed type for Row-derivation and returns null instead if type was invalid
            </returns>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.GetDataStoreKey(System.String)">
            <summary>
            Returns values for fields that represent row's primary key
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.Configure(NFX.Environment.IConfigSectionNode)">
            <summary>
            In base class applies Config attribute. Useful for typed rows
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.PersistConfiguration(NFX.Environment.ConfigSectionNode)">
            <summary>
            The base class does not implement this method. Override to persist row fields into config node
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.Validate">
            <summary>
            Performs validation of data in the row returning exception object that provides description
            in cases when validation does not pass. Validation is performed not targeting any particular backend
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.Validate(System.String)">
            <summary>
            Validates row using row schema and supplied field definitions.
            Override to perform custom validations,
            i.e. TypeRows may directly access properties and write some validation type-safe code
            The method is not expected to throw exception in case of failed validation, rather return exception instance because
             throwing exception really hampers validation performance when many rows need to be validated
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.Equals(NFX.DataAccess.CRUD.Row)">
            <summary>
            Override to perform custom row equality comparison.
            Default implementation equates rows using their key fields
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.Equals(System.Object)">
            <summary>
            Object override - sealed. Override Equals(row) instead
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.GetHashCode">
            <summary>
            Object override - gets hash code from key fields
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.SimpleFilterPredicate(System.String,System.Boolean)">
            <summary>
            Returns true if this row satisfies simple filter - it contains the supplied filter string.
            The filter pattern may start or end with "*" char that denotes a wildcard. A wildcard is permitted on both sides of the filter value
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.GetFieldValue(NFX.DataAccess.CRUD.Schema.FieldDef)">
            <summary>
            Gets value of the field, for typerows it accesses property using reflection; for dynamic rows it reads data from
             row buffer array using field index(order)
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.SetFieldValue(NFX.DataAccess.CRUD.Schema.FieldDef,System.Object)">
            <summary>
            Sets value of the field, for typerows it accesses property using reflection; for dynamic rows it sets data into
             row buffer array using field index(order)
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.ConvertFieldValueToDef(NFX.DataAccess.CRUD.Schema.FieldDef,System.Object)">
            <summary>
            Converts field value to the type specified by Schema.FieldDef. For example converts GDID->ulong or ulong->GDID.
            This method can be overridden to perform custom handling of types,
             for example one can assign bool field as "Si" that would convert to TRUE.
            This method is called by SetFieldValue(...) before assigning actual field buffer 
            </summary>
            <param name="fdef">Field being converted</param>
            <param name="value">Value to convert</param>
            <returns>Converted value before assignment to field buffer</returns>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.ApplyDefaultFieldValues(System.String,System.Boolean)">
            <summary>
            Writes default values specified in schema into fields.
            Pass overwrite=true to force defaults over non-null existing values (false by default)
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.CopyFields(NFX.DataAccess.CRUD.Row,System.Boolean,System.Boolean)">
            <summary>
            Copies fields from this row into another row/form
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.WriteAsJSON(System.IO.TextWriter,System.Int32,NFX.Serialization.JSON.JSONWritingOptions)">
            <summary>
            Writes row as JSON either as an array or map depending on JSONWritingOptions.RowsAsMap setting.
            Do not call this method directly, instead call rowset.ToJSON() or use JSONWriter class
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.ValidateField(System.String,NFX.DataAccess.CRUD.Schema.FieldDef)">
            <summary>
            Validates row field using Schema.FieldDef settings.
            This method is invoked by base Validate() implementation.
            The method is not expected to throw exception in case of failed validation, rather return exception instance because
             throwing exception really hampers validation performance when many rows need to be validated
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Row.Schema">
            <summary>
            References a schema for a table that this row is part of
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Row.Item(System.String)">
            <summary>
            Gets/sets field values by name 
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Row.Item(System.Int32)">
            <summary>
            Gets/sets field values by positional index(Order)
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.TypedRow.Schema">
            <summary>
            References a schema for a table that this row is a part of
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.IAmorphousData">
            <summary>
            Denotes an entity, which is typically a row-derivative, that has extra data fields that are not 
            defined by particular schema and get represented as {name:value} map instead (schema-less data).
            This interface is usually implemented by rows that support version changing between releases, i.e. when
            structured storage (such as Mongo DB) stores more fields than are currently declared in the row the extra fields will be placed 
             in the AmorphousData collection. This interface also provides hook BeforeSave()/AfterLoad() that allow for transforms between
             Amorphous and "hard-schema" data models
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.IAmorphousData.BeforeSave(System.String)">
            <summary>
            Invoked to allow the entity (such as a row) to transform its state into AmorphousData bag.
            For example, this may be usefull to store extra data that is not a part of established business schema.
            The operation is performed per particular targetName (name of physical backend). Simply put, this method allows
             business code to "specify what to do before object gets saved in THE PARTICULAR TARGET backend store"
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.IAmorphousData.AfterLoad(System.String)">
            <summary>
            Invoked to allow the entity (such as a row) to hydrate its fields/state from AmorphousData bag.
            For example, this may be used to reconstruct some temporary object state that is not stored as a part of established business schema.
            The operation is performed per particular targetName (name of physical backend).
            Simply put, this method allows business code to "specify what to do after object gets loaded from THE PARTICULAR TARGET backend store".
            An example: suppose current MongoDB collection stores 3 fields for name, and we want to collapse First/Last/Middle name fields into one field.
            If we change rowschema then it will only contain 1 field which is not present in the database, however those 'older' fields will get populated 
            into AmorphousData giving us an option to merge older 3 fields into 1 within AfterLoad() implementation
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.IAmorphousData.AmorphousDataEnabled">
            <summary>
            When true, enabled amorphous data behaviour, i.e. copying of amorphous data between rows.
            When false, the amorphous data is ignored as-if the type did not implement this interface
            This is needed for security, i.e. on the web returning false will prevent injection via posted forms
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.IAmorphousData.AmorphousData">
            <summary>
            Returns data that does not comply with known schema (dynamic data).
            The field names are NOT case-sensitive
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.AmorphousTypedRow.BeforeSave(System.String)">
            <summary>
            Invoked to allow the row to transform its state into AmorphousData bag.
            For example, this may be usefull to store extra data that is not a part of established business schema.
            The operation is performed per particular targetName (name of physical backend). Simply put, this method allows
             business code to "specify what to do before object gets saved in THE PARTICULAR TARGET backend store"
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.AmorphousTypedRow.AfterLoad(System.String)">
            <summary>
            Invoked to allow the row to hydrate its fields/state from AmorphousData bag.
            For example, this may be used to reconstruct some temporary object state that is not stored as a part of established business schema.
            The operation is performed per particular targetName (name of physical backend).
            Simply put, this method allows business code to "specify what to do after object gets loaded from THE PARTICULAR TARGET backend store".
            An example: suppose current MongoDB collection stores 3 fields for name, and we want to collapse First/Last/Middle name fields into one field.
            If we change rowschema then it will only contain 1 field which is not present in the database, however those 'older' fields will get populated 
            into AmorphousData giving us an option to merge older 3 fields into 1 within AfterLoad() implementation
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.AmorphousTypedRow.AmorphousDataEnabled">
            <summary>
            True by default for rows
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.AmorphousTypedRow.AmorphousData">
            <summary>
            Returns data that does not comply with known schema (dynamic data). The field names are NOT case-sensitive
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FormModel.FormMode">
            <summary>
            Gets/sets form mode - unspecified|insert|edit. This field may be queried by validate and save, i.e. Validate may perform extra cross checks on Insert - i.e. check whether
            some other user is already registered with the specified email in this form etc.
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FormModel.CSRFToken">
            <summary>
            Gets/sets CSRF token
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.FormModel.Save``1(``0@)">
            <summary>
            Saves form into data store. The form is validated first and validation error is returned which indicates that save did not succeed due to validation error/s.
            The core implementation is in DoSave() that can also abort by either returning execption when predictable failure happens on save (i.e. key violation).
            Other exceptions are thrown.
            Returns extra result obtained during save i.e. a db-assigned auto-inc field
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.FormModel.Save(System.Object@)">
            <summary>
            Saves form into data store. The form is validated first and validation error is returned which indicates that save did not succeed due to validation error/s.
            The core implementation is in DoSave() that can also abort by either returning execption when predictable failure happens on save (i.e. key violation).
            Other exceptions are thrown.
            Returns extra result obtained during save i.e. a db-assigned auto-inc field
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.FormModel.DoSave(System.Object@)">
            <summary>
            Override to save model into data store. Return "predictable" exception (such as key violation) as a value instead of throwing.
            Throw only in "un-predictable" cases (such as DB connection is down, not enough space etc...).
            Return extra result obtained during save i.e. a db-assigned auto-inc field
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.FormModel.AmorphousDataEnabled">
            <summary>
            False by default for forms, safer for web. For example, no injection of un-inteded fields can be done via web form post
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.FormModel.DataStoreTargetName">
            <summary>
            Returns the name of data store target obtained from App.DataStore by default.
            Override to supply a different name. This property is used for validation
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.ParcelPayloadWrappingMode">
            <summary>
            Specifies modes of wrapping handling of parcel payload.
            This setting controls whether parcel's payload is sub-serialized into inner byte[].
            When a parcel contains simple data payload (i.e. typed row), then wrapping its content in extra byte[] would
             cause extra overhead in which case NotWrapped mode should be used (default).
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Distributed.ParcelPayloadWrappingMode.NotWrapped">
            <summary>
            The parcel payload will be stored as an object graph which will be completely serialized instead of byte[].
            This option should be used for parcels that have simple structure without many object ref fields and without nesting
             because wrapping parcel content in inner byte[] would cause extra overhead due to simple structure of payload.
             This is the default setting which is applicable to most common cases
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Distributed.ParcelPayloadWrappingMode.Wrapped">
            <summary>
            The parcel payload will be wrapped into byte[] for (re-)transmission efficency.
            Use this setting when parcel contains large object graph with nesting or many reference fields 
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.DataParcelAttribute">
            <summary>
            Decorates Pacel-derivative classes specifying distributed data store options
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.IParcelCachePolicy">
            <summary>
            Stipulates a contract for getting parcel caching options
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.IParcelCachePolicy.CacheWriteMaxAgeSec">
            <summary>
            Specifies for how long should this parcel be cached in RAM after a write (after a parcel gets saved).
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.IParcelCachePolicy.CacheReadMaxAgeSec">
            <summary>
            Specifies the maximum age of parcel instance in cache to be suitable for reading
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.IParcelCachePolicy.CachePriority">
            <summary>
            Specifies the relative cache priority of this parcel
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.IParcelCachePolicy.CacheTableName">
            <summary>
            Specifies the name of the cache table for this parcel
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.IParcelCachePolicy.CacheAbsoluteExpirationUTC">
            <summary>
            Specifies the absolute time when items expires in cache
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.DataParcelAttribute.GetParcelAttr(System.Type)">
            <summary>
            Returns DataParcelAttribute for a parcel type. Use Parcel.MetadataAttribute to 
             obtain the attribute instance polymorphically for instance.
             If parcel is not decorated by the attribute then exception is thrown
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.DataParcelAttribute.SupportsMerge">
            <summary>
            Returns true if parcel supports merge with other versions. 
            Server may merge multiple parcel versions to resolve versioning conflict.
            Default implementation returns false
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.DataParcelAttribute.ShardingParcel">
            <summary>
            Specifies the type of Parcel that is used for sharding. By default this parameter is null, so
            parcels are sharded on their own instance types, however there are cases when a parcel overrides ShardingID
             and specifies ShardingParcel type via this member so it gets stored along with the specified parcel
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.DataParcelAttribute.SchemaName">
            <summary>
            Specifies the name for logical schema that parcel decorated by this attribute belongs to.
            The exact location within the data store is detailed further with AreaName property.
            The value is required and is always specified or exception is thrown in .ctor
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.DataParcelAttribute.AreaName">
            <summary>
            Specifies the Areaname - the logical subdivision in the store where parcels reside within the schema(see SchemaName): i.e.  'commonClinicalData'.
            Depending on a particular store setup this logical name may or may not represent physical servers/locations in the store.
            Every store implementation maps logical paths to physical servers and/or shards. This feature provides very high degree
             of distributed database design flexibility, as some parcels may represent common/dictionary data that does not need to be sharded,
            whereas others may represent purely transactional high-volume data that needs to be sharded.
            The value is required and is always specified or exception is thrown in .ctor
            </summary>
            <remarks>
            Keep in mind that in a distributed database system various parcels may be stored not only in different locations, be optionally sharded,
            and even be stored in different back-end technologies (i.e. NoSQL/RDBMS/flat files)
            </remarks>
        </member>
        <member name="P:NFX.DataAccess.Distributed.DataParcelAttribute.PayloadWrappingMode">
            <summary>
            Specifies modes of wrapping handling of parcel payload.
            This setting controls whether parcel's payload is sub-serialized into inner byte[].
            When a parcel contains simple typed data payload (i.e. typedrow), then wrapping its content in extra byte[] would
             cause extra overhead in which case NotWrapped mode should be used (default).
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.DataParcelAttribute.ReplicationChannel">
            <summary>
            Specifies the name of the replication channel used to pump data between servers/data centers/locations
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.DataParcelAttribute.CacheWriteMaxAgeSec">
            <summary>
            Specifies for how long should this parcel be cached in RAM after a write (after a saved change).
            This property acts as a default, the runtime first checks parcel instance properties then reverts to this attribute 
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.DataParcelAttribute.CacheReadMaxAgeSec">
            <summary>
            Specifies the maximum age of parcel instance in cache to be suitable for reading
            This property acts as a default, the runtime first checks parcel instance properties then reverts to this attribute 
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.DataParcelAttribute.CachePriority">
            <summary>
            Specifies the relative cache priority of this parcel
            This property acts as a default, the runtime first checks parcel instance properties then reverts to this attribute 
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.DataParcelAttribute.CacheTableName">
            <summary>
            Specifies the name of the cache table for this parcel
            This property acts as a default, the runtime first checks parcel instance properties then reverts to this attribute 
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.DataParcelAttribute.CacheAbsoluteExpirationUTC">
            <summary>
            This property can not be set on the attribute level and always returns null
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.Command">
            <summary>
            Defines a command sent into IDistributedDataStore implementor to retrieve or change data.
            A Command is a named bag of paremeters where every parameter has a name and a value 
            </summary>
        </member>
        <member name="T:NFX.IParameters">
            <summary>
            Represents abstract parameters bag
            </summary>
        </member>
        <member name="M:NFX.IParameters.ParamByName(System.String)">
            <summary>
            Returns a parameter found by name or throws exception if it could not be found
            </summary>
        </member>
        <member name="M:NFX.IParameters.FindParamByName(System.String)">
            <summary>
            Tries to find parameter by name and returns null if parameter could not be found
            </summary>
        </member>
        <member name="P:NFX.IParameters.AllParameters">
            <summary>
            Enumerates all parameters
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.IShardingIDProvider">
            <summary>
            Denotes an entity which provides a sharding ID that can be used to determine 
            data location via conversion of this id into physical shard #(particular server) that this entity represents
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.IShardingIDProvider.ShardingID">
            <summary>
            Returns the ID used for sharding. This id is converted into physical shard # (particular server) where
            data represented by this entity resides. 
            WARNING! The ShardingID is immutable during the lifecycle of the entity. See Parcel.ShardingID
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Command.Name">
            <summary>
            Returns Command name, providers use it to locate modules particular to backend implementation that they represent
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Command.ShardingParcel">
            <summary>
            Returns the type of parcel that sharding is performed on or null.
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Command.ShardingID">
            <summary>
            Returns the ID used for sharding or null
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Command.Item(System.String)">
            <summary>
            Returns parameter by its name or null
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.Command.Param">
            <summary>
            Represents a distributed command parameter
            </summary>
        </member>
        <member name="T:NFX.IParameter">
            <summary>
            Represents abstract parameter
            </summary>
        </member>
        <member name="P:NFX.IParameter.Value">
            <summary>
            Parameter Value
            </summary>
        </member>
        <member name="P:NFX.IParameter.HasValue">
            <summary>
            Indicates whether parameter has a value, even if Value==null parameter may or 
             may not have a value (be assigned) in some scenarious
            </summary>
        </member>
        <member name="P:NFX.IParameter.IsInput">
            <summary>
            Indicates whether parameter is purposed as an input for a target 
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Command.Param.Equals(System.Object)">
            <summary>
            Equates param by name and values
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.Command.PList">
            <summary>
            Used to denote a list of values in command params, use this class instead of array as it gives better hash distribution
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.DistributedDataAccessException">
            <summary>
            Thrown by distributed data access classes
            </summary>
        </member>
        <member name="T:NFX.DataAccess.DataAccessException">
            <summary>
            Thrown by data access classes
            </summary>
        </member>
        <member name="F:NFX.DataAccess.DataAccessException.KeyViolationKind">
            <summary>
            Spcifies the sub-type of key violation
            </summary>
        </member>
        <member name="F:NFX.DataAccess.DataAccessException.KeyViolation">
            <summary>
            Provides the name of entity/index/field that was violated and resulted in this exception
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.DistributedDataParcelSerializationException">
            <summary>
            Thrown by distributed data access classes when parcel serialization problems happen
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.ParcelValidationException">
            <summary>
            Thrown by distributed data access classes  to indicate some data validation error
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.ParcelSealValidationException">
            <summary>
            Thrown by Parcel.Seal() method trying to ensure parcel consistency before it gets sealed
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.GDID">
            <summary>
            Represents a Global Distributed ID key (key field) used in distributed databases that identify entities with a combination of unsigned 32 bit integer
             'Era' and unsigned 64 bit integer 'ID'. The first 32 bit integer is an 'era' in which the 'ID' (64 bit) was created, consequently
            a GDID is a 12 byte = 96 bit integer that can hold 2^96 = 79,228,162,514,264,337,593,543,950,336 combinations. 
            The ID consists of two segments: 4 bit authority + 60 bits counter. Authority segment occupies the most significant 4 bits of uint64, so
             the system may efficiently query the data store to identify the highest stored ID value in a range.
            Authorities identify one of 16 possible ID generation sources in the global distributed system, therefore ID duplications are not 
            possible between authorities. 
            Within a single era, GDID structure may identify 2^60 = 1,152,921,504,606,846,976(per authority) * 16(authorities) = 2^64 = 18,446,744,073,709,551,616 total combinations.
            Because of such a large number of combinations supported by GDID.ID alone (having the same Era), some systems may always use Era=0 and only store the ID part 
            (i.e. as UNSIGNED BIGINT in SQL datastores)
            </summary>
        </member>
        <member name="T:NFX.DataAccess.IDataStoreKey">
            <summary>
            Decorator interface for entities used to uniquely identify entities in a store
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Distributed.GDID.COUNTER_MAX">
            <summary>
            Provides maximum value for counter segment
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Distributed.GDID.AUTHORITY_MAX">
            <summary>
            Provides maximum value for authority segment
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Distributed.GDID.Zero">
            <summary>
            Zero GDID singleton
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.GDID.Authority">
            <summary>
            Returns the 0..15 index of the authority that issued this ID
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.GDID.Counter">
            <summary>
            Returns the 60 bits of counter segment of this id (without athority segment upper 4 bits)
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.GDID.Bytes">
            <summary>
            Returns the GDID buffer as BigEndian Era:ID tuple
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.IDistributedDataStore">
            <summary>
            Represents a data store that works with large distributed systems that support OLTP-style processing
            and provide data querying, caching, partitioning/sharding, failover and replication.
            These systems are designed to handle billions of rows that need to be accessed by millions of active concurrent users,
             so the design is specific to this model that scales horizontally. There is no need to use this technology for medium and smaller data stores
             as it imposes specific requirements on how application is written/interacts with the backend system. This technology is based on the idea
             of Parcels - an atomic unit of data change. Parcels get replicated between hosts for failover and performance reasons.
            Note: 
             NFX library does not provide the implementation for this technology, only marker interfaces so developers can plan for distributed backends
             in future
            </summary>
            <remarks>
            The structure of distributed data store:
            
             +------------------------------------------------------------------------------------------------------------+
             |                                            Data Store                                                      |
             |  +-------------------------------------------------------------------------+      +---------------------+  |
             |  |                             Bank = N 1 (Schema A)                       |      |      Bank   =  N 2  |  |
             |  | +----------+ +--------------------------------------------------------+ |      |      (Schema A)     |  |
             |  | |   Area   | +                 Area "UserData"                        | | ...  |                     |  |
             |  | | "common" | +-----------+-----------+-----------+-----------+--------+ |      |                     |  |
             |  | |          | +  Shard 1  |  Shard 2  |  Shard 3  |  Shard 4  |          |      |                     |  |
             |  | +----------+ |           |           |           |           |          |      +---------------------+  |
             |  |              +-----------+           |           |           |          |      +---------------------+  |
             |  | +----------------------+ |           +-----------+           |          |      |      Bank   =  N X  |  |
             |  | |Area "clinicalData"   | |           |           |           |          |      |      (Schema B)     |  |
             |  | |       /doctors       | |           |           |           |          | ...  |                     |  |
             |  | |       /codes         | |           |           |           |          |      |                     |  |
             |  | |       /diagnoses     | |           |           +-----------+          |      |                     |  |
             |  | +----------------------+ |           |                                  |      +---------------------+  |
             |  |                          +-----------+                                  |                               |
             |  +-------------------------------------------------------------------------+                               |
             +------------------------------------------------------------------------------------------------------------+
            Distributed data stores hold single or multiple named data banks instances: Bank = global data bank name, a named instance of a distributed database.
            Banks are logical isolation containers in large datasets. Store implementations may use it for physical isolation as well.
            Every bank implements a particular schema - a structure suitable for some business purpose.
            A store may support multiple schemas, but every particular database bank implements only one schema.
            Named instances of database banks with the same schema may be used to house data for different clients or environments. 
            Bank name example: "PROD-Data", "DEV-Data", "EnterpriseA", "CustomerX" etc.
            
            Every Bank is further broken down by Areas that can be accessed/addressed by their names.
            Areas contain shards that partition large volumes of data horizontally, they define how data is partitioned and where it is stored
            </remarks>
        </member>
        <member name="T:NFX.DataAccess.IDataStore">
            <summary>
            Represents a store that can save and retrieve data 
            </summary>
        </member>
        <member name="M:NFX.DataAccess.IDataStore.TestConnection">
            <summary>
            Tests connection and throws an exception if connection could not be established 
            </summary>
        </member>
        <member name="P:NFX.DataAccess.IDataStore.TargetName">
            <summary>
            Returns the name of the underlying store technology, i.e. "ORACLE".
            This property is used by some metadata-based validation logic which is target-dependent
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.IDistributedDataStore.BankNames(System.String)">
            <summary>
            Returns names of database bank instances in the store that implement the specified schema
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.IDistributedDataStore.GetBank(System.String,System.String)">
            <summary>
            Returns Bank object by name within schema
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.IDistributedDataStore.SchemaNames">
            <summary>
            Returns names of database bank schemas supported by the store.
            Every bank implements a particular schema
            </summary>
        </member>
        <member name="T:NFX.DataAccess.IDataStoreImplementation">
            <summary>
            Represents a store that can save and retrieve data 
            </summary>
        </member>
        <member name="P:NFX.DataAccess.IDataStoreImplementation.LogLevel">
            <summary>
            Defines log level for data stores
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.ISchema">
            <summary>
            Provides information about schema of data store banks. Schema defines areas of the bank, where every area
             defines what parcel types can be stored. Each bank implements only one bank schema
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.ISchema.DataStore">
            <summary>
            References data store that this schema is a part of
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.ISchema.Areas">
            <summary>
            Returns registry of named schema areas
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.IArea">
            <summary>
            Provides information about an area of a bank schema. This information does not depend on a particular bank instance,
             as it is common for all banks that implement the same schema.
            Area provides configuration information for parcels that it can store.
            Every instance of this (interface-implementer) class has a corresponding IAreaInstance instance that stores information
             for every particular bank, i.e. what distribution policies are applied (such as sharding) to the parcels stored in this area 
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.IArea.Schema">
            <summary>
            Returns schema that this area is in
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.IArea.Description">
            <summary>
            Returns area description
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.IArea.DeviceType">
            <summary>
            Returns the type of device driver that loads/stores data
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.DataVeracity">
            <summary>
            Stipulates levels of data fidality, the higher the level - the more accurately verified data is provided
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Distributed.DataVeracity.Maximum">
            <summary>
            The highest level of data accuracy - the backend will compare data from multiple storage mediums/devices to calculate the most accurate/latest data.
            This mode is the slowest among the others
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Distributed.DataVeracity.BackedUp">
            <summary>
            The backend will return the data which is stored in more than one device/medium
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Distributed.DataVeracity.Any">
            <summary>
            The backend will return the fist available data as soon as it finds it. This mode is the fastest however it may return
            data that has since been overwritten in some other storage devices/mediums.
            This mode may be used in cases when performance is paramount but 100% data accuracy is not really needed, i.e. when showing
            message/forum post comments on a social web site
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.DataCaching">
            <summary>
            Stipulates where data gets cached
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Distributed.DataCaching.None">
            <summary>
            Does not get cached
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Distributed.DataCaching.LatestData">
            <summary>
            Gets cached on the level where data is always accurate and never gets stale, i.e. in the BDB server that reflects most recent changes (can not get out of date)
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Distributed.DataCaching.Everywhere">
            <summary>
            Gets cached everywhere including system tiers where data can get stale
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.IQueryResult">
            <summary>
            Denotes query result returned from bank query execution
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.IBank">
            <summary>
            Provides abstraction for Global Database Bank instance
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.IBank.GetDescription(System.String)">
            <summary>
            Returns database description for the specific culture.
            This method is needed because end users may need to see the description of the database instance in their native language
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.IBank.GenerateReplicationVersionInfo(NFX.DataAccess.Distributed.Parcel)">
            <summary>
            Generates version replication information for the parcel instance which is being sealed
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.IBank.ObjectToShardingID(System.Object)">
            <summary>
            Returns ULONG(convertible to gdid) for an object so any object (i.e. a string) may be used as a sharding key.
            Suppose a string needs to be used for sharding, this method translates a string into a 64 bit hash expressed as ulong/GDID 
            </summary>
            <param name="key">An object used for sharding ID translation</param>
            <returns>UInt64 that represents the sharding ID</returns>
        </member>
        <member name="M:NFX.DataAccess.Distributed.IBank.LoadByID``1(NFX.DataAccess.Distributed.GDID,System.Object,NFX.DataAccess.Distributed.DataVeracity,NFX.DataAccess.Distributed.DataCaching,System.Nullable{System.Int32})">
            <summary>
            Loads parcel by fetching it from the bank backened by its primary id
            </summary>
            <param name="id">The unique GDID of the parcel</param>
            <param name="shardingID">
            The ID of the entity used for sharding, 
            i.e. a message may use ID of the item that the message relates to, so messages get sharded in the same location as their "parent" record.
            The parcel type T specifies the DataParcelAttirbute.GetParcelAttr(tyepof(T)).ShardingParcel
            </param>
            <param name="veracity">The level of data veracity</param>
            <param name="cacheOpt">The cache control options</param>
            <param name="cacheMaxAgeSec">The maximum acceptable age of cached instance, cached data will be re-queried from backend if it is older</param>
        </member>
        <member name="M:NFX.DataAccess.Distributed.IBank.LoadByIDAsync``1(NFX.DataAccess.Distributed.GDID,System.Object,NFX.DataAccess.Distributed.DataVeracity,NFX.DataAccess.Distributed.DataCaching,System.Nullable{System.Int32})">
            <summary>
            Async version: Loads parcel by fetching it from the bank backened by its primary id
            </summary>
            <param name="id">The unique GDID of the parcel</param>
            <param name="shardingID">
            The ID of the entity used for sharding, 
            i.e. a message may use ID of the item that the message relates to, so messages get sharded in the same location as their "parent" record.
            The parcel type T specifies the DataParcelAttirbute.GetParcelAttr(tyepof(T)).ShardingParcel
            </param>
            <param name="veracity">The level of data veracity</param>
            <param name="cacheOpt">The cache control options</param>
            <param name="cacheMaxAgeSec">The maximum acceptable age of cached instance, cached data will be re-queried from backend if it is older</param>
        </member>
        <member name="M:NFX.DataAccess.Distributed.IBank.LoadByQuery(NFX.DataAccess.Distributed.Command,NFX.DataAccess.Distributed.DataVeracity,NFX.DataAccess.Distributed.DataCaching,System.Nullable{System.Int32})">
            <summary>
            Loads parcel by executing a query command in the bank backend fetching necessary parcel by keys/params other than primary ID.
            The returned value is a single parcel (or null if not found), which could be modified/saved back
            </summary>
            <param name="loadCommand">The command object that contains command name and parameters to query the datastore</param>
            <param name="veracity">The level of data veracity</param>
            <param name="cacheOpt">The cache control options</param>
            <param name="cacheMaxAgeSec">The maximum acceptable age of cached instance, cached data will be re-queried from backend if it is older</param>
        </member>
        <member name="M:NFX.DataAccess.Distributed.IBank.LoadByQueryAsync(NFX.DataAccess.Distributed.Command,NFX.DataAccess.Distributed.DataVeracity,NFX.DataAccess.Distributed.DataCaching,System.Nullable{System.Int32})">
            <summary>
            Async version: Loads parcel by executing a query command in the bank backend fetching necessary parcel by keys/params other than primary ID.
            The returned value is a single parcel (or null if not found), which could be modified/saved back
            </summary>
            <param name="loadCommand">The command object that contains command name and parameters to query the datastore</param>
            <param name="veracity">The level of data veracity</param>
            <param name="cacheOpt">The cache control options</param>
            <param name="cacheMaxAgeSec">The maximum acceptable age of cached instance, cached data will be re-queried from backend if it is older</param>
        </member>
        <member name="M:NFX.DataAccess.Distributed.IBank.Query(NFX.DataAccess.Distributed.Command,NFX.DataAccess.Distributed.DataVeracity,NFX.DataAccess.Distributed.DataCaching,System.Nullable{System.Int32})">
            <summary>
            Loads IQueryResult by executing a query command in the bank backend fetching necessary parcels/records/documents and aggregating the result
            </summary>
            <param name="command">The command object that contains command name and parameters to query the datastore</param>
            <param name="veracity">The level of data veracity</param>
            <param name="cacheOpt">The cache control options</param>
            <param name="cacheMaxAgeSec">The maximum acceptable age of cached instance, cached data will be re-queried from backend if it is older</param>
        </member>
        <member name="M:NFX.DataAccess.Distributed.IBank.QueryAsync(NFX.DataAccess.Distributed.Command,NFX.DataAccess.Distributed.DataVeracity,NFX.DataAccess.Distributed.DataCaching,System.Nullable{System.Int32})">
            <summary>
            Async version: Loads IQueryResult by executing a query command in the bank backend fetching necessary parcels/records/documents and aggregating the result
            </summary>
            <param name="command">The command object that contains command name and parameters to query the datastore</param>
            <param name="veracity">The level of data veracity</param>
            <param name="cacheOpt">The cache control options</param>
            <param name="cacheMaxAgeSec">The maximum acceptable age of cached instance, cached data will be re-queried from backend if it is older</param>
        </member>
        <member name="M:NFX.DataAccess.Distributed.IBank.Save(NFX.DataAccess.Distributed.Parcel,NFX.DataAccess.Distributed.DataCaching,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.DateTime})">
             <summary>
             Saves/sends the parcel into this bank
             </summary>
             <param name="parcel">parcel instance to save</param>
             <param name="cacheOpt">The cache control options</param>
             <param name="cachePriority">
             The relative priority of the item in cache.
             If null is passed then the value is obtained from the parcel instance
             </param>
             <param name="cacheMaxAgeSec">
             Specifies the duration of parcel lifespan in cache devices.
             If null is passed then the value is obtained from the parcel instance
             </param>
            <param name="cacheAbsoluteExpirationUTC">
             Specifies absolute expiration time for this parcel instance in cache.
             If null is passed then the value is obtained from the parcel instance
             </param>
        </member>
        <member name="M:NFX.DataAccess.Distributed.IBank.SaveAsync(NFX.DataAccess.Distributed.Parcel,NFX.DataAccess.Distributed.DataCaching,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.DateTime})">
             <summary>
             Async version: Saves/sends the parcel into this bank
             </summary>
             <param name="parcel">parcel instance to save</param>
             <param name="cacheOpt">The cache control options</param>
             <param name="cachePriority">
             The relative priority of the item in cache.
             If null is passed then the value is obtained from the parcel instance
             </param>
             <param name="cacheMaxAgeSec">
             Specifies the duration of parcel lifespan in cache devices.
             If null is passed then the value is obtained from the parcel instance
             </param>
            <param name="cacheAbsoluteExpirationUTC">
             Specifies absolute expiration time for this parcel instance in cache.
             If null is passed then the value is obtained from the parcel instance
             </param>
        </member>
        <member name="M:NFX.DataAccess.Distributed.IBank.Remove``1(NFX.DataAccess.Distributed.GDID,System.Object)">
            <summary>
            Removes the parcel from the bank returning true if parcel was found and removed
            </summary>
            <param name="id">The unique GDID of the parcel</param>
            <param name="shardingID">
            The ID of the entity used for sharding, 
            i.e. a message may use ID of the item that the message relates to, so messages get sharded in the same location as their "parent" record.
            The parcel type T specifies the DataParcelAttirbute.ShardingParcel
            </param>
        </member>
        <member name="M:NFX.DataAccess.Distributed.IBank.RemoveAsync``1(NFX.DataAccess.Distributed.GDID,System.Object)">
            <summary>
            Async version: Removes the parcel from the bank returning true if parcel was found and removed
            </summary>
            <param name="id">The unique GDID of the parcel</param>
            <param name="shardingID">
            The ID of the entity used for sharding, 
            i.e. a message may use ID of the item that the message relates to, so messages get sharded in the same location as their "parent" record.
            The parcel type T specifies the DataParcelAttirbute.ShardingParcel
            </param>
        </member>
        <member name="P:NFX.DataAccess.Distributed.IBank.DataStore">
            <summary>
            References data store that this data bank is a part of
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.IBank.Schema">
            <summary>
            Returns the schema that this bank implements
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.IBank.Areas">
            <summary>
            Returns registry of named bank schema area instances
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.IBank.Description">
            <summary>
            Returns database description
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.IBank.IDGenerator">
            <summary>
            Returns sequence provider that generates unique identifiers in the store
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.IAreaInstance">
            <summary>
            Represents data for a concrete instance of schema area within banks, this depends on a concrete bank instance (unlike it's complementary part IArea)
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.IAreaInstance.Area">
            <summary>
            Returns schema area that this bank area represents - a prototype of this instance
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.IAreaInstance.Bank">
            <summary>
            Returns bank instance that this area is in
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.IReplicatable">
            <summary>
            Denotes a distributed entity that can be replicated to a different location/site/instance.
            Normally only Parcel and its derivatives should implement this interface
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.IReplicatable.ReplicationVersionInfo">
            <summary>
            Provides the information about this version of data that this isntance represents.
            Usually this object contains the name of the user who made a change, server/cluster node ID and/or machine name  
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.IReplicatable.ReplicationPriority">
            <summary>
            Returns the relative priority of replication, where 0=highest priority 
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.IReplicationVersionInfo.VersionDeleted">
            <summary>
            Returns true for items that have been marked for deletion
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.IReplicationVersionInfo.VersionUTCTimestamp">
            <summary>
            Provides a UTC timestamp for this version - when last change was made
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.ParcelCachePolicyData">
            <summary>
            Holds data per IParcelCachePolicy contract 
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.ParcelState">
            <summary>
            Represents data parcel states - creating, modifying, sealed
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.Parcel">
            <summary>
            Describes a data parcel - a piece of logically-grouped data that gets fetched from/comitted into a distributed backend system.
            Parcels represent an atomic unit of change, a changeset that gets replicated between failover hosts.
            Every parcel has a Payload property that stores business data of interest that the parcel contains.
            This class is designed in such way that Payload property (unwrapped data) is not serialized, instead a byte[](wrapped data) is serialized.
            This is needed because an instance of Parcel may travel between many hosts that do not need to serialize/deserialize possibly complex business
            object that parcel contains.
            Parcels wrap their payload - when parcels get transported between hosts only parcel metadata (Parcel class fields) get serialized/deserialized by 
            hosts in the data supply chain, so metadata is available for tasks like parcel routing and cache policy adjustment, but the business data (the payload) must be 
            unwrapped first before it can be used. This design promotes efficient storage in distributed cache systems, i.e. the data origination host may keep cached version
            in an unwrapped state (not serialized) so business payload is ready for access right away without deserialization. 
            On the other hand, the intermediary parcel relays do not need to deserialize/serialize payload every time as it may be complex and waste significant processing time.
            This class is not thread-safe. Use DeepClone() to create 100% copies for working in multiple threads.
            This particular class serves as a very base for all Parcel implementations 
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Distributed.Parcel.STANDARD_SLIM_PAYLOAD_FORMAT">
            <summary>
            Denotes a payload serialization format that uses Slim with standard(to this class) type registry
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Distributed.Parcel.STANDARD_PODSLIM_PAYLOAD_FORMAT">
            <summary>
            Denotes a payload serialization format that uses PODSlim (Portable Object Document + Slim) with standard(to this class) type registry
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Distributed.Parcel.DEFAULT_REPLICATION_PRIORITY">
            <summary>
            Default priority of replication
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Distributed.Parcel.STANDARD_KNOWN_SERIALIZER_TYPES">
            <summary>
            Defines well-known frequently used types for slim serializer compression
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.GetParcelCacheTableName(System.Type)">
            <summary>
            Obtains parcel cache name from either it's associated DataParcelAttribute or 
             if not defined, from parcel type full name. Keep in mind, that a parcel instance may dynamicaly sypply a
             different name for CacheTable so the store may need to search in alternative cache tables
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.#ctor">
            <summary>
            Used by serialization
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.#ctor(NFX.DataAccess.Distributed.GDID,System.Object)">
            <summary>
            Called when creating new Parcel instances by the original author.
            The new instance is in 'ParcelState.Creating' state
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.#ctor(NFX.DataAccess.Distributed.GDID,System.Object,NFX.DataAccess.Distributed.IReplicationVersionInfo)">
            <summary>
            Called by device to load parcel from storage. 
            The new instance is in 'ParcelState.Sealed' state.
            Business logic devs - do not call 
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.Open">
            <summary>
            Opens parcel for modification. Parcel must be in the Sealed state for this call and must not be ReadOnly.
            Once open for modification, a parcel can not be "UnOpened", only Seal()-ed. This is because there is no way to track
            whether some part of payload object has changed by the calling code. Use DeepClone() before calling Open to retain a copy of Sealed parcel
            to revert to the cloned instance instead
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.Seal(NFX.DataAccess.Distributed.IBank)">
            <summary>
            Seal parcel after modification
            May call this method on parcels in either Creating or Modifying states.
            Bank is used to create the ReplicationVersionInfo which is depends on store/bank implementation.
            Parcels can replicate only within stores/technologies that have sealed them
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.Merge(System.Collections.Generic.IEnumerable{NFX.DataAccess.Distributed.Parcel})">
            <summary>
            Merges other parcel instances into this one. 
            A parcel type may support merging (when DataParcel attribute SupportsMerge is set to true) of data from other parcels/versions into this instance.
            This parcel must not be sealed as merge may change the payload in which case TRUE is returned. The parcel needs to be sealed again after the change.
            If a call to this method returns false, then nothing was changed as this instance already contains the latest data/could not be merged.
            Merging is used for version conflict resolution: servers check if the type of the updated parcel instance SupportsMerge, then if it does, Opens parcel 
            and calls this method passing other versions in question to this method. The framework does not impose a limit on the supplied parcel types, however 
            most of the parcel types support merge only with the same-typed parcel instances.
            IMPORTANT: The ordering of parcel versions is not guaranteed. 
            </summary>
            <param name="others">Other parcel versions/data</param>
            <returns>True if Merge() generated newer version/changed payload. False when Merge did not/could not change existing parcel</returns>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.Validate(NFX.DataAccess.Distributed.IBank)">
            <summary>
            Performs validation of the data. Does not throw but populates validation exceptions if data is not valid.
            Bank context may be used to run sub-queries during consistency/crosschecks
            May call this method on parcels in either Creating or Modifying states
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.ForgetWrappedPayloadCopy">
            <summary>
            Forgets wrapped payload copy by deallocating byte[] that stores serialized payload.
            If parcel is ParcelPayloadWrappingMode.NotWrapped then forgets a reference to payload data which is transmitted(serialized).
            This method is usually used by business code after Parcel instance gets sent to backend, then this method is called, then
             the instance gets written into local in-memory field/cache (same process address space).
            WARNING!!! Parcel instances are NOT thread-safe, they can not be mutated by multiple threads at the same time, so
             if a parcel instance needs to be cached for subsequent parallel modifications then DeepClone() should be used.
             DeepClone() will recreate the wrapped payload buffer, so this method does not need to be called in this case
            Parcel must be in a Sealed state for this call
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.ForgetPayloadCopy">
            <summary>
            Forgets the unwrapped payload object graph.
            This method is used by cache store that holds data in byte[] anyway because it needs to do DeepClone() for cache hits,
             consequently the redundant object graph is not needed.
            Parcel must be in a Sealed state for this call 
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.DeepClone">
            <summary>
            Duplicates this parcel by doing a complete deep-clone of its state via serialization.
            This method is useful for making copies of the same parcel for different threads as it is thread-safe while no other thread mutates the instance,
            however Parcel instances are NOT THREAD-SAFE for parallel changes.
            The existing parcel MUST be SEALED (otherwise it can not be serialized).
            This method is also used before a call to Open() if parcel needs to be "un-opened" the cloned instance may be reverted to
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.Equals(System.Object)">
            <summary>
            Tests for parcel equality based on the same type and GDID value
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.GetHashCode">
            <summary>
            Generates hash code based on parcel type and GDID value
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.EnsurePayloadUnwrapped">
            <summary>
            Checks to see if payload is already unwrapped and does nothing if it is.
            Otherwise, unwraps the payload by deserializing byte[] stream into payload object.
            If this parcel is ParcelPayloadWrappingMode.NotWrapped then just swaps references.
            Parcel must be in a Sealed state for this call
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.EnsurePayloadWrappedCopy">
            <summary>
            Checks to see if payload wrapped copy is present and does nothing if it is.
            Otherwise, wraps the payload by serializing payload into a byte[], thus creating payload copy for wire transmission.
            If this parcel is ParcelPayloadWrappingMode.NotWrapped then just swaps references.
            Parcel must be in a Sealed state for this call
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.DoUnwrapPayload">
            <summary>
            Called only if this parcel is ParcelPayloadWrappingMode.Wrapped.
            Override to perform custom content deserialization, i.e. when particular store may use special format for data marshalling.
            Base implementation understands  Parcel.STANDARD_SLIM_PAYLOAD_FORMAT and Parcel.STANDARD_PODSLIM_PAYLOAD_FORMAT formats
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.DoWrapPayloadCopy(System.String@)">
            <summary>
            Called only if this parcel is ParcelPayloadWrappingMode.Wrapped.
            Override to perform custom content serialization, i.e. when particular store may use special format for data marshalling.
            Base implementation uses  Parcel.STANDARD_SLIM_PAYLOAD_FORMAT with SlimSerializer
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.GetEstimatedWrappedPayloadBufferSize">
            <summary>
            Override to provide a better estimate for buffer size needed to serialize the Payload instance into WrappedPayload which is a byte[].
            Used by cloning and wrapped payload serialization. 
            This implementation returns default buffer size if wrapped payload is null
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.OnBeforePayloadUnwrap">
            <summary>
            Override to initialize internal Parcel state right before payload gets unwrapped - deserialized from byte[], 
             i.e.  this may be used to clear some internal fields. Base implementation does nothing
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.OnAfterPayloadUnwrap">
            <summary>
            Override to initialize internal Parcel state right after payload gets unwrapped - deserialized from byte[], 
             i.e.  this may be used to cache or clear some internal fields. Base implementation does nothing
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.OnBeforePayloadWrap">
            <summary>
            Override to initialize internal Parcel state right before payload gets wrapped - serialized into byte[], 
             i.e.  this may be used to set some internal fields used for caching, i.e. copy user rating field from complex user object(payload)
            which will be wrapped into byte[] into separate field that may influence Parcel caching policy. Base implementation does nothing  
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.OnAfterPayloadWrap">
            <summary>
            Override to initialize internal Parcel state right after payload gets wrapped - serialized into byte[], 
             i.e.  this may be used to clear some internal fields. Base implementation does nothing
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.DoOpen">
            <summary>
            Override to perform actions when parcel is unsealed (opened) for modification
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.DoSeal(NFX.DataAccess.Distributed.IBank)">
            <summary>
            Override to seal the parcel instance, i.e. generate some calculated fields.
            The version information is already generated by the time this method is called
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.DoMerge(System.Collections.Generic.IEnumerable{NFX.DataAccess.Distributed.Parcel})">
            <summary>
            Override to merge other parcels into this one. Return true if merge changed the payload. See Merge().
            This implementation throws an exception
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.DoValidate(NFX.DataAccess.Distributed.IBank)">
            <summary>
            Override to perform parcel/payload validation after modification. Add validation exceptions into m_ValidationExceptions field.
            Use bank for cross-checks (i.e. may run queries to check consistency)
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel.GDID">
            <summary>
            Returns GDID for data that this parcel represents
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel.ShardingID">
            <summary>
            Returns the ID used for sharding, default implementation returns GDID. override to return another sharding key, i.e.
             a social comment msg may use parent item (that the msg relates to) ID as the shard key so msgs are co-located with related items.
             IMPORTANT!!! ShardingID must return an immutable value, the one that CAN NOT be changed during parcel payload life.  
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel.ReplicationPriority">
            <summary>
            Returns replication priority, override to make replication priority dependent on instance, i.e. a user profile data for 
             a celebrity user may need to have higher replication rate. The lower value indicates the higher priority
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel.Payload">
            <summary>         
            Returns payload of this parcel.
            If the parcel is sealed and payload has not been unwrapped yet it will be unwrapped first then cached for subsequent access.
            May set payload only if parcel is in Creating or Modifying state (opened/not sealed).
            WARNING!!! Although parcels do not allow to set Payload property if they are sealed, one can still mutate/modify the payload object graph 
            even on a sealed parcel instance, i.e. one may write: 
              <code>mySealedParcel.Payload.DueDates.Add(DateTime.Now) (given DueDates of type List(DateTime))</code>.
            This case is considered to be a bug in the calling-code. The framework has no way of preventing such an inadvertent behavior as there is no
            way to intercept a mutation via transitive or direct references/functors in an object graph referenced by Payload property because payload type
             does not impose (and should not) any constraints on what can be a payload.
            In Aum language we will use static type checker that will detect possible property access via Payload BEFORE calling Open() 
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel.PayloadUnwrapped">
            <summary>
            Returns true when payload data is already cached - either deserialized from internal byte[] prepped for transmission, or was created locally
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel.WrappedPayload">
            <summary>
            Returns payload wrapped as byte[] for transmission.
            If payload has not been wrapped yet it will be wrapped first (serialized into byte[]) then cached for subsequent access.
            Parcel must be in a Sealed state for this call. Returns null if ParcelPayloadWrappingMode==NotWrapped
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel.HasWrappedPayload">
            <summary>
            Returns true to indicate that internal wrapped payload buffer is available (does not need to be wrapped)
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel.WrappedPayloadFormat">
            <summary>
            Returns pauload wrap format - a type of serialization used to wrap the payload
            Parcel must be in a Sealed state for this call. Returns null if ParcelPayloadWrappingMode==NotWrapped
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel.ReadOnly">
            <summary>
            Indicates whether the data may be altered. 
            ReadOnly parcels can not be Opened after that have been Sealed by their creator
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel.State">
            <summary>
            Returns the state of the parcel: Creating|Modifying|Sealed
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel.NewlySealed">
            <summary>
            Returns true when parcel was just sealed after a call to Open or .ctor/create.
            Datastore may check this flag and disallow saving of parcel instances that have not changed
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel.ReplicationVersionInfo">
            <summary>
            Implements IReplicatable interface
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel.CacheWriteMaxAgeSec">
            <summary>
            Implements IParcelCachePolicy contract.
            The default implementation returns null.
            Override to supply a value for maximum length of this isntance stay in cache
             that may depend on particular parcel payload state (i.e. field values) 
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel.CacheReadMaxAgeSec">
            <summary>
            Implements IParcelCachePolicy contract.
            The default implementation returns null.
            Override to supply a value for maximum validity span of cached parcel
             that may depend on particular parcel payload state (i.e. field values). 
            This property may be used to obtain a value before parcel is re-read from the store
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel.CachePriority">
            <summary>
            Implements IParcelCachePolicy contract.
            The default implementation returns null.
            Override to supply a relative cache priority of this parcel
             that may depend on particular parcel payload state (i.e. field values). 
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel.CacheTableName">
            <summary>
            Implements IParcelCachePolicy contract.
            The default implementation returns null.
            Override to supply a different name of caching table
             that may depend on particular parcel payload state (i.e. field values). 
            Example: store 'ultra hot' items in a dedicated cache table 
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel.CacheAbsoluteExpirationUTC">
            <summary>
            Implements IParcelCachePolicy contract.
            The default implementation returns null.
            Override to supply a different absolute cache expiration UTC timestamp for this parcel
             that may depend on particular parcel payload state (i.e. field values). 
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel.ValidationExceptions">
            <summary>
            Returns validation exceptions - populated by a call to Validate
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel.MetadataAttribute">
            <summary>
            Returns DataParcelAttribute that describes this parcel
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel.EffectiveCachePolicy">
            <summary>
            Returns effective cache policy the one that is calculated from attribute and overidden by the instance
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.Parcel`1">
            <summary>
            Describes a data parcel - a piece of logically-grouped data that gets fetched from/comitted into a distributed backend system.
            Parcels represent an atomic unit of change, a changeset that gets replicated between failover hosts.
            Every parcel has a Payload property that stores business data of interest that the parcel contains.
            This class is designed in such way that Payload property (unwrapped data) is not serialized, instead a byte[](wrapped data) is serialized.
            This is needed because an instance of Parcel may travel between many hosts that do not need to serialize/deserialize possibly complex business
            object that parcel contains.
            Parcels wrap their payload - when parcels get transported between hosts only parcel metadata (Parcel class fields) get serialized/deserialized by 
            hosts in the data supply chain, so metadata is available for tasks like parcel routing and cache policy adjustment, but the business data (the payload) must be 
            unwrapped first before it can be used. This design promotes efficient storage in distributed cache systems, i.e. the data origination host may keep cached version
            in an unwrapped state (not serialized) so business payload is ready for access right away without deserialization. 
            On the other hand, the intermediary parcel relays do not need to deserialize/serialize payload every time as it may be complex and waste significant processing time.
            This class is not thread-safe.
            This particular class serves as a very base for distributed data store implementations
            </summary>
            <typeparam name="TPayload">Type of payload that parcel carries</typeparam>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel`1.Payload">
            <summary>
            Returns payload of this parcel.
            If the parcel is sealed and payload has not been unwrapped yet it will be unwrapped first then cached for subsequent access.
            May set payload only if parcel is in Creating or Modifying state (opened/not sealed)
            </summary>
        </member>
        <member name="T:NFX.DataAccess.StoreLogLevel">
            <summary>
            Defines log level for DataStores
            </summary>
        </member>
        <member name="T:NFX.DataAccess.StoreFlag">
            <summary>
            Determines whether entity should be loaded/stored from/to storage
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CharCase">
            <summary>
            Types of char casing
            </summary>
        </member>
        <member name="T:NFX.DataAccess.ISequenceInfo">
            <summary>
            Provides basic information about a named sequence
            </summary>
        </member>
        <member name="T:NFX.DataAccess.IUniqueSequenceProvider">
            <summary>
            Represents an entity that provides unique identifiers via named sequences
            </summary>
        </member>
        <member name="M:NFX.DataAccess.IUniqueSequenceProvider.GetSequenceInfos(System.String)">
            <summary>
            Returns sequnce information enumerable for all sequences in the named scope
            </summary>
        </member>
        <member name="M:NFX.DataAccess.IUniqueSequenceProvider.GenerateSequenceID(System.String,System.String,System.Int32,System.Nullable{System.UInt64})">
            <summary>
            Generates ID for the supplied sequence name
            </summary>
            <param name="scopeName">The name of scope where sequences are kept</param>
            <param name="sequenceName">The name of sequence within the scope for which ID to be obtained</param>
            <param name="blockSize">If >0 specifies how many sequence values to pre-allocate, otherwise provider would use its default setting</param>
            <param name="vicinity">The location on ID counter scale, the issuing authority may disregard this parameter</param>
            <returns>The new ULONG sequence value</returns>
        </member>
        <member name="P:NFX.DataAccess.IUniqueSequenceProvider.SequenceScopeNames">
            <summary>
            Returns the list of all scope names in the instance
            </summary>
        </member>
        <member name="T:NFX.DataAccess.IGDIDProvider">
            <summary>
            Represents an entity that provides unique Global Distributed IDs (GDIDs) via named sequences
            </summary>
        </member>
        <member name="M:NFX.DataAccess.IGDIDProvider.GenerateGDID(System.String,System.String,System.Int32,System.Nullable{System.UInt64})">
            <summary>
            Generates Globally-Unique distributed ID (GDID) for the supplied sequence name
            </summary>
            <param name="scopeName">The name of scope where sequences are kept</param>
            <param name="sequenceName">The name of sequence within the scope for which ID to be obtained</param>
            <param name="blockSize">If >0 specifies how many sequence values to pre-allocate, otherwise provider would use its default setting</param>
            <param name="vicinity">The location on ID counter scale, the authority may disregard this parameter</param>
            <returns>The GDID instance</returns>
        </member>
        <member name="P:NFX.DataAccess.IGDIDProvider.TestingAuthorityNode">
            <summary>
            Gets/sets Authority Glue Node for testing. It can only be set once in the testing app container init before the first call to
             Generate is made. When this setting is set then any cluster authority nodes which would have been normally used will be 
             completely bypassed during block allocation
            </summary>
        </member>
        <member name="T:NFX.ELink">
            <summary>
            Represents an Electronic Link which is an alpha-encoded identifier along with metadata information.
            Warning! This class MAY generate fragments of profanity, however any ID can be regenerated using a different seed passed to Encode(seed)
            </summary>
        </member>
        <member name="M:NFX.ELink.#ctor(System.UInt64,System.Byte[])">
            <summary>
            Creates an Elink instance initialized with GDID of 0 Era having its ID set to ulong value
            </summary>
        </member>
        <member name="M:NFX.ELink.#ctor(NFX.DataAccess.Distributed.GDID,System.Byte[])">
            <summary>
            Create ELink instance from GDID (with era).
            </summary>
        </member>
        <member name="M:NFX.ELink.Encode(System.Nullable{System.Byte})">
            <summary>
            Encodes a link into a textual form, using the supplied randomization seed, otherwise the system rnd is used.
            A seed has 4 effective bits, yielding 16 possible variations for every link
            </summary>
        </member>
        <member name="P:NFX.ELink.ID">
            <summary>
            Returns the ID portion of GDID represented by this instance
            </summary>
        </member>
        <member name="P:NFX.ELink.Metadata">
            <summary>
            Returns metadata attached to this instance, or null if there is no metadata specified
            </summary>
        </member>
        <member name="P:NFX.ELink.Link">
            <summary>
            Returns a link encoded as a string using whatever randomization seed was passed to the last Encode(seed) call.
            If Encode() was not called, then the link will get encoded using system rnd for a seed value
            </summary>
        </member>
        <member name="P:NFX.ELink.GDID">
            <summary>
            Returns the GDID that this link represents
            </summary>
        </member>
        <member name="T:NFX.Erlang.ErlConnection">
            <summary>
            Maintains a connection between a C# process and a remote
            Erlang, C# or C node. The object maintains connection state and
            allows data to be sent to and received from the peer
            </summary>
            <remarks>
            In current implementation each connection creates a thread
            </remarks>
        </member>
        <member name="T:NFX.Erlang.ErlAbstractConnection">
             <summary>
             Maintains a connection between a C# process and a remote Erlang,
             C# or C node. The object maintains connection state and allows
             data to be sent to and received from the peer
             </summary>
             <remarks>
             This abstract class provides the neccesary methods to maintain
             the actual connection and encode the messages and headers in the
             proper format according to the Erlang distribution protocol.
             Subclasses can use these methods to provide a more or less
             transparent communication channel as desired.
            
             Note that no receive methods are provided. Subclasses must
             provide methods for message delivery, and may implement their own
             receive methods.
            
             If an exception occurs in any of the methods in this class, the
             connection will be closed and must be reopened in order to resume
             communication with the peer. This will be indicated to the subclass
             by passing the exception to its delivery() method
             </remarks>
        </member>
        <member name="M:NFX.Erlang.ErlAbstractConnection.#ctor(NFX.Erlang.ErlLocalNode,System.Net.Sockets.TcpClient)">
            <summary>
            Accept an incoming connection from a remote node. Used by ErlLocalNode.Accept
            to create a connection
            based on data received when handshaking with the peer node, when
            the remote node is the connection intitiator.
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlAbstractConnection.#ctor(NFX.Erlang.ErlLocalNode,NFX.Erlang.ErlRemoteNode,System.Nullable{NFX.Erlang.ErlAtom},System.Boolean)">
            <summary>
            Intiate and open a connection to a remote node
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlAbstractConnection.Deliver(NFX.Erlang.ErlConnectionException)">
            <summary>
            Deliver communication exceptions to the recipient
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlAbstractConnection.Deliver(NFX.Erlang.ErlMsg)">
            <summary>
            Deliver messages to the recipient
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlAbstractConnection.Close">
            <summary>
            Close the connection to the remote node
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlAbstractConnection.SendRPC(NFX.Erlang.ErlPid,System.String,System.String,NFX.Erlang.ErlList)">
             <summary>
             Send an RPC request to the remote Erlang node
             </summary>
             <param>mod the name of the Erlang module containing the function to be called</param>
             <param>fun the name of the function to call</param>
             <param>args a list of Erlang terms, to be used as arguments to the function</param>
             <remarks>This convenience function creates the following message
             and sends it to 'rex' on the remote node:
             
             <code>
             { Self, { call, Mod, Fun, Args, user }}
             </code>
            
             Note that this method has unpredicatble results if the remote
             node is not an Erlang node
             </remarks>
        </member>
        <member name="M:NFX.Erlang.ErlAbstractConnection.SendRPCcast(NFX.Erlang.ErlPid,System.String,System.String,NFX.Erlang.ErlList)">
            <summary>
            Send an RPC cast request to the remote Erlang node
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlAbstractConnection.ReadSock(System.Byte[],System.Int32,System.Boolean)">
            <summary>
            Read data from socket
            </summary>
            <remarks>
            This method now throws exception if we don't get full read
            </remarks>
        </member>
        <member name="P:NFX.Erlang.ErlAbstractConnection.TraceLevel">
            <summary>
            Set the trace level for this connection. Normally tracing is off by default
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlAbstractConnection.SentBytes">
            <summary>
            Total number of bytes sent through connection
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlAbstractConnection.ReceivedBytes">
            <summary>
            Total number of bytes received from connection
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlAbstractConnection.SentMsgs">
            <summary>
            Total number of messages sent through connection
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlAbstractConnection.ReceivedMsgs">
            <summary>
            Total number of messages received from connection
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlAbstractConnection.SendCookie">
            <summary>
            Cookie to send along with each distribution message
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlAbstractConnection.MaxPayloadLength">
            <summary>
            Max size of the message accepted from the peer.
            The connection will be closed if a message is received of size greater than this.
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlAbstractConnection.Connected">
            <summary>
            Determine if the connection is still alive. Note that this method
            only reports the status of the connection, and that it is
            possible that there are unread messages waiting in the receive
            queue
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlConnection.#ctor(NFX.Erlang.ErlLocalNode,System.Net.Sockets.TcpClient)">
            <summary>
            Accept an incoming connection from a remote node
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlConnection.#ctor(NFX.Erlang.ErlLocalNode,NFX.Erlang.ErlRemoteNode,System.Boolean)">
            <summary>
            Intiate and open a connection to a remote node
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlConnection.Send(NFX.Erlang.ErlPid,NFX.Erlang.IErlObject)">
            <summary>
            Send an Erlang term to a Pid on a local or remote node
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlConnection.Deliver(NFX.Erlang.ErlConnectionException)">
            <summary>
            Deliver communication exceptions to the recipient
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlConnection.Deliver(NFX.Erlang.ErlMsg)">
            <summary>
            Deliver messages to the recipient
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlConnection.cookieError(NFX.Erlang.ErlLocalNode,NFX.Erlang.ErlAtom)">
            <summary>
            Send an auth error to peer because he sent a bad cookie
            The auth error uses his cookie (not revealing ours).
            This is just like send_reg otherwise
            </summary>
        </member>
        <member name="T:NFX.Erlang.Internal.ErlAcceptor">
            <summary>
            This thread simply listens for incoming connections
            </summary>
        </member>
        <member name="T:NFX.Erlang.ErlEpmd">
            <summary>
            Provides methods for registering, unregistering and looking up
            nodes with the Erlang portmapper daemon (Epmd). For each registered
            node, Epmd maintains information about the port on which incoming
            connections are accepted, as well as which versions of the Erlang
            communication protocolt the node supports
            </summary>
            <remarks>
            Nodes wishing to contact other nodes must first request
            information from Epmd before a connection can be set up, however
            this is done automatically by
            <see cref="M:NFX.Erlang.ErlLocalNode.Connection(System.String,System.Nullable{NFX.Erlang.ErlAtom})"/>
            when necessary.
            
            The methods <see cref="M:NFX.Erlang.ErlEpmd.PublishPort(NFX.Erlang.ErlLocalNode)"/> and
            <see cref="M:NFX.Erlang.ErlEpmd.UnPublishPort(NFX.Erlang.ErlLocalNode)"/> will fail if an
            Epmd process is not running on the localhost. Additionally
            <see cref="M:NFX.Erlang.ErlEpmd.LookupPort(NFX.Erlang.ErlLocalNode,NFX.Erlang.ErlRemoteNode,System.Boolean)"/> will fail if there is no Epmd
            process running on the host where the specified node is running.
            See the Erlang documentation for information about starting Epmd.
            
            This class contains only static methods, there are no
            constructors.
            </remarks>
        </member>
        <member name="M:NFX.Erlang.ErlEpmd.LookupPort(NFX.Erlang.ErlLocalNode,NFX.Erlang.ErlRemoteNode,System.Boolean)">
            <summary>
            Determine what port a node listens for incoming connections on
            </summary>
            <param name="home">Local node</param>
            <param name="node">Remote lode for which to look up the port number from remote EPMD</param>
            <param name="closeSocket">If true, close the connection to remote EPMD at return</param>
            <returns>the listen port for the specified node, or 0 if the node
            was not registered with Epmd</returns>
        </member>
        <member name="M:NFX.Erlang.ErlEpmd.PublishPort(NFX.Erlang.ErlLocalNode)">
            <summary>
            Publish node's port at local EPMD, so that other nodes can connect to it.
            
            On failure to connect to EPMD the function may throw if the value of
            ErlApp.IgnoreLocalEpmdConnectErrors variable is true.
            
            On failed connection attempt the function calls
            node.OnEpmdFailedConnectAttempt delegate
            </summary>
            <remarks>
            This function will get an exception if it tries to talk to an r3
            epmd, or if something else happens that it cannot forsee. In both
            cases we return an exception (and the caller should try again, using
            the r3 protocol).
            
            If we manage to successfully communicate with an r4 epmd, we return
            either the socket, or null, depending on the result
            </remarks>
        </member>
        <member name="M:NFX.Erlang.ErlEpmd.UnPublishPort(NFX.Erlang.ErlLocalNode)">
            <summary>
            Unregister from Epmd.
            Other nodes wishing to connect will no longer be able to
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlLink.HasPid">
            <summary>
            Returns true if this link points to a pid rather than to a node
            </summary>
        </member>
        <member name="T:NFX.Erlang.ReadWriteCallback">
            <summary>
            Delegate called on read/write from socket
            </summary>
        </member>
        <member name="T:NFX.Erlang.ErlAbstractNode">
            <summary>
            Represents an OTP node
            </summary>
            <remarks>
            About nodenames: Erlang nodenames consist of two components, an
            alivename and a hostname separated by '@'. Additionally, there are
            two nodename formats: short and long. Short names are of the form
            "alive@hostname", while long names are of the form
            "alive@host.fully.qualified.domainname". Erlang has special
            requirements regarding the use of the short and long formats, in
            particular they cannot be mixed freely in a network of
            communicating nodes, however Jinterface makes no distinction. See
            the Erlang documentation for more information about nodenames.
            
            The constructors for the AbstractNode classes will create names
            exactly as you provide them as long as the name contains '@'. If
            the string you provide contains no '@', it will be treated as an
            alivename and the name of the local host will be appended,
            resulting in a shortname. Nodenames longer than 255 characters will
            be truncated without warning.
            
            Upon initialization, this class attempts to read the file
            .erlang.cookie in the user's home directory, and uses the trimmed
            first line of the file as the default cookie by those constructors
            lacking a cookie argument. If for any reason the file cannot be
            found or read, the default cookie will be set to the empty string
            (""). The location of a user's home directory is determined using
            the system environment "HOME", which may not be automatically set
            on all platforms
            </remarks>
        </member>
        <member name="M:NFX.Erlang.ErlAbstractNode.#ctor(System.String,System.Boolean)">
            <summary>
            Create a node with the given name and the default cookie
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlAbstractNode.#ctor(System.String,NFX.Erlang.ErlAtom,System.Boolean)">
            <summary>
            Create a node with the given name and cookie
            </summary>
            <param name="name">Node name in the form "name" or "name@hostname"</param>
            <param name="cookie">Security cookie used to connect to this/other node(s)</param>
            <param name="shortName">Use short/long host names</param>
        </member>
        <member name="M:NFX.Erlang.ErlAbstractNode.#ctor(System.String,NFX.Environment.IConfigSectionNode)">
            <summary>
            This constructor 
            </summary>
            <param name="name"></param>
            <param name="config"></param>
        </member>
        <member name="P:NFX.Erlang.ErlAbstractNode.NodeName">
            <summary>
            Get the name of this node (short or long depending on UseShortName)
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlAbstractNode.NodeLongName">
            <summary>
            Get the long name of this node
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlAbstractNode.Host">
            <summary>
            Get the hostname part of the nodename. Nodenames are composed of
            two parts, an alivename and a hostname, separated by '@'. This
            method returns the part of the nodename following the '@'
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlAbstractNode.AliveName">
            <summary>
            Get the alivename part of the hostname. Nodenames are composed of
            two parts, an alivename and a hostname, separated by '@'. This
            method returns the part of the nodename preceding the '@'
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlAbstractNode.Cookie">
            <summary>
            Get the authorization cookie used by this node
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlAbstractNode.Epmd">
            <summary>
            Get/Set the Epmd socket after publishing this nodes listen port to Epmd
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlAbstractNode.Port">
            <summary>
            Get the port number used by this node.
            For local node the value may be 0 if the node was not registered with
            the EPMD port mapper
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlLocalNode.#ctor(System.String,System.Boolean)">
            <summary>
            Create a node with the given name and the default cookie
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlLocalNode.#ctor(System.String,NFX.Erlang.ErlAtom,System.Boolean)">
            <summary>
            Create a node with the given name, cookie, and short name indicator
            </summary>
        </member>
        <member name="F:NFX.Erlang.ErlLocalNode.m_OnReadWrite">
            <summary>
            Delegate invoked on read/write from socket
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlLocalNode.Add(NFX.Erlang.ErlConnection)">
            <summary>
            Add a connection to collection
            </summary>
            <returns>Returns false if this connection was already previously added</returns>
        </member>
        <member name="M:NFX.Erlang.ErlLocalNode.Remove(NFX.Erlang.ErlConnection)">
            <summary>
            Remove a connection from collection
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlLocalNode.CreateMbox">
            <summary>
            Create a new mailbox (emulates spawning a new Pid)
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlLocalNode.CreateMbox(System.String)">
            <summary>
            Create a new named mailbox (emulates spawning a new Pid)
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlLocalNode.CreateMbox(NFX.Erlang.ErlAtom)">
            <summary>
            Create a new named mailbox (emulates spawning a new Pid)
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlLocalNode.CloseMbox(NFX.Erlang.ErlMbox)">
            <summary>
            Close the given mailbox
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlLocalNode.FindMbox(NFX.Erlang.ErlAtom)">
            <summary>
            Determine the mailbox corresponding to a
            registered name on this <see cref="T:NFX.Erlang.ErlLocalNode"/>
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlLocalNode.Send(NFX.Erlang.ErlPid,NFX.Erlang.IErlObject)">
            <summary>
            Send a message to a remote <see cref="T:NFX.Erlang.ErlPid"/>, representing
            either another <see cref="T:NFX.Erlang.ErlMbox"/> or an Erlang process
            </summary>
            <returns>true if message was sent successfully</returns>
        </member>
        <member name="M:NFX.Erlang.ErlLocalNode.Send(NFX.Erlang.ErlPid,NFX.Erlang.ErlAtom,NFX.Erlang.ErlAtom,NFX.Erlang.IErlObject)">
            <summary>
            Send a message to a named mailbox on a given remote node
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlLocalNode.Send(NFX.Erlang.ErlPid,NFX.Erlang.ErlAtom,NFX.Erlang.IErlObject)">
            <summary>
            Send a message to a named mailbox on local node
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlLocalNode.CreateRef">
            <summary>
            Create an Erlang {@link Ref reference}. Erlang
            references are based upon some node specific information; this
            method creates a reference using the information in this node.
            Each call to this method produces a unique reference
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlLocalNode.WaitAny(NFX.Erlang.ErlMbox[],System.Int32)">
            <summary>
            Wait for arrival of messages in any one of the given mailboxes
            </summary>
            <param name="mboxes">Mailboxes to wait for messages in</param>
            <param name="msecTimeout">Timeout in milliseconds</param>
            <returns>Index of the first non-empty mailbox or -1 on timeout</returns>
        </member>
        <member name="M:NFX.Erlang.ErlLocalNode.DoStart">
            <summary>
            Start current node. This optionally creates a socket listener
            and I/O server
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlLocalNode.BreakLinks(NFX.Erlang.ErlAtom,NFX.Erlang.IErlObject)">
            <summary>
            Break links of all pids linked to pids on the fromNode node
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlLocalNode.CreateNullPid(NFX.Erlang.ErlAtom)">
            <summary>
            Create an Erlang <see cref="T:NFX.Erlang.ErlPid"/> that belongs to current node
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlLocalNode.CreatePid">
            <summary>
            Create an Erlang <see cref="T:NFX.Erlang.ErlPid"/>. Erlang pids are based
            upon some node specific information; this method creates a pid
            using the information in this node. Each call to this method
            produces a unique pid
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlLocalNode.CreatePort">
            <summary>
            Create an Erlang <see cref="T:NFX.Erlang.ErlPort"/>. Erlang ports are
            based upon some node specific information; this method creates a
            port using the information in this node. Each call to this method
            produces a unique port. It may not be meaningful to create a port
            in a non-Erlang environment, but this method is provided for
            completeness
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlLocalNode.Creation">
            <summary>
            Contains node creation bits that facilitate Pid uniqueness
            upon node restart
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlLocalNode.AcceptConnections">
            <summary>
            If true local node will start a listener
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlLocalNode.AcceptAddressPort">
            <summary>
            Configuration Address and Port information for the listener in
            the "address:port" format 
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlLocalNode.GroupLeader">
            <summary>
            Mailbox for handling all I/O directed from remote nodes
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlLocalNode.TraceLevel">
            <summary>
            Set the trace level for this connection. Normally tracing is off by default
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlLocalNode.OnTrace">
            <summary>
            Trace callback executed if connection tracing is enabled
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlLocalNode.MboxFreelist">
            <summary>
            Cache of freed mailboxes that can be reused for RPC calls
            </summary>
            <remarks>This is needed because the unique Pid space is limited to 2^28</remarks>
        </member>
        <member name="T:NFX.Erlang.OnMessageDelegate">
            <summary>
            Indicates arrival of a message to a given mailbox
            </summary>
        </member>
        <member name="T:NFX.Erlang.OnErrorDelegate">
            <summary>
            Indicates arrival of an exception in a given mailbox
            </summary>
        </member>
        <member name="T:NFX.Erlang.ErlMbox">
             <summary>
             Provides a simple mechanism for exchanging messages with Erlang
             processes or other instances of this class
             </summary>
             <remarks>
             Each mailbox is associated with a unique <see cref="T:NFX.Erlang.ErlPid"/>
             that contains information necessary for delivery of messages.
             When sending messages to named processes or mailboxes, the sender
             pid is made available to the recipient of the message. When sending
             messages to other mailboxes, the recipient can only respond if the
             sender includes the pid as part of the message contents. The sender
             can determine his own pid by calling <see cref="P:NFX.Erlang.ErlMbox.Self"/>.
            
             Mailboxes can be named, either at creation or later. Messages
             can be sent to named mailboxes and named Erlang processes without
             knowing the <see cref="T:NFX.Erlang.ErlPid"/> that identifies the mailbox.
             This is neccessary in order to set up initial communication between
             parts of an application. Each mailbox can have at most one name.
            
             Messages to remote nodes are externalized for transmission, and
             as a result the recipient receives a <b>copy</b> of the original
             C# object. To ensure consistent behaviour when messages are sent
             between local mailboxes, such messages are cloned before delivery.
            
             Additionally, mailboxes can be linked in much the same way as
             Erlang processes. If a link is active when a mailbox is closed
             any linked Erlang processes or ErlMbox's will be
             sent an exit signal. As well, exit signals will be (eventually)
             sent if a mailbox goes out of scope and its Dispose method called.
             However due to the nature of
             finalization (i.e. C# makes no guarantees about when Dispose
             will be called) it is recommended that you
             always explicitly close mailboxes if you are using links instead of
             relying on finalization to notify other parties in a timely manner.
            
             When retrieving messages from a mailbox that has received an exit
             signal, an <see cref="T:NFX.Erlang.ErlExit"/> exception will be
             raised. Note that the exception is queued in the mailbox along with
             other messages, and will not be raised until it reaches the head of
             the queue and is about to be retrieved
             </remarks>
        </member>
        <member name="M:NFX.Erlang.ErlMbox.#ctor(NFX.Erlang.ErlLocalNode,NFX.Erlang.ErlPid,System.String)">
            <summary>
            Create a mailbox with optional name
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlMbox.Register(System.String)">
            <summary>
            Register a name for this mailbox. Registering a
            name for a mailbox enables others to send messages without
            knowing the <see cref="T:NFX.Erlang.ErlPid"/> of the mailbox. A mailbox
            can have at most one name; if the mailbox already had a name,
            calling this method will supercede that name
            </summary>
            <returns>true if the name was available, or false otherwise</returns>
        </member>
        <member name="M:NFX.Erlang.ErlMbox.ReceiveMatch(NFX.Erlang.IErlObject,System.Int32)">
            <summary>
            Receive a message and match it against a given pattern
            </summary>
            <param name="pattern">Pattern to match the message against</param>
            <param name="timeoutMsec">Timeout in milliseconds</param>
            <returns>Return a tuple containing the received message and variable
            binding object. On timeout the first element of the tuple is null.
            On unsuccessful match the second element of the tuple is null</returns>
        </member>
        <member name="M:NFX.Erlang.ErlMbox.ReceiveMatch(NFX.Erlang.ErlPatternMatcher,System.Int32)">
            <summary>
            Receive a message and match it against a given pattern
            </summary>
            <param name="pm">Patterns to match the message against</param>
            <param name="timeoutMsec">Timeout in milliseconds</param>
            <returns>Return a tuple containing the received message and index of the
            pattern in the pm instance that was successfully matched.
            On timeout the 2nd element of the tuple is -2 and 1st element of the tuple is null.
            On unsuccessful match the second element of the tuple is -1</returns>
        </member>
        <member name="M:NFX.Erlang.ErlMbox.Receive(System.Int32)">
            <summary>
            Wait for a message to arrive for this mailbox. On timeout return null
            </summary>
            <param name="timeout">Timeout time in milliseconds</param>
            <returns></returns>
        </member>
        <member name="M:NFX.Erlang.ErlMbox.Send(NFX.Erlang.ErlAtom,NFX.Erlang.ErlAtom,NFX.Erlang.IErlObject)">
            <summary>
            Send a message to a named mailbox created from another node
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlMbox.AsyncRPC(NFX.Erlang.ErlAtom,NFX.Erlang.ErlAtom,NFX.Erlang.ErlAtom,NFX.Erlang.ErlList,NFX.Erlang.IErlObject)">
            <summary>
            Send RPC call to a given node.
            </summary>
            <param name="node">Destination node for this RPC call</param>
            <param name="mod">Module name to call</param>
            <param name="fun">Function name to call</param>
            <param name="args">Function arguments</param>
            <param name="ioServer">Either a PID or an Atom containing registered I/O server's name.</param>
        </member>
        <member name="M:NFX.Erlang.ErlMbox.Link(NFX.Erlang.ErlPid)">
            <summary>
            Link to a remote mailbox or Erlang process. Links are
            idempotent, calling this method multiple times will not result in
            more than one link being created
            </summary>
            <remarks>
            If the remote process subsequently exits or the mailbox is
            closed, a subsequent attempt to retrieve a message through this
            mailbox will cause an {@link Exit Exit}
            exception to be raised. Similarly, if the sending mailbox is
            closed, the linked mailbox or process will receive an exit
            signal.
            
            If the remote process cannot be reached in order to set the
            link, the exception is raised immediately.
            </remarks>
        </member>
        <member name="M:NFX.Erlang.ErlMbox.Unlink(NFX.Erlang.ErlPid)">
            <summary>
            Remove a link to a remote mailbox or Erlang process. This
            method removes a link created with <see cref="T:NFX.Erlang.ErlLink"/>
            Links are idempotent; calling this method once will remove all
            links between this mailbox and the remote <see cref="T:NFX.Erlang.ErlPid"/>
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlMbox.Equals(System.Object)">
            <summary>
            Determine if two mailboxes are equal
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlMbox.Close">
             <summary>
             Close this mailbox
             </summary>
             <remarks>
             After this operation, the mailbox will no longer be able to
             receive messages. Any delivered but as yet unretrieved messages
             can still be retrieved however.
            
             If there are links from this mailbox to other <see cref="T:NFX.Erlang.ErlPid"/>
             pids they will be broken when this method is
             called and exit signals will be sent.
             </remarks>
        </member>
        <member name="M:NFX.Erlang.ErlMbox.Deliver(NFX.Erlang.ErlMsg)">
            <summary>
            Called to deliver message to this mailbox
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlMbox.BreakLinks(NFX.Erlang.ErlAtom,NFX.Erlang.IErlObject)">
            <summary>
            Used to break all known links to this mbox
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlMbox.BreakLinks(NFX.Erlang.ErlAtom)">
            <summary>
            Used to break all known links to this mbox
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlMbox.receiveBuf">
            <summary>
            Block until a message arrives for this mailbox
            </summary>
            <returns>a stream representing the still-encoded body of the next
            message waiting in this mailbox</returns>
        </member>
        <member name="M:NFX.Erlang.ErlMbox.receiveBuf(System.Int32)">
            <summary>
            Wait for a message to arrive for this mailbox
            </summary>
            <param name="timeout">time in milliseconds</param>
            <returns>a stream representing the still-encoded body of the next
            message waiting in this mailbox, or null on timeout</returns>
        </member>
        <member name="M:NFX.Erlang.ErlMbox.receiveMsg(System.Int32)">
            <summary>
            Receive a message complete with sender and recipient information
            from a remote process. This method blocks at most for the specified
            time, until a valid message is received or an exception is raised
            </summary>
            <param name="timeout">Time in milliseconds</param>
            <returns>Erlang distributed message or null on timeout</returns>
        </member>
        <member name="P:NFX.Erlang.ErlMbox.Self">
            <summary>
            Get the Pid identifying associated with this mailbox
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlMbox.Name">
            <summary>
            Get the registered name of this mailbox, or string.Empty if the
            mailbox doesn't have a registered name
            </summary>
            <returns></returns>
        </member>
        <member name="P:NFX.Erlang.ErlMbox.Empty">
            <summary>
            Return true if there are no messages waiting in the receive queue
            of this connection
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlMbox.MsgCount">
            <summary>
            Return the number of messages currently waiting in the receive
            queue of this connection
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlMbox.Handle">
            <summary>
            Queue not empty status notification handle
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlMbox.LastUsed">
            <summary>
            Timestamps when this mailbox was last used - this is used internally
            by mailbox caching
            </summary>
        </member>
        <member name="T:NFX.Erlang.IQueable">
            <summary>
            Represents a interface that messages enqueued to ErlMbox must support
            </summary>
        </member>
        <member name="T:NFX.Erlang.ErlMsg">
            <summary>
            Provides a distributed carrier for Erlang messages
            </summary>
            <remarks>
            Instances of this class are created to package header and
            payload information in received Erlang messages so that the
            recipient can obtain both parts with a single call to
            <see cref="M:NFX.Erlang.ErlMbox.receiveMsg"/>
            
            The header information that is available is as follows:
            <ul>
            <li>a tag indicating the type of message</li>
            <li>the intended recipient of the message, either as a
                <see cref="T:NFX.Erlang.ErlPid"/> or as a <see cref="T:NFX.Erlang.ErlAtom"/>, but never both.</li>
            <li>(sometimes) the sender of the message. Due to some eccentric
                characteristics of the Erlang distribution protocol, not
                all messages have information about the sending process. In
                particular, only messages whose tag is <see cref="F:NFX.Erlang.ErlMsg.Tag.RegSend"/>
                contain sender information.</li>
            </ul>
            
            Message are sent using the Erlang external format (see separate
            documentation). When a message is received and delivered to the
            recipient <see cref="T:NFX.Erlang.ErlMbox"/>, the body of the message is still
            in this external representation until <see cref="P:NFX.Erlang.ErlMsg.Msg"/>
            is called, at which point the message is decoded. A copy of the
            decoded message is stored in the OtpMsg so that subsequent calls to
            <see cref="P:NFX.Erlang.ErlMsg.Msg"/> do not require that the message be decoded
            a second time.
            </remarks>
        </member>
        <member name="F:NFX.Erlang.ErlMsg.Type">
            <summary>
            The type of message
            </summary>
        </member>
        <member name="F:NFX.Erlang.ErlMsg.Ref">
            <summary>
            Returns reference contained in this message
            </summary>
        </member>
        <member name="F:NFX.Erlang.ErlMsg.Reason">
            <summary>
            Reason associated with some messages
            </summary>
        </member>
        <member name="F:NFX.Erlang.ErlMsg.Cookie">
            <summary>
            Contains cookie if it is to be sent or was received in the message
            </summary>
        </member>
        <member name="F:NFX.Erlang.ErlMsg.TraceToken">
            <summary>
            Trace token delivered in the message
            </summary>
        </member>
        <member name="F:NFX.Erlang.ErlMsg.Paybuf">
            <summary>
            The payload of this deserialized message
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlMsg.Msg">
            <summary>
            Deserialized Erlang message contained in this instance
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlMsg.RecipientName">
            <summary>
            Get the name of the recipient for this message
            </summary>
            <remarks>
            Messages are sent to Pids or names. If this message was sent
            to a name then the name is returned by this method
            </remarks>
        </member>
        <member name="P:NFX.Erlang.ErlMsg.RecipientPid">
            <summary>
            Get the Pid of the recipient for this message, if it is a Send message
            </summary>
            <remarks>
            Messages are sent to Pids or names. If this message was sent
            to a Pid then the Pid is returned by this method. The recipient
            Pid is also available for link, unlink and exit messages
            </remarks>
        </member>
        <member name="P:NFX.Erlang.ErlMsg.Recipient">
            <summary>
            Get the recipient for this message, as a Pid or a registered name (Atom)
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlMsg.SenderPid">
            <summary>
            Returns pid of the sender (may be empty, i.e. SenderPid.Empty == true)
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlMsg.Sender">
            <summary>
            Get the sender for this message, as a Pid or a registered name (Atom)
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlMsg.HasSender">
            <summary>
            Returns true if the message has a non-empty sender
            </summary>
        </member>
        <member name="T:NFX.Erlang.ErlMsg.Tag">
            <summary>
            Erlang message header tags
            </summary>
        </member>
        <member name="F:NFX.Erlang.ErlTraceLevel.Off">
            <summary>
            Tracing is off
            </summary>
        </member>
        <member name="F:NFX.Erlang.ErlTraceLevel.Send">
            <summary>
            Trace ordinary send and receive messages
            </summary>
        </member>
        <member name="F:NFX.Erlang.ErlTraceLevel.Ctrl">
            <summary>
            Trace control messages (e.g. link/unlink)
            </summary>
        </member>
        <member name="F:NFX.Erlang.ErlTraceLevel.Handshake">
            <summary>
            Trace handshaking at connection startup
            </summary>
        </member>
        <member name="F:NFX.Erlang.ErlTraceLevel.Epmd">
            <summary>
            Trace Epmd connectivity
            </summary>
        </member>
        <member name="F:NFX.Erlang.ErlTraceLevel.Wire">
            <summary>
            Trace wire-level message content
            </summary>
        </member>
        <member name="T:NFX.Erlang.TraceCallback">
            <summary>
            Debugging delegate called to be able to record transport-related events
            </summary>
            <param name="type">Type of trace event</param>
            <param name="dir">Event direction (in/out-bound)</param>
            <param name="message">Event detail</param>
        </member>
        <member name="T:NFX.Erlang.EpmdFailedConnAttemptCallback">
            <summary>
            Callback related to failed EPMD connectivity attempts
            </summary>
        </member>
        <member name="T:NFX.Erlang.Internal.Parser">
            <summary>
            Provides compilation of strings to Erlang terms
            </summary>
        </member>
        <member name="M:NFX.Erlang.Internal.Parser.Format(NFX.Erlang.ErlList)">
            <summary>
            Substitute variables in a string contained in args[0]. The
            substitution values begin with args[1]
            </summary>
        </member>
        <member name="M:NFX.Erlang.Internal.Parser.Format(System.String,NFX.Erlang.ErlList)">
            <summary>
            Substitute variables in a fmt string
            </summary>
            <param name="fmt">Format string containing substitution variables (e.g. '~w')</param>
            <param name="args">List of arguments</param>
        </member>
        <member name="M:NFX.Erlang.Internal.Parser.Format(System.String,System.Object[])">
            <summary>
            Substitute variables in a fmt string. The following variables are supported:
            <dl>
            <dt>~v</dt><dd>Take next argument as string.
                            If the argument is ErlAtom, it's name is used. If the argument is
                            ErlVar it's name is used with the type if the fmt string doesn't have
                            the variable type specification (e.g. A::integer()), or the name
                            is used verbatim, if the variable type is present in the format
                            string.  Finally if the argument is not ErlAtom and ErlVar, it's
                            inserted as string verbatim</dd>
            <dt>~w</dt><dd>Format next argument as string</dd>
            <dt>~i</dt><dd>Skip next argument</dd>
            <dt>~c</dt><dd>Format next argument as the character</dd>
            </dl>
            </summary>
            <param name="fmt">Format string containing substitution variables (e.g. '~w')</param>
            <param name="args">List of arguments</param>
        </member>
        <member name="M:NFX.Erlang.Internal.Parser.ParseMFA(System.String,System.Int32@,System.Int32@,System.Object[])">
            <summary>
            Parses a string representation of an Erlang function call in the form
            <code>Module:Function(Arg1, ..., Arg)</code> or
            <code>Module:Function(Arg1, ..., Arg).</code>
            </summary>
            <param name="fmt">string to parse</param>
            <param name="pos">starting index</param>
            <param name="argc">argument number</param>
            <param name="args">optional arguments</param>
            <returns>A 3-element tuple containing Module, Function, Arguments</returns>
        </member>
        <member name="M:NFX.Erlang.Internal.Parser.Parse(System.String,System.Int32@,System.Int32@,System.Object[])">
            <summary>
            Compile a string fmt into an Erlang term
            </summary>
        </member>
        <member name="T:NFX.Erlang.ErlPatternMatcher">
            <summary>
            Pattern matcher that implements a container of patterns to be
            matched against a given Erlang term.  On successful match, the
            corresponding func registered with that pattern gets invoked
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlPatternMatcher.Add(System.String,NFX.Erlang.PatternMatchFunc)">
            <summary>
            Add a matching pattern to the collection
            </summary>
            <param name="pattern">Pattern to compile</param>
            <param name="func">Function to invoke on successful match</param>
            <returns>ID of the newly added pattern</returns>
        </member>
        <member name="M:NFX.Erlang.ErlPatternMatcher.Add(NFX.Erlang.IErlObject,NFX.Erlang.PatternMatchFunc)">
            <summary>
            Add a matching pattern to the collection
            </summary>
            <param name="pattern">Erlang term to be used as a match pattern</param>
            <param name="func">Function to invoke on successful match</param>
            <returns>ID of the newly added pattern</returns>
        </member>
        <member name="M:NFX.Erlang.ErlPatternMatcher.Add``1(``0,System.String,NFX.Erlang.PatternMatchFunc{``0})">
            <summary>
            Add a matching pattern to the collection
            </summary>
            <typeparam name="TContext">Type of context passed to func</typeparam>
            <param name="context">Context passed to func</param>
            <param name="pattern">Pattern to compile</param>
            <param name="func">Function to invoke on successful match</param>
            <returns>ID of the newly added pattern</returns>
        </member>
        <member name="M:NFX.Erlang.ErlPatternMatcher.Add``1(``0,NFX.Erlang.IErlObject,NFX.Erlang.PatternMatchFunc{``0})">
            <summary>
            Add a matching pattern to the collection
            </summary>
            <typeparam name="TContext">Type of context passed to func</typeparam>
            <param name="context">Context passed to func</param>
            <param name="pattern">Compiled pattern containing variables to match</param>
            <param name="func">Function to invoke on successful match</param>
            <returns>ID of the newly added pattern</returns>
        </member>
        <member name="M:NFX.Erlang.ErlPatternMatcher.Remove(System.Int32)">
            <summary>
            Remove pattern from collection given its ID
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlPatternMatcher.Match(NFX.Erlang.IErlObject@,System.Object[])">
            <summary>
            Match a term against the patterns in the collection.
            The first successful match will result in invocation of the func
            associated with the pattern, and storing func result in the term
            </summary>
            <param name="term">Term to match against patterns</param>
            <param name="args">Arguments to be passed to an func on successful pattern match</param>
            <returns>ID of the pattern that matched, or -1 if there were no matches</returns>
        </member>
        <member name="M:NFX.Erlang.ErlPatternMatcher.Clear">
            <summary>
            Clear the collection of patterns
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlRemoteNode.#ctor(NFX.Erlang.ErlLocalNode)">
            <summary>
            Constructor used for creating a remote node by the Acceptor of incoming connections
            </summary>
            <param name="home"></param>
        </member>
        <member name="M:NFX.Erlang.ErlRemoteNode.#ctor(NFX.Erlang.ErlLocalNode,System.String,System.Nullable{NFX.Erlang.ErlAtom})">
            <summary>
            Create a peer node
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlRemoteNode.#ctor(NFX.Erlang.ErlLocalNode,NFX.Erlang.ErlAtom,System.Nullable{NFX.Erlang.ErlAtom})">
            <summary>
            Create a peer node
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlRemoteNode.Connect(NFX.Erlang.ErlLocalNode)">
            <summary>
            Create a connection to a remote node
            </summary>
            <param name="self">the local node from which you wish to connect</param>
            <returns>A connection to the remote node</returns>
        </member>
        <member name="P:NFX.Erlang.Internal.ErlBlockingQueue`1.Handle">
            <summary>
            Queue message arrival notification handle
            </summary>
        </member>
        <member name="T:NFX.Erlang.Internal.ErlIoServer">
            <summary>
            I/O server processing distributed I/O operations from remote
            Erlang nodes
            </summary>
            <remarks>
            <see href="http://erlang.org/doc/apps/stdlib/io_protocol.html"/>
            </remarks>
        </member>
        <member name="T:NFX.Erlang.Internal.ErlRpcServer">
            <summary>
            Server that handles inbound RPC calls
            </summary>
        </member>
        <member name="T:NFX.Erlang.Internal.MboxRegistry">
            <summary>
            This class implements a registry of Mailboxes indexed by Name and Pid
            </summary>
        </member>
        <member name="M:NFX.Erlang.Internal.MboxRegistry.Create(NFX.Erlang.ErlAtom)">
            <summary>
            Create a named mailbox if one is not already registered, otherwise
            return registered mailbox
            </summary>
        </member>
        <member name="M:NFX.Erlang.Internal.MboxRegistry.Create(System.Boolean)">
            <summary>
            Return a new or unused mailbox from freelist
            </summary>
        </member>
        <member name="M:NFX.Erlang.Internal.MboxRegistry.Register(NFX.Erlang.ErlMbox)">
            <summary>
            Register an unnamed mailbox with the registry
            </summary>
        </member>
        <member name="M:NFX.Erlang.Internal.MboxRegistry.Register(System.String,NFX.Erlang.ErlMbox)">
            <summary>
            Register a named mailbox with the registry. Name must not be empty
            </summary>
        </member>
        <member name="M:NFX.Erlang.Internal.MboxRegistry.Register(NFX.Erlang.ErlAtom,NFX.Erlang.ErlMbox)">
            <summary>
            Register a named mailbox with the registry. Name must not be empty
            </summary>
        </member>
        <member name="M:NFX.Erlang.Internal.MboxRegistry.Unregister(NFX.Erlang.ErlMbox)">
            <summary>
            Unregister a mailbox and move it to free-list
            </summary>
        </member>
        <member name="M:NFX.Erlang.Internal.MboxRegistry.Clear">
            <summary>
            Clear the registry
            </summary>
        </member>
        <member name="P:NFX.Erlang.Internal.MboxRegistry.RegNames">
            <summary>
            Return a list of all registered mailboxes
            </summary>
        </member>
        <member name="P:NFX.Erlang.Internal.MboxRegistry.Item(NFX.Erlang.ErlAtom)">
            <summary>
            Look up a mailbox based on its name
            </summary>
            <returns>Mailbox or null if the name is not registered</returns>
        </member>
        <member name="P:NFX.Erlang.Internal.MboxRegistry.Item(NFX.Erlang.ErlPid)">
            <summary>
            Look up a mailbox based on its pid
            </summary>
            <returns>Mailbox reference or null if the pid is not present on this node</returns>
        </member>
        <member name="T:NFX.Erlang.ErlTrace">
            <summary>
            Special class used for passing tracing information in Erlang distributed 
            messages SEND_TT, EXIT_TT, REG_SEND_TT, EXIT2_TT
            </summary>
            <remarks>
            See 
            </remarks>
        </member>
        <member name="T:NFX.Erlang.IErlObject">
            <summary>
            All Erlang terms implement this interface
            </summary>
        </member>
        <member name="M:NFX.Erlang.IErlObject.Clone">
            <summary>
            Clone an instance of Erlang object by performing deep copy of non-scalar terms
            and shallow copy of scalar terms
            </summary>
        </member>
        <member name="M:NFX.Erlang.IErlObject.Match(NFX.Erlang.IErlObject,NFX.Erlang.ErlVarBind)">
            <summary>
            Perform pattern match on this Erlang term, storing matched variables
            found in the pattern into the binding.
            </summary>
        </member>
        <member name="M:NFX.Erlang.IErlObject.Match(NFX.Erlang.IErlObject)">
            <summary>
            Perform pattern match on this Erlang term returning null if match fails
            or a dictionary of matched variables bound in the pattern
            </summary>
        </member>
        <member name="M:NFX.Erlang.IErlObject.Matches(NFX.Erlang.IErlObject)">
            <summary>
            Perform pattern match on this Erlang term without binding any variables
            </summary>
        </member>
        <member name="M:NFX.Erlang.IErlObject.Subst(NFX.Erlang.IErlObject@,NFX.Erlang.ErlVarBind)">
            <summary>
            Substitute variables in a given Erlang term provided a dictionary
            of bound values
            </summary>
        </member>
        <member name="P:NFX.Erlang.IErlObject.TypeOrder">
            <summary>
            Defines order of the Erlang term for comparison purposes
            </summary>
        </member>
        <member name="P:NFX.Erlang.IErlObject.IsScalar">
            <summary>
            Determines whether the underlying type is scalar or complex (i.e. tuple, list)
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlTupleBase.#ctor(NFX.Erlang.IErlObject[],System.Boolean)">
            <summary>
            Create an Erlang string from the given string
            </summary>
        </member>
        <member name="F:NFX.Erlang.ErlTupleBase.m_Items">
            <summary>
            The index of this atom in the global atom table
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlTupleBase.Cast``1(System.Int32)">
            <summary>
            Return index'th element cast to the given type
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlTupleBase.Add(NFX.Erlang.IErlObject)">
            <summary>
            Add an item to a mutable list. This method must be used only during
            list construction phase, since it treats the list as a mutable entity
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlTupleBase.ToString">
            <summary>
            Get the string representation of the list.
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlTupleBase.Equals(System.Object)">
            <summary>
            Determine if this instance is equal to the object
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlTupleBase.Equals(NFX.Erlang.IErlObject)">
            <summary>
            Determine if two Erlang objects are equal
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlTupleBase.GetHashCode">
            <summary>
            Get internal hash code
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlTupleBase.CompareTo(System.Object)">
            <summary>
            Compare this instance to the object.
            Negative value means that the atom is less than obj, positive - greater than the obj
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlTupleBase.CompareTo(NFX.Erlang.IErlObject)">
            <summary>
            Compare this instance to the IErlObject.
            Negative value means that the atom is less than obj, positive - greater than the obj
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlTupleBase.Match(NFX.Erlang.IErlObject)">
            <summary>
            Perform pattern match on this Erlang term returning null if match fails
            or a dictionary of matched variables bound in the pattern
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlTupleBase.Match(NFX.Erlang.IErlObject,NFX.Erlang.ErlVarBind)">
            <summary>
            Perform pattern match on this Erlang term, storing matched variables
            found in the pattern into the binding.
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlTupleBase.Matches(NFX.Erlang.IErlObject)">
            <summary>
            Perform pattern match on this Erlang term without binding any variables
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlTupleBase.Clone">
            <summary>
            Clone an instance of the object (non-scalar immutable objects are copied by reference)
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlTupleBase.Value">
            <summary>
            Get the list of Erlang terms contained in this object
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlTupleBase.IsScalar">
            <summary>
            Determines whether the underlying type is scalar or complex (i.e. tuple, list)
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlTupleBase.Item(System.Int32)">
            <summary>
            Return index'th element from the container
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlTupleBase.Count">
            <summary>
            Return number of elements in the container
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlTuple.#ctor(NFX.Erlang.IErlObject[])">
            <summary>
            Create an Erlang tuple from the given list of items
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlTuple.op_Implicit(NFX.Erlang.ErlTuple)~System.Collections.Generic.List{NFX.Erlang.IErlObject}">
            <summary>
            Implicit conversion of atom to string
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlTuple.Equals(NFX.Erlang.IErlObject)">
            <summary>
            Determine if two Erlang objects are equal
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlTuple.Equals(NFX.Erlang.ErlTuple)">
            <summary>
            Determine if two Erlang tuples are equal
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlTuple.ValueAsDateTime">
            <summary>
            Returns tuple value as DateTime in UTC if the tuple is in the form
            <code>{MegaSec, Sec, MicroSec}</code>
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlTrace.#ctor(System.Int32,System.Int32,System.Int32,NFX.Erlang.ErlPid,System.Int32)">
            <summary>
            Create an Erlang trace from the given arguments
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlTrace.op_Implicit(NFX.Erlang.ErlTrace)~System.Collections.Generic.List{NFX.Erlang.IErlObject}">
            <summary>
            Implicit conversion of atom to string
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlTrace.Equals(NFX.Erlang.IErlObject)">
            <summary>
            Determine if two Erlang objects are equal
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlTrace.Equals(NFX.Erlang.ErlTrace)">
            <summary>
            Determine if two Erlang tuples are equal
            </summary>
        </member>
        <member name="T:NFX.ExternalRandomGenerator">
            <summary>
            Represents a random generator which is based on System.Random() yet has an ability to feed external samples into it. 
             Use ExtrenalRandomGenerator.Instance to use the default thread-safe instance.
            </summary>
            <remarks>
            Introduces external entropy into the generation sequence by adding a sample into the ring buffer.
            Call FeedExternalEntropySample(int sample) method from places that have true entropy values, i.e.
             a network-related code may have good entropy sources in server applications.
             External entropy sources may rely on user-dependent actions, i.e.:
              number of bytes/requests received per second, dollar(or cent remainders) amount of purchases made (on a server),
              zip codes of customers, IP addresses of site visitors, average noise level sampled on an open WAVE device(microphone),
               mouse position (i.e. in GUI app) etc...
             This class MAY be crypto-safe if it is fed a good entropy data at high rate, however that depends on the use pattern.
             The framework implementation feeds some entropy from Glue and cache components infrequently (once every few seconds),
              which is definitely not strong for cryptography
            </remarks>
        </member>
        <member name="M:NFX.ExternalRandomGenerator.#ctor">
            <summary>
            Create new instance of ExternalRandomGenerator. Create new instances only if you need to use different sample ring buffers.
            In majority of cases use ExternalRandomGenerator.Instance to use default instance instead of creating a new instance.
            Default instance is thread-safe for process-wide use
            </summary>
        </member>
        <member name="M:NFX.ExternalRandomGenerator.FeedExternalEntropySample(System.Int32)">
            <summary>
            Introduces external entropy into the generation sequence by adding a sample into the ring buffer.
            Call this method from places that have true entropy values, i.e.
             a network-related code may have good entropy sources in server applications.
             External entropy sources may rely on user-dependent actions, i.e.:
              number of bytes/requests received per second, dollar(or cent remainders) amount of purchases made (on a server),
              zip codes of customers, IP addresses of site visitors, average noise level sampled on an open WAVE device(microphone),
               mouse position (i.e. in GUI app) etc...
            </summary>
        </member>
        <member name="M:NFX.ExternalRandomGenerator.NextScaledRandomInteger(System.Int32,System.Int32)">
            <summary>
            Generates random number in min..max range
            </summary>
        </member>
        <member name="M:NFX.ExternalRandomGenerator.NextRandomWebSafeString(System.Int32,System.Int32)">
            <summary>
            Generates a random string of chars which are safe for the use on the web - 
             a string that only contains "a-z"/"A-Z" and "0-9" and "-"/"_" chars, i.e.: "bo7O0EFasZe-wEty9w0__JiOKk81".
             The length of the string can not be less than 4 and more than 1024 chars
            </summary>
        </member>
        <member name="P:NFX.ExternalRandomGenerator.Instance">
            <summary>
            Returns the default instance of the generator. This instance is thread-safe
            </summary>
        </member>
        <member name="P:NFX.ExternalRandomGenerator.NextRandomInteger">
            <summary>
            Generates next random integer in the Int32.MinValue..Int32.MaxValue diapason
            </summary>
        </member>
        <member name="P:NFX.ExternalRandomGenerator.NextRandom16Bytes">
            <summary>
            Generates random byte[16] buffer
            </summary>
        </member>
        <member name="P:NFX.ExternalRandomGenerator.NextRandomDouble">
            <summary>
            Returns 0..1 random double
            </summary>
        </member>
        <member name="T:NFX.Financial.Amount">
            <summary>
            Represents monetary amount with currency
            </summary>
        </member>
        <member name="M:NFX.Financial.Amount.IsSameCurrencyAs(NFX.Financial.Amount)">
            <summary>
            Perfoms case-insensitive currency equality comparison
            </summary>
        </member>
        <member name="T:NFX.Financial.FinancialException">
            <summary>
            Base exception thrown by the financial-related framework
            </summary>
        </member>
        <member name="T:NFX.Geometry.LatLng">
            <summary>
            Provides support for Latitude/Longitude logic
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.MpxBinding">
            <summary>
            Provides asynchronous communicating pattern based on asynchronous virtual socket.
            The concrete socket may be based on OS-supported technology i.e. -  IO completion ports on Windows
            </summary>
        </member>
        <member name="T:NFX.Glue.Binding">
            <summary>
            Represents a particular named binding. 
            Binding type defines a protocol by implementing a transport instance management strategy
            that support particular technology, such as blocking TCP or async ZeroMQ.
            Binding instance retains state/config information about all transports
            and has logic for Node's host:service resolution.
            Bindings are services, meaning - they can have state/threads that
            manage transport channels that operate under binding
            </summary>
        </member>
        <member name="T:NFX.Glue.GlueComponentService">
            <summary>
            Provides base functionality for internal glue component implementations 
            </summary>
        </member>
        <member name="M:NFX.Glue.GlueComponentService.ExternalParametersForGroups(System.String[])">
            <summary>
            Returns named parameters that can be used to control this component
            </summary>
        </member>
        <member name="M:NFX.Glue.GlueComponentService.ExternalGetParameter(System.String,System.Object@,System.String[])">
            <summary>
            Gets external parameter value returning true if parameter was found
            </summary>
        </member>
        <member name="M:NFX.Glue.GlueComponentService.ExternalSetParameter(System.String,System.Object,System.String[])">
            <summary>
            Sets external parameter value returning true if parameter was found and set
            </summary>
        </member>
        <member name="P:NFX.Glue.GlueComponentService.InstrumentationEnabled">
            <summary>
            Implements IInstrumentable
            </summary>
        </member>
        <member name="P:NFX.Glue.GlueComponentService.ExternalParameters">
            <summary>
            Returns named parameters that can be used to control this component
            </summary>
        </member>
        <member name="F:NFX.Glue.Binding.DEFAULT_STAT_TIMES_EMA_FACTOR">
            <summary>
            Defines how much smoothing the timing statistics filter does - the lower the number the more smoothing is done.
            Smoothing makes stat times insensitive to some seldom delays that may happen every now and then
            </summary>
        </member>
        <member name="M:NFX.Glue.Binding.GetClientCallStatTimeKey(NFX.Glue.ClientEndPoint,NFX.Glue.Protocol.RequestMsg)">
            <summary>
            Extracts necessary information from client:request pair that characterizes the particular call
             for the purpose of call timing
            </summary>
        </member>
        <member name="M:NFX.Glue.Binding.AreNodesIdentical(NFX.Glue.Node,NFX.Glue.Node)">
            <summary>
            Returns true when two nodes represent the same binding, host and service identities.
            The implementation depends on binding, for example some binding may recognize an optional parameter as part of host segment, however
             that parameter does not change the identity of the node instance
            </summary>
        </member>
        <member name="M:NFX.Glue.Binding.DispatchCall(NFX.Glue.ClientEndPoint,NFX.Glue.Protocol.RequestMsg)">
            <summary>
            Dispatches a call allocating new or re-using existing transport if needed. The strategy depends on particular Binding implementation.
            This call is thread-safe
            </summary>
        </member>
        <member name="M:NFX.Glue.Binding.CheckRunningState(System.Boolean)">
            <summary>
            Ensures that application and binding runtime are running or throws otherwise 
            </summary>
        </member>
        <member name="M:NFX.Glue.Binding.DumpMsg(System.Boolean,NFX.Glue.Protocol.Msg,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Conditionally dumps message to disk
            </summary>
            <param name="server">True for server-side message</param>
            <param name="msg">Message that was deserialized/serialized. If null then error happened while deserializing</param>
            <param name="buffer">Message body</param>
            <param name="offset">Start index in buffer</param>
            <param name="count">Byte size of message body</param>
        </member>
        <member name="M:NFX.Glue.Binding.DumpMsg(System.Boolean,NFX.Glue.Protocol.Msg,System.Func{System.ArraySegment{System.Byte}})">
            <summary>
            Conditionally dumps message to disk where the data is lazily obtained by calling dataFun
            </summary>
        </member>
        <member name="M:NFX.Glue.Binding.DumpMsg(System.Boolean,NFX.Glue.Protocol.Msg,System.ArraySegment{System.Byte})">
            <summary>
            Conditionally dumps message to disk
            </summary>
            <param name="server">True for server-side message</param>
            <param name="msg">Message that was deserialized/serialized. If null then error happened while deserializing</param>
            <param name="data">Data</param>
        </member>
        <member name="F:NFX.Glue.Binding.m_ClientTransportAllocatorLocks">
            <summary>
            Hash table of locks used during new transport allocation, must be prime size
            </summary>
        </member>
        <member name="M:NFX.Glue.Binding.AcquireClientTransportForCall(NFX.Glue.ClientEndPoint,NFX.Glue.Protocol.RequestMsg)">
            <summary>
            Returns an instance of transport suitable for a call. The implementation may return existing transport or allocate a new instance.
            The call is thread-safe
            </summary>
        </member>
        <member name="M:NFX.Glue.Binding.MakeNewClientTransport(NFX.Glue.ClientEndPoint)">
            <summary>
            Factory method - Override to make an instance of a new client transport suitable for particular binding type
            </summary>
        </member>
        <member name="M:NFX.Glue.Binding.ConfigureAndStartNewClientTransport(NFX.Glue.ClientTransport)">
            <summary>
            Override to perform custom transport preparation and launch
            </summary>
        </member>
        <member name="M:NFX.Glue.Binding.ReleaseClientTransportAfterCall(NFX.Glue.ClientTransport)">
            <summary>
            Releases a transport instance that was acquired for call.
            The implementation may return this instance back to the pool of available transports or deallocate it.
            The default implementation releases the instance back to the pool
            </summary>
        </member>
        <member name="M:NFX.Glue.Binding.TryGetExistingAcquiredTransportPerRemoteNode(NFX.Glue.Node)">
            <summary>
            Tries to acquire an available client transport to make a call.
            This method respects binding/transport settings that impose a limit on the number of
             open concurrent transports and timeouts for acqusition waiting
            </summary>
            <param name="remoteNode">remote node to connect to</param>
            <returns>Available acquired transport or null</returns>
        </member>
        <member name="P:NFX.Glue.Binding.OperationFlow">
            <summary>
            Returns sync/async flow that this binding provides
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.EncodingFormat">
            <summary>
            Returns name of msg format encoding
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.Transports">
            <summary>
            Returns all transports in the binding stack
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.ClientTransports">
            <summary>
            Returns all client transports in the binding stack
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.ServerTransports">
            <summary>
            Returns all server transports in the binding stack
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.ConfigNode">
            <summary>
            Returns configuration node for this named instance
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.ClientMsgInspectors">
            <summary>
            Returns client message inspectors for this instance
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.ServerMsgInspectors">
            <summary>
            Returns server message inspectors for this instance
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.ClientDump">
            <summary>
            Turns on/off client message dumping to disk. Turning on dumping has negative effect on performance and consumes resources
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.ServerDump">
            <summary>
            Turns on/off server message dumping to disk. Turning on dumping has negative effect on performance and consumes resources
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.DumpPath">
            <summary>
            Set the path for message dumping. Must be an existing navigable path
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.DumpMsgFormat">
            <summary>
            Set the format for message dumping
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.InstrumentClientTransportStat">
            <summary>
            Defines whether client transport statistics is periodically dumped into instrumentation
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.InstrumentServerTransportStat">
            <summary>
            Defines whether server transport statistics is periodically dumped into instrumentation
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.MeasureStatTimes">
            <summary>
            Defines whether message processing latency should be measured - i.e. messages time-stamped on arrival
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.StatTimeTicks">
            <summary>
            Returns current time in system frequency-dependent ticks.
            This property is used to measure accurate times and depends on MeasureStatTimes set to true, otherwise 0 is returned
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.StatTimesEMAFactor">
            <summary>
            Defines how much smoothing the timing statistics filter does - the lower the number the more smoothing is done.
            Smoothing makes stat times insensitive to some seldom delays that may happen every now and then
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.ClientTransportIdleTimeoutMs">
            <summary>
            Specifies when client transports get auto-closed. Interval is measured in ms. Zero means indefinite/never closed transport.
            For more info, see 'NFX.Glue: Client Call Concurrency' topic in manual/blog
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.ServerTransportIdleTimeoutMs">
            <summary>
            Specifies when server transports get auto-closed. Interval is measured in ms. Zero means indefinite/never closed transport.
            For more info, see 'NFX.Glue: Client Call Concurrency' topic in manual/blog
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.ClientTransportExistingAcquisitionTimeoutMs">
            <summary>
            Sets the length of interval for the binding trying to acquire existing client transport instance to make a call.
            When this interval is exhausted then binding tries to allocate a new client transport per remote address, unless
             other limits prohibit (max transport count). The value has to be greater or equal to zero. 
            NOTE: this property works in conjunction with ClientTransportCoutWaitThreshold, if the number of active client transports
             is below ClientTransportCoutWaitThreshold, then binding does not wait and allocates a new client transport right away until
              ClientTransportCoutWaitThreshold limit is reached, then binding will try to acquire existing transport for ClientTransportExistingAcquisitionTimeoutMs milliseconds.
            For more info, see 'NFX.Glue: Client Call Concurrency' topic in manual/blog  
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.ClientTransportCountWaitThreshold">
            <summary>
            Sets the threshold, expressed as the number of active client transports per remote address, below which binding will always allocate a new instance
             of client transport without trying/waiting to acquire an existing one. When this number is exceeded then binding will try to acquire an existing
             client transport instance for up to ClientTransportExistingAcquisitionTimeoutMs milliseconds.
             For more info, see 'NFX.Glue: Client Call Concurrency' topic in manual/blog  
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.ClientTransportMaxCount">
            <summary>
            Imposes a limit on number of active client transports per remote address. Once this limit is reached the binding will block until it can acquire
            an existing transport instance. Set value to zero to remove the limit.
             For more info, see 'NFX.Glue: Client Call Concurrency' topic in manual/blog   
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.ClientTransportMaxExistingAcquisitionTimeoutMs">
            <summary>
            Imposes a timeout for binding trying to get an existing transport instance per remote address.
            Binding throws ClientCallException when this timeout is exceeded. A value of zero removes the limit
            </summary>
        </member>
        <member name="M:NFX.Glue.Native.MpxBinding.MakeOrReuseChunk">
            <summary>
            Fetches available existing chunk from cache or creates a new one.
            Called by new sockets by incipient connections
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.MpxBinding.OperationFlow">
            <summary>
            Mpx binding is always async by definition
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.MpxBinding.SocketFactory">
            <summary>
            Returns factory used to make new socket instances per particular technology
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.MpxBinding.MaxMsgSize">
            <summary>
            Imposes a limit on maximum message size in bytes
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.MpxBinding.IdleChunkLifeSec">
            <summary>
            Specifies the maximum length of life of an unused memory chunk in the pool.
            The idle chunk will be evicted after this interval. 
            This setting is common for both server and client as they share the same pool
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.MpxBinding.MaxChunkPoolCount">
            <summary>
            Imposes a limit on how many memory chunks can be stored in free chunk pool.
            The chunks can be resued for making new connections.
            This setting is common for both server and client as they share the same pool
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.MpxBinding.SocketLingerSec">
            <summary>
            Sets socket linger options.
            This setting is common for both server and client as they have the same channel semantics
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.MpxClientTransport">
            <summary>
            Implements asynchronous MPX client transport for MpxBinding
            </summary>
        </member>
        <member name="T:NFX.Glue.Transport">
            <summary>
            Transports are thread-safe and are intended for use by multiple threads from ClientCallReactor 
            and ServerProcessor when bindings operate in OperationFlow.Asynchronous mode.
            Transports are acquired by the thread that creates them
            </summary>
        </member>
        <member name="M:NFX.Glue.Transport.stat_Time(System.String,System.Int64)">
            <summary>
            Processes named time measurement statistical sample by using EMA filter
            </summary>
            <param name="key">Name of time measurement key</param>
            <param name="ticks">Duration in ticks</param>
        </member>
        <member name="M:NFX.Glue.Transport.ResetStats">
            <summary>
            Resets all statistical counters
            </summary>
        </member>
        <member name="M:NFX.Glue.Transport.DumpInstrumentationData">
            <summary>
            Dumps instrumentation data
            </summary>
        </member>
        <member name="M:NFX.Glue.Transport.DoDumpInstrumentationData">
            <summary>
            Override to dump instrumentation data, dont forget to call base to dump basic metrics
            </summary>
        </member>
        <member name="M:NFX.Glue.Transport.TryAcquire">
            <summary>
            A thread-safe operation that tries to acquire(reserve) this instance for exclusive use. 
            Returns true if acqusition succeded, false is this instance is reserved by someone else 
            </summary>
        </member>
        <member name="M:NFX.Glue.Transport.Release">
            <summary>
            Releases transport by setting Acquired flag to false so it can be used by other operations
            </summary>
        </member>
        <member name="M:NFX.Glue.Transport.CheckRunningState">
            <summary>
            Ensures that application and transport instance are running or throws otherwise 
            </summary>
        </member>
        <member name="P:NFX.Glue.Transport.Acquired">
            <summary>
            Returns true when this transport instance has been acquired by some operation and is busy
            </summary>
        </member>
        <member name="P:NFX.Glue.Transport.Binding">
            <summary>
            Returns a binding that this transport operates under 
            </summary>
        </member>
        <member name="P:NFX.Glue.Transport.Glue">
            <summary>
            Returns glue implementation that this transport is under 
            </summary>
        </member>
        <member name="P:NFX.Glue.Transport.TransportKind">
            <summary>
            Reports if this is a server or client transport
            </summary>
        </member>
        <member name="P:NFX.Glue.Transport.ExpirationStart">
            <summary>
            Returns timestamp when manager touched the instance for last time and no traffic went through it since
            </summary>
        </member>
        <member name="P:NFX.Glue.Transport.IdleAgeMs">
            <summary>
            Returns the duration of transport idle period in ms.
            </summary>
        </member>
        <member name="P:NFX.Glue.Transport.Node">
            <summary>
            Returns node that this transport services
            </summary>
        </member>
        <member name="P:NFX.Glue.Transport.StatBytesReceived">
            <summary>
            Returns how many bytes were received since .ctor or last ResetStats() call
            </summary>
        </member>
        <member name="P:NFX.Glue.Transport.StatBytesSent">
            <summary>
            Returns how many bytes were sent since .ctor or last ResetStats() call
            </summary>
        </member>
        <member name="P:NFX.Glue.Transport.StatMsgReceived">
            <summary>
            Returns how many messages were received since .ctor or last ResetStats() call
            </summary>
        </member>
        <member name="P:NFX.Glue.Transport.StatMsgSent">
            <summary>
            Returns how many messages were sent since .ctor or last ResetStats() call
            </summary>
        </member>
        <member name="P:NFX.Glue.Transport.StatErrors">
            <summary>
            Returns how many message processing errors happened since .ctor or last ResetStats() call
            </summary>
        </member>
        <member name="P:NFX.Glue.Transport.StatTimes">
            <summary>
            Returns enumerable of named times measured in double second fractions. 
            The returned times are EMA-filtered from supplied individual measurement samples 
            </summary>
        </member>
        <member name="M:NFX.Glue.ClientTransport.SendRequest(NFX.Glue.ClientEndPoint,NFX.Glue.Protocol.RequestMsg,NFX.Glue.Protocol.CallOptions)">
            <summary>
            Sends a client request into remote endpoint.
            This is a blocking call for bindings that are OperationFlow.Synchronous and
            result arrives immediately into CallSlot.
            </summary>
        </member>
        <member name="M:NFX.Glue.ClientTransport.DoSendRequest(NFX.Glue.ClientEndPoint,NFX.Glue.Protocol.RequestMsg,NFX.Glue.Protocol.CallOptions)">
            <summary>
            Override to send a client request into remote endpoint.
            This is a blocking call for bindings that are OperationFlow.Synchronous and
            result arrives immediately into CallSlot.
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.MpxServerTransport">
            <summary>
            Implements asynchronous MPX server transport for MpxBinding
            </summary>
        </member>
        <member name="M:NFX.Glue.ServerTransport.#ctor(NFX.Glue.Binding,NFX.Glue.ServerEndPoint)">
            <summary>
            Creates an instance of listener transport
            </summary>
        </member>
        <member name="M:NFX.Glue.ServerTransport.#ctor(NFX.Glue.Binding,NFX.Glue.ServerTransport)">
            <summary>
            Creates instance of a transport that resulted from connection accept by
            listener. Not all technologies support listener/child transports (TCP does)
            </summary>
        </member>
        <member name="M:NFX.Glue.ServerTransport.SendResponse(NFX.Glue.Protocol.ResponseMsg)">
            <summary>
            Sends a response into remote client endpoint
            </summary>
        </member>
        <member name="M:NFX.Glue.ServerTransport.DoSendResponse(NFX.Glue.Protocol.ResponseMsg)">
            <summary>
            Override to send a response into remote client endpoint
            </summary>
        </member>
        <member name="P:NFX.Glue.ServerTransport.ServerEndpoint">
            <summary>
            Returns server endpoint instance  that opened this transport
            </summary>
        </member>
        <member name="P:NFX.Glue.ServerTransport.IsListener">
            <summary>
            Indicates whether this instance is the one that accepts connections.
            Depending on implementation listeners may allocate other transports after
            they accept incoming connect request (i.e. TCP)
            </summary>
        </member>
        <member name="P:NFX.Glue.ServerTransport.Listener">
            <summary>
            Returns a listener transport that opened this one. If this is a listener
            transport then returns null. Not all technologies support listener/child
            transports (TCP does)
            </summary>
        </member>
        <member name="M:NFX.Glue.ServerTransport`1.#ctor(NFX.Glue.Binding,NFX.Glue.ServerEndPoint)">
            <summary>
            Creates an instance of listener transport
            </summary>
        </member>
        <member name="M:NFX.Glue.ServerTransport`1.#ctor(NFX.Glue.Binding,NFX.Glue.ServerTransport)">
            <summary>
            Creates instance of a transport that resulted from connection accept by listener.
            Not all technologies support listener/child transports (TCP does)
            </summary>
        </member>
        <member name="M:NFX.Glue.Native.MpxServerTransport.#ctor(NFX.Glue.Native.MpxBinding,NFX.Glue.ServerEndPoint,System.Net.IPAddress,System.Int32)">
            <summary>
            Allocates a listener transport
            </summary>
        </member>
        <member name="M:NFX.Glue.Native.MpxServerTransport.ClientSiteConnected(NFX.Glue.Native.MpxServerSocket)">
            <summary>
            Notifies the transport that site connection has arrived so the transport may allocate some site/socket-specific state.
            Called from listener
            </summary>
        </member>
        <member name="M:NFX.Glue.Native.MpxServerTransport.ClientSiteDisconnected(NFX.Glue.Native.MpxServerSocket)">
            <summary>
            Notifies the transport that site connection has closed/broke so the transport may de-allocate some site/socket-specific state.
            Called from listener
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.MpxSocketReceiveAction`1">
            <summary>
            Delivers wire msg from another side. DO NOT use WireMsg beyound the implementation of this delegate,
             if needed make a copy of msg.Data as the memory will be freed after this call returns
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.MpxSocket`1">
            <summary>
            Base for MpxSockets implementation. An MpxSocket represents an asynchronous bi-directional channel of communication
            that delivers binary/wire messages of flexible size.
            The socket is NOT THREAD SAFE for calling Send() from parallel threads. Send() is done synchronously on the
            calling thread, i.e. the sender waits until the data is written into the OS socket buff.
             Receive is invoked by internal/system/io thread asynchronously and should not block for long (seconds)
            </summary>
        </member>
        <member name="M:NFX.Glue.Native.MpxSocket`1.ReleaseMemChunksAfterAsyncOperations">
            <summary>
            Releases socket memory chunks. This method MUST BE called AFTER all pending async IO is done,
            otherwise the chunks may get released to the pool and get corrupted by the prior operation
            </summary>
        </member>
        <member name="M:NFX.Glue.Native.MpxSocket`1.DoReleaseMemChunksAfterAsyncOperations">
            <summary>
            Do not call this method, override only when freeing more than 2 standard chunks (send/recv)
            </summary>
        </member>
        <member name="M:NFX.Glue.Native.MpxSocket`1.Send(NFX.Glue.Native.WireMsg)">
            <summary>
            Adds the specified socket msg to the outgoing stack. 
            This is a synchronous blocking call that executes until the data is written 
            into socket stack (but not necessarily delivered). If send error occurs then socket is
            marked as !Active (Disposed)
            </summary>
        </member>
        <member name="M:NFX.Glue.Native.MpxSocket`1.GetSendChunk(System.Int32)">
            <summary>
            Reserves a chunk of memory of the suggested size for network send operation.
            The buffer must be released by a call to ReleaseSendBuffer().
            Keep in mind that this method is NOT RE-ENTRANT by this or any other thread until corresponding ReleaseSendChunk() is called.
            MpxSocket is not thread safe for sends in general.
            </summary>
        </member>
        <member name="M:NFX.Glue.Native.MpxSocket`1.ReleaseSendChunk">
            <summary>
            Releases previously reserved buffer, i.e. may trim excess allocation after a large message
            </summary>
        </member>
        <member name="M:NFX.Glue.Native.MpxSocket`1.AcceptManagerVisit(System.DateTime)">
            <summary>
            Override to perform maintenance i.e. trim excessive m_SendChunk size etc..
            This method is called by Glue/Binding/Transport runtime.
            Also resets last last idle manager visit timestamp which is used for socket closing
            </summary>
        </member>
        <member name="M:NFX.Glue.Native.MpxSocket`1.InvokeReceive(NFX.Glue.Native.WireMsg)">
            <summary>
            Calls ReceiveAction callback guarding for possible unhandled receive action errors
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.MpxSocket`1.Transport">
            <summary>
            Returns transport that this socket is under
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.MpxSocket`1.EndPoint">
            <summary>
            Returns IP End point that this socket services, remote server for client socket and remote client for server sockets
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.MpxSocket`1.Socket">
            <summary>
            Returns the underlying socket
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.MpxSocket`1.Active">
            <summary>
            True when socket is not disposing and runtime is not shutting down
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.MpxSocket`1.ClientSite">
            <summary>
            Returns client site for the computer that initiated the call.
            Server socket returns the transmitted value from client. Client socket returns the one that was
             sent to server upon handshake
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.MpxSocket`1.LastIdleManagerVisit">
            <summary>
            Returns timestamp of last manager visit since then no traffic came through. Null indicates that traffic came though
             and socket has not been idle since last visit. Manager is an extrenal visitor that closes idle sockets
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.MpxClientSocket">
            <summary>
            Represents client-side asynchronous socket. This socket initiates a connection to MpxServerSocket
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.MpxServerSocket">
            <summary>
            Represents server-side asynchronous socket that clients connect to
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.MpxServerSocket.Listener">
            <summary>
            Returns listener socket that initiated/opened this server socket
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.MpxListener">
            <summary>
            Represents a server-side listener socket that accepts the calls
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.MpxListener.Transport">
            <summary>
            Returns transpoirt that this listener listens under
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.MpxListener.EndPoint">
            <summary>
            Returns IP End point that this listener listens on
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.MpxSocketFactory">
            <summary>
            Defines factory abstraction that creates socket per particular technology
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.MpxWinSocketFactory">
            <summary>
            Factory that makes MpxWin sockets based on Windows-IO completion ports
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.MpxWinClientSocket">
            <summary>
            Implements a MPX client socket using Windows IO completion ports for receive
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.MpxWinServerSocket">
            <summary>
            Implements a MPX server socket using Windows IO completion ports for receive
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.MpxWinListener">
            <summary>
            Implements a MPX socket listener that accepts connections into MpxWinServerSocket
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.MemChunk">
            <summary>
            Represents a stream/writable chunk of memory backed by an array buffer
            </summary>
        </member>
        <member name="F:NFX.Glue.Native.MemChunk._LastReleaseUtc">
            <summary>
            Whan was the chunk released to the pool for the last time
            </summary>
        </member>
        <member name="F:NFX.Glue.Native.MemChunk.Acquired">
            <summary>
            True if chunk is taken out of pool by some socket
            </summary>
        </member>
        <member name="F:NFX.Glue.Native.MemChunk.stat_MaxUsedPosition">
            <summary>
            Used for statistics/tracking 
            </summary>
        </member>
        <member name="F:NFX.Glue.Native.MemChunk.stat_MaxLength">
            <summary>
            Used for statistics/tracking 
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.WireMsg">
            <summary>
            Represents a message that is transmitted over the wire:
            </summary>
            <remarks>
              Wire Msg gets serialized like so: 
                +----+ | +----------------------------------------------+---------+ | +-------+
                |Size| | |                 Frame Content                | Hdrs... | | | GlueM |
                +----+ | +----------------------------------------------+---------+ | +-------+
                   ^     \----------------------+---------------------------------/       ^
                   |                            |                                         |
                   |                            |                                         +-- Msg data (payload) , i.e. Glue message body
                   |                            +----------------------------- Transport Frame with optional var length headers
                   +-------------------------------------------------------- Total msg size 4 bytes
            </remarks>
        </member>
        <member name="M:NFX.Glue.Native.WireMsg.#ctor(NFX.Glue.Native.MemChunk)">
            <summary>
            Creates WireMsg around pre-filled memory chunk that includes msg size - first 4 bytes
            </summary>
        </member>
        <member name="F:NFX.Glue.Native.WireMsg.Data">
            <summary>
            Returns the data chunk received/sent from/to socket INCLUDING the total size (first 4 bytes BEint32)
            </summary>
        </member>
        <member name="M:NFX.Glue.Native.WireMsg.UpdateBufferStats">
            <summary>
            Update buffers statistics
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.WireMsg.Frame">
            <summary>
            Returns frame serialized in data
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.WireMsg.Buffer">
            <summary>
            Returns data byte buffer
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.WireMsg.BufferUsedSize">
            <summary>
            Returns data byte buffer use count, i.w. the buffer may be physically larger, however only BufferUsedSize must be transmitted
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.FrameType">
            <summary>
            Type of transport frame message
            </summary>
        </member>
        <member name="F:NFX.Glue.Native.FrameType.GlueMsg">
            <summary>
            Indicator that following payload is a standard Glue message
            </summary>
        </member>
        <member name="F:NFX.Glue.Native.FrameType.Heartbeat">
            <summary>
            Indicator of the oneway hartbeat message
            </summary>
        </member>
        <member name="F:NFX.Glue.Native.FrameType.Echo">
            <summary>
            Indicator that this is an echo request message and sending party awaits the EchoResponse message
            </summary>
        </member>
        <member name="F:NFX.Glue.Native.FrameType.EchoResponse">
            <summary>
            Indicator that this is an echo response message that sending party awaits after E was sent
            </summary>
        </member>
        <member name="F:NFX.Glue.Native.FrameType.Dummy">
            <summary>
            Indicator that the payload is a one way dummy and should be ignored.
            This may be needed for stress testing the network throughput
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.WireFrame">
            <summary>
            This struct defines a frame transmitted as a part of WireMsg
            which can be used for transport or session management needs
            </summary>
            <remarks>
            Frame Content:
              ----------------------------------------- 
              MAGIC       ushort               2  byte   -  0xABBA
              VESRION     byte                 1  byte
              TYPE        {G|H|E|R|D}          1  byte
              FORMAT      int32BE              4  bytes
              ONEWAY      {0|!0}               1  byte
              REQID       FID                  8  bytes
              HDRSLEN     int32BE              4  bytes 
                                           ------------
                                              21  bytes
                                              
              HDRSCONTENT  utf8_char[x]  HDRSLEN  bytes
              -----------------------------------------
                                    21 + HDRSLEN  bytes total size 
            </remarks>
        </member>
        <member name="M:NFX.Glue.Native.WireFrame.#ctor(System.IO.Stream)">
            <summary>
            Reconstruct (deserializes) frame from the stream. May throw on error
            </summary>
        </member>
        <member name="M:NFX.Glue.Native.WireFrame.Serialize(System.IO.Stream)">
            <summary>
            Serialize the frame to the given stream returning the byte size of the frame
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.WireFrame.Type">
            <summary>
            Returns type of this frame
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.WireFrame.Format">
            <summary>
            Format used for payload encoding, use FORMAT_SLIM as a default constant
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.WireFrame.RequestID">
            <summary>
            RequestID of the request in following message or echo response message
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.WireFrame.OneWay">
            <summary>
            True if the requesting party does not expect a response
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.WireFrame.HeadersContent">
            <summary>
            Optional frame headers content - an unparsed XML string
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.WireFrame.Headers">
            <summary>
            Optional frame headers parsed from XML HeadersContent
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.WireFrame.Length">
            <summary>
            The total byte size of the frame that includes the length of headers (if any)
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.ClientSite">
            <summary>
            Represents a client call site identifier which gets generated on client and sent to server upon handshake.
            This struct identifies the calling client by supplying machine/host name and calling application instance ID
            </summary>
        </member>
        <member name="F:NFX.Glue.Native.ClientSite.MachineName">
            <summary>
            Sets process-global machine name for client site identification.
            Assign on client to cluster/other machine names, by default the .ctor will use local computer name
            </summary>
        </member>
        <member name="M:NFX.Glue.Native.ClientSite.#ctor(System.IO.Stream)">
            <summary>
            Deserializes ClientSite from stream. The stream position must be past total size
            </summary>
        </member>
        <member name="M:NFX.Glue.Native.ClientSite.Serialize(System.IO.Stream)">
            <summary>
            Writes ClientSite into stream including total size in bytes. Returns total size
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.ClientSite.Name">
            <summary>
            Returns host name+app instance guid suitable for registry operations
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.ClientSite.Host">
            <summary>
            Returns host name for where calling application runs
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.ClientSite.AppInstanceID">
            <summary>
            Returns instance ID for the calling application container
            </summary>
        </member>
        <member name="T:NFX.Glue.Tools.GluecCompiler">
            <summary>
            Generates code from glue contracts
            </summary>
        </member>
        <member name="T:NFX.Glue.Tools.CSharpGluecCompiler">
            <summary>
            CS Gluec compiler
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.DecimalGauge">
            <summary>
            Represents a general-purpose decimal measurement datum
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.DecimalGauge.Value">
            <summary>
            Gets gauge value
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.AmountGauge">
            <summary>
            Represents a general-purpose financial Amount measurement datum
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.IFinancialLogic">
            <summary>
            A class of operations related to financial transactions / business logic
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.IBusinessLogic">
            <summary>
            A class of operations related to business logic that instrument measures
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.AmountGauge.Value">
            <summary>
            Gets gauge value
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.IInstrumentationInstrument">
            <summary>
            Instruments that measure instrumentation itself
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.NOPInstrumentationProvider">
            <summary>
            Represents a provider that does nothing
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.InstrumentationProvider">
            <summary>
            Defines a base provider for InstrumentationService
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.InstrumentationProvider.ExternalGetParameter(System.String,System.Object@,System.String[])">
            <summary>
            Gets external parameter value returning true if parameter was found
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.InstrumentationProvider.ExternalSetParameter(System.String,System.Object,System.String[])">
            <summary>
            Sets external parameter value returning true if parameter was found and set
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.InstrumentationProvider.ExternalParametersForGroups(System.String[])">
            <summary>
            Returns named parameters that can be used to control this component
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.InstrumentationProvider.ExternalParameters">
            <summary>
            Returns named parameters that can be used to control this component
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Telemetry.ITelemetryReceiver">
            <summary>
            Represents a contract for working with remote receiver of telemetry information
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Telemetry.ITelemetryReceiver.Send(System.String,NFX.Instrumentation.Datum)">
            <summary>
            Sends data to remote telemetry receiver
            </summary>
            <param name="siteName">the name/identifier of the reporting site</param>
            <param name="data">Telemetry data</param>
        </member>
        <member name="T:NFX.Instrumentation.Telemetry.TelemetryInstrumentationProvider">
            <summary>
            Represents a provider that writes aggregated datums into remote telemetry receiver
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.LogInstrumentationProvider">
            <summary>
            Represents a provider that writes aggregated datums to log
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Telemetry.TelemetryInstrumentationProvider.UseLog">
            <summary>
            Determines whether to write to log as well
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Telemetry.TelemetryInstrumentationProvider.ReceiverNode">
            <summary>
            Provides remote telemetry receiver node
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Telemetry.TelemetryInstrumentationProvider.SiteName">
            <summary>
            Provides name for reporting site, if this property is blank then App.Name is used instead
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Telemetry.TelemetryReceiverClient">
            <summary>
             Client for glued contract NFX.Instrumentation.Telemetry.ITelemetryReceiver server.
             Each contract method has synchronous and asynchronous versions, the later denoted by 'Async_' prefix.
             May inject client-level inspectors here like so:
               client.MsgInspectors.Register( new YOUR_CLIENT_INSPECTOR_TYPE());
            </summary>
        </member>
        <member name="T:NFX.Glue.ClientEndPoint">
            <summary>
            Represents an ancestor for client classes that make calls to server endpoints. 
            This and descendant classes are thread safe ONLY for making non-constructing/destructing remote calls, unless ReserveTransport is set to true
            in which case no operation is thread safe
            </summary>
            <remarks>
            This class is not thread safe in general, however Glue allows for concurrent remote calls via the same endpoint instance 
            if the following conditions are met:
             1). The endpoint instance has not reserved its transport (ReserveTransport=false)
             2). Either remote contract is stateless OR none of the concurrent calls are constructing/destructing remote instance
            The second condition ensures that stateful remote instance is consistent, otherwise operations may get executed 
             out-of-order in the multithreaded scenario 
            </remarks>
        </member>
        <member name="T:NFX.Glue.EndPoint">
            <summary>
            Abstarction of server and client endpoints. And endpoint is a logically-connected entity per: ABC rule - Address/Binding/Contract(s)
            </summary>
        </member>
        <member name="P:NFX.Glue.EndPoint.Glue">
            <summary>
            References glue that this endpoint works under
            </summary>
        </member>
        <member name="P:NFX.Glue.EndPoint.Node">
            <summary>
            Returns a node of this endpoint. "A" component of the "ABC" rule
            </summary>
        </member>
        <member name="P:NFX.Glue.EndPoint.Binding">
            <summary>
            Returns a binding of this endpoint. "B" component of the "ABC" rule
            </summary>
        </member>
        <member name="M:NFX.Glue.ClientEndPoint.ForgetRemoteInstance">
            <summary>
            Sets RemoteInstance to null. This method is needed when the same instance of client endpoint is used to make subsequent statefull calls
             to different server instances. Call this method before calling [Constructor]-decorated remote method or making the first call to
              InstanceLifetime.AutoconstructedStateful servers.
            </summary>
            <remarks>
            The remote instance ID is retained locally even after a call to [Destructor]-decorated remote method. This is needed because
             a call to destructor may be asynchronous and it may be necessary to know the ID of the instance (that has already died on remote host) after call returns.
            Call ForgetRemoteInstance() to deterministically nullify the local cached ID.
            </remarks>
        </member>
        <member name="M:NFX.Glue.ClientEndPoint.DispatchCall(NFX.Glue.Protocol.RequestMsg)">
            <summary>
            Dispatches a call into binding passing message through client inspectors on this endpoint
            </summary>
        </member>
        <member name="P:NFX.Glue.ClientEndPoint.Contract">
            <summary>
            Returns a contract type of this endpoint. "C" component of the "ABC" rule
            </summary>
        </member>
        <member name="P:NFX.Glue.ClientEndPoint.MsgInspectors">
            <summary>
            Returns client message inspectors for this instance
            </summary>
        </member>
        <member name="P:NFX.Glue.ClientEndPoint.Headers">
            <summary>
            Returns headers that get attached in every call
            </summary>
        </member>
        <member name="P:NFX.Glue.ClientEndPoint.RemoteInstance">
            <summary>
            Returns a reference to remote instance or null if service is stateless(no instance created)
            </summary>
        </member>
        <member name="P:NFX.Glue.ClientEndPoint.ReserveTransport">
            <summary>
            Indicates whether transport instance should not be released after a call and be reserved per this endpoint instance.
            Be carefull when setting this property to true as this action can really impede the system performance as transport is reserved
             until this property is either reset to false or endpoint instance is disposed. Transport reservation reduces call latency
              and is mostly beneficial in synchronous bindings. Warning: client endpoint with reserved transport is NOT THREAD SAFE for making
             parallel calls! Set this property to true only when latency is very critical and only 1 dedicated thread is working with this
              client endpoint instance
            </summary>
        </member>
        <member name="P:NFX.Glue.ClientEndPoint.DispatchTimeoutMs">
            <summary>
            Specifies timeout for call invocation
            </summary>
        </member>
        <member name="P:NFX.Glue.ClientEndPoint.TimeoutMs">
            <summary>
            Specifies timeout for the whole call
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Telemetry.TelemetryReceiverClient.Send(System.String,NFX.Instrumentation.Datum)">
            <summary>
             Synchronous invoker for  'NFX.Instrumentation.Telemetry.ITelemetryReceiver.Send'.
             This is a one-way call per contract specification, meaning - the server sends no acknowledgement of this call receipt and
             there is no result that server could return back to the caller.
             ClientCallException is thrown if the call could not be placed in the outgoing queue.
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Telemetry.TelemetryReceiverClient.Async_Send(System.String,NFX.Instrumentation.Datum)">
            <summary>
             Asynchronous invoker for  'NFX.Instrumentation.Telemetry.ITelemetryReceiver.Send'.
             This is a one-way call per contract specification, meaning - the server sends no acknowledgement of this call receipt and
             there is no result that server could return back to the caller.
             CallSlot is returned that can be queried for CallStatus, ResponseMsg.
            </summary>
        </member>
        <member name="T:NFX.IO.BufferSegmentReadingStream">
            <summary>
            Implements a read-only stream wrapper around a segment of byte[].
            Unlike MemoryStream, this class allows for use of long indexes and reuse the same stream instance with different byte[].
            </summary>
        </member>
        <member name="M:NFX.IO.BufferSegmentReadingStream.BindBuffer(System.Byte[],System.Int64,System.Int64)">
            <summary>
            Sets byte[] as stream source
            </summary>
        </member>
        <member name="P:NFX.IO.BufferSegmentReadingStream.Buffer">
            <summary>
            Target stream that this stream wraps
            </summary>
        </member>
        <member name="T:NFX.IO.ErrorHandling.Adler32">
            <summary>
            Implements Adler32 checksum algorithm
            </summary>    
        </member>
        <member name="M:NFX.IO.ErrorHandling.Adler32.ForEncodedString(System.String,System.Text.Encoding)">
            <summary>
            Computes Adler32 for encoded string
            </summary>
        </member>
        <member name="M:NFX.IO.ErrorHandling.Adler32.ForString(System.String)">
            <summary>
            Computes Adler32 for binary string representation (in-memory)
            </summary>
        </member>
        <member name="M:NFX.IO.ErrorHandling.Adler32.ForBytes(System.Byte[])">
            <summary>
            Computes Adler32 for byte array
            </summary>
        </member>
        <member name="M:NFX.IO.ErrorHandling.Adler32.Add(System.Int32)">
            <summary>
            Adds byte to checksum
            </summary>
        </member>
        <member name="M:NFX.IO.ErrorHandling.Adler32.Add(System.Byte[])">
            <summary>
            Addes byte[] to checksum
            </summary>
        </member>
        <member name="T:NFX.IO.FileSystem.FileSystemDirectory">
            <summary>
            Represents a directory item in a file system. This class is NOT thread-safe
            </summary>
        </member>
        <member name="T:NFX.IO.FileSystem.FileSystemSessionItem">
            <summary>
             Represents an abstraction for items kept in a file system - i.e. directories and files.This class is NOT thread-safe
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSessionItem.GetSizeAsync">
            <summary>
            Async version of <see cref="P:Size"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSessionItem.SetCreationTimestampAsync(System.DateTime)">
            <summary>
            Async version of <see cref="P:CreationTimestamp"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSessionItem.SetModificationTimestampAsync(System.DateTime)">
            <summary>
            Async version of <see cref="P:ModificationTimestamp"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSessionItem.SetLastAccessTimestampAsync(System.DateTime)">
            <summary>
            Async version of <see cref="P:LastAccessTimestamp"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSessionItem.GetCreationUserAsync">
            <summary>
            Async version of <see cref="P:CreationUser"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSessionItem.GetModificationUserAsync">
            <summary>
            Async version of <see cref="P:ModificationUser"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSessionItem.GetLastAccessUserAsync">
            <summary>
            Async version of <see cref="P:LastAccessUser"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSessionItem.SetReadOnlyAsync(System.Boolean)">
            <summary>
            Async version of <see cref="P:ReadOnly"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSessionItem.CheckCanChange">
            <summary>
            Throws when item can not change
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSessionItem.CheckCanChangeAsync">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystemSessionItem.CheckCanChange"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSessionItem.Rename(System.String)">
            <summary>
            Renames an item. Check file system capabilities to see if renaming is supported
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSessionItem.RenameAsync(System.String)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystemSessionItem.Rename(System.String)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSessionItem.Delete">
            <summary>
            Deletes this item from file system
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSessionItem.DeleteAsync">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystemSessionItem.Delete"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSessionItem.Refresh">
            <summary>
            Refreshes the state represented by this item, i.e. this may re-read attributes from remote file system
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSessionItem.RefreshAsync">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystemSessionItem.Refresh"/>
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSessionItem.Handle">
            <summary>
            Returns file system handle for this entity
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSessionItem.Modified">
            <summary>
            Indicates whether anything has changed since last transaction has started
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSessionItem.Path">
            <summary>
            Returns an absolute path for this item
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSessionItem.ParentPath">
            <summary>
            Returns path to directory that contains this item
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSessionItem.FileSystem">
            <summary>
            Returns filesystem - this is a shortcut to Session.FileSystem
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSessionItem.Session">
            <summary>
            Returns session through which this object was obtained
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSessionItem.PermissionsStream">
            <summary>
            Returns item permissions stream
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSessionItem.MetadataStream">
            <summary>
            Returns item metadata stream
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSessionItem.Size">
            <summary>
            Returns the byte size of the item, depending on implementation this property may return approximate sizes for files and directories
            (i.e in distributed systems)
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSessionItem.CreationTimestamp">
            <summary>
            Gets/sets UTC creation timestamp
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSessionItem.ModificationTimestamp">
            <summary>
            Gets/sets UTC modification timestamp
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSessionItem.LastAccessTimestamp">
            <summary>
            Gets/sets UTC last access timestamp
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSessionItem.CreationUser">
            <summary>
            Gets the user who created this item
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSessionItem.ModificationUser">
            <summary>
            Gets the user who modified this item
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSessionItem.LastAccessUser">
            <summary>
            Gets the last user who accessed the item
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSessionItem.ReadOnly">
            <summary>
            Gets/sets readonly attribute
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSessionItem.IsReadOnly">
            <summary>
            Indicates whether this item can change and file system supports modifications
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemDirectory.#ctor(NFX.IO.FileSystem.FileSystemSession,System.String,System.String,NFX.IO.FileSystem.IFileSystemHandle)">
            <summary>
            Internal method that should not be called by developers
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemDirectory.GetSubDirectoryNamesAsync">
            <summary>
            Async version of <see cref="P:SubDirectoryNames"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemDirectory.GetFileNamesAsync">
            <summary>
            Async version of <see cref="P:FileNames"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemDirectory.GetRecursiveSubDirectoryNamesAsync">
            <summary>
            Async version of <see cref="P:RecursiveSubDirectoryNames"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemDirectory.GetRecursiveFileNamesAsync">
            <summary>
            Async version of <see cref="P:RecursiveFileNames"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemDirectory.GetItemAsync(System.String)">
            <summary>
            Async version of Item(string)
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemDirectory.GetFile(System.String)">
            <summary>
            Gets file in this directory or null if it does not exist or not a file
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemDirectory.GetFileAsync(System.String)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystemDirectory.GetFile(System.String)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemDirectory.GetSubDirectory(System.String)">
            <summary>
            Gets dubdirectory in this directory or null if it does not exist or not a directory
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemDirectory.GetSubDirectoryAsync(System.String)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystemDirectory.GetFile(System.String)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemDirectory.CreateFile(System.String,System.Int32)">
            <summary>
            Creates a new file optionally pre-allocating te specified number of bytes
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemDirectory.CreateFileAsync(System.String,System.Int32)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystemDirectory.CreateFile(System.String,System.Int32)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemDirectory.CreateFile(System.String,System.String,System.Boolean)">
            <summary>
            Puts local existing file into file system
            </summary>
            <param name="name">File system file name</param>
            <param name="localFilePath">Local system file name</param>
            <param name="readOnly">Indictaes whether the newly created file should be readonly</param>
            <returns>FileSystemFile instance</returns>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemDirectory.CreateFileAsync(System.String,System.String,System.Boolean)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystemDirectory.CreateFile(System.String,System.String,System.Boolean)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemDirectory.CreateDirectory(System.String)">
            <summary>
            Creates a directory in this directory
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemDirectory.CreateDirectoryAsync(System.String)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystemDirectory.CreateDirectory(System.String)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemDirectory.DeepCopyTo(NFX.IO.FileSystem.FileSystemDirectory,NFX.IO.FileSystem.FileSystemDirectory.DirCopyFlags,System.Int32,System.Func{NFX.IO.FileSystem.FileSystemSessionItem,System.Boolean},System.Func{NFX.IO.FileSystem.FileSystemSessionItem,System.Boolean})">
            <summary>
            Performs a deep copy of this directory into another directory that may belong to a different file system.
            This method allows to copy directory trees between different file systems i.e. from SVN into AmazonS3 or local file system etc.
            </summary>
            <param name="target">Target directory where the files will be placed. It's name does not have to be the same as the source's name</param>
            <param name="flags">Copy flags that specify what to copy</param>
            <param name="bufferSize">Copy buffer size</param>
            <param name="filter">Optional filter function</param>
            <param name="cancel">Optional cancellation function. Return true to abort copying</param>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemDirectory.DeepCopyToAsync(NFX.IO.FileSystem.FileSystemDirectory,NFX.IO.FileSystem.FileSystemDirectory.DirCopyFlags,System.Int32,System.Func{NFX.IO.FileSystem.FileSystemSessionItem,System.Boolean},System.Func{NFX.IO.FileSystem.FileSystemSessionItem,System.Boolean})">
            <summary>
            Async version of DeepCopyTo(...)
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemDirectory.SubDirectoryNames">
            <summary>
            Returns directory names contained in this directory
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemDirectory.FileNames">
            <summary>
            Returns file names contained in this directory
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemDirectory.RecursiveSubDirectoryNames">
            <summary>
            Returns directory names contained in this directory and all subdirectories
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemDirectory.RecursiveFileNames">
            <summary>
            Returns file names contained in this directory and all subdirectories
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemDirectory.Item(System.String)">
            <summary>
            Navigates to the specified path relative to this directory
            </summary>
            <param name="path">Path relative to this directory to navigate to</param>
            <returns>FileSystemSessionItem instance - a directory or a file</returns>
        </member>
        <member name="T:NFX.IO.FileSystem.FileSystemException">
            <summary>
            General NFX file system specific exception
            </summary>
        </member>
        <member name="T:NFX.IO.FileSystem.FileSystemFile">
            <summary>
            Represents a file in a file system. This class is NOT thread-safe
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemFile.#ctor(NFX.IO.FileSystem.FileSystemSession,System.String,System.String,NFX.IO.FileSystem.IFileSystemHandle)">
            <summary>
            Internal method that should not be called by developers
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemFile.ReadAllText">
            <summary>
            Reads all text from file using byte order mark detection with UTF8 encoding
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemFile.ReadAllTextAsync">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystemFile.ReadAllText"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemFile.ReadAllText(System.Text.Encoding,System.Boolean,System.Int32)">
            <summary>
            Reads all text from stream using the specified parameters
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemFile.ReadAllTextAsync(System.Text.Encoding,System.Boolean,System.Int32)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystemFile.ReadAllText(System.Text.Encoding,System.Boolean,System.Int32)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemFile.WriteAllText(System.String)">
            <summary>
            Sets file content to supplied string using default UTF8 encoding
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemFile.WriteAllTextAsync(System.String)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystemFile.WriteAllText(System.String)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemFile.WriteAllText(System.String,System.Text.Encoding,System.Int32)">
            <summary>
            Sets file content to supplied string using the specified parameters
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemFile.WriteAllTextAsync(System.String,System.Text.Encoding,System.Int32)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystemFile.WriteAllText(System.String,System.Text.Encoding,System.Int32)"/>
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemFile.FileStream">
            <summary>
            Returns a stream usable for file content access. If the file has not opened stream yet it will be opened and cached
            </summary>
        </member>
        <member name="T:NFX.IO.FileSystem.IFileSystemCapabilities">
            <summary>
            Supplies capabilities for the file system. The implementation must be thread safe
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.IFileSystemCapabilities.SupportsVersioning">
            <summary>
            Indicates whether a file system supports versioning
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.IFileSystemCapabilities.SupportsTransactions">
            <summary>
            Indicates whether a file system supports transactions
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.IFileSystemCapabilities.MaxFilePathLength">
            <summary>
            Returns maximum allowed length of the whole path that includes directory name/s and/or separator chars and/or file name
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.IFileSystemCapabilities.MaxFileNameLength">
            <summary>
            Returns maximum allowed length of a file name
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.IFileSystemCapabilities.MaxDirectoryNameLength">
            <summary>
            Returns maximum allowed length of a directory name
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.IFileSystemCapabilities.MaxFileSize">
            <summary>
            Returns the maximum size of a file
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.IFileSystemCapabilities.PathSeparatorCharacters">
            <summary>
            Returns understood path separator characters
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.IFileSystemCapabilities.IsReadonly">
            <summary>
            Indicates whether file system supports modification of its files and structure
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.IFileSystemCapabilities.SupportsSecurity">
            <summary>
            Indicates whether the file system supports security permissions
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.IFileSystemCapabilities.SupportsCustomMetadata">
            <summary>
            Indicates whether the file system supports custom metadata for files and folders
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.IFileSystemCapabilities.SupportsAsyncronousAPI">
            <summary>
            Defines if this FileSystem implements Async methods in real asynchronous manner.
            By default asynchronous methods are actually executed syncronously and return Task with execution result or exception
            </summary>
        </member>
        <member name="T:NFX.IO.FileSystem.FileSystem">
            <summary>
            Provides a base for various file system abstractions.
            FileSystem abstractions are mostly useful for working with components/classes that may need to inter-operate not only with local file system
             but also with distributed systems like ApacheHDFS, SVN, GIT, or Aum Cluster Big-Transactional File System (BoltFS).
             NFX library provides compatibility wrapper 'NFX.IO.FileSystem.Local.LocalFileSystem' for access to local machine file system  
             (which is based on this class and is implemented using a traditional System.IO.* set of classes).
            The FileSystem abstraction supports the following concepts: versioning, transactions, metadata, security; however it does not guarantee that
             every implementation is capable of providing all of these functions. Query "GeneralCapabilities" and "InstanceCapabilities" to see what functions
              are supported by a particular instance.
            This class is not thread-safe unless stated otherwise on method level, however multiple threads are allowed to obtain their own FileSystemSession
             object via a call to StartSession() which is thread safe
            </summary>
        </member>
        <member name="T:NFX.IO.FileSystem.IFileSystem">
            <summary>
            Stipulates contract for various file system abstractions.
            FileSystem abstractions are mostly useful for working with components/classes that may need to inter-operate not only with local file system
             but also with distributed systems like ApacheHDFS, SVN, GIT, or Aum Cluster File System (ACFS).
             NFX library provides compatibility wrapper 'NFX.IO.FileSystem.Local.LocalFileSystem' for access to local machine file system  
             (which is based on this class and is implemented using a traditional System.IO.* set of classes).
            The FileSystem abstraction supports the following concepts: versioning, transactions, metadata, security; however it does not guarantee that
             every implementation is capable of providing all of these functions. Query "GeneralCapabilities" and "InstanceCapabilities" to see what functions
              are supported by a particular instance.
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.IFileSystem.StartSession(NFX.IO.FileSystem.FileSystemSessionConnectParams)">
            <summary>
            Creates a new session for the specified user and version
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.IFileSystem.CombinePaths(System.String,System.String[])">
            <summary>
            Combines two or more path segments joining them using primary file system path separator
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.IFileSystem.Sessions">
            <summary>
            Returns a list of sessions
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.IFileSystem.GeneralCapabilities">
            <summary>
            Returns capabilities for this file system in general
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.IFileSystem.InstanceCapabilities">
            <summary>
            Returns capabilities for this file system instance, that may or may not be the same as GeneralCapabilities
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.AutoStartSystems">
            <summary>
            Automatically starts systems designated in config with auto-start attribute
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.Configure(NFX.Environment.IConfigSectionNode)">
            <summary>
            Configures file system. This method is a part of lifecycle management and is intended to be called only by creating thread (not thread-safe)
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.StartSession(NFX.IO.FileSystem.FileSystemSessionConnectParams)">
            <summary>
            Creates a new session for the user. This method is thread-safe, however the returned FileSystemSession object is not.
            Every thread must obtain its own session via this method
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.CombinePaths(System.String,System.String[])">
            <summary>
            Combines two or more path segments joining them using primary file system path separator. This method is thread-safe
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoConfigure(NFX.Environment.IConfigSectionNode)">
            <summary>
            Override to perform custom configuration
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoCheckCanChange(NFX.IO.FileSystem.FileSystemSessionItem)">
            <summary>
            Override in particular file systems to see if item can change, i.e. 
             for file systems that support versioning throw exception if item is in session
              which "looks" at a sealed/closed version and can not change. This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoCheckCanChangeAsync(NFX.IO.FileSystem.FileSystemSessionItem)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoCheckCanChange(NFX.IO.FileSystem.FileSystemSessionItem)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoCheckCanChange(NFX.IO.FileSystem.FileSystemSessionItem)"/> and 
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoCheckCanChange(NFX.IO.FileSystem.FileSystemSessionItem)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetLatestVersion(NFX.IO.FileSystem.FileSystemSession)">
            <summary>
            Override in particular file systems that support versioning to get latest version object that this session can work with.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetLatestVersionAsync(NFX.IO.FileSystem.FileSystemSession)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetLatestVersion(NFX.IO.FileSystem.FileSystemSession)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetLatestVersion(NFX.IO.FileSystem.FileSystemSession)"/> and 
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetLatestVersion(NFX.IO.FileSystem.FileSystemSession)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetVersion(NFX.IO.FileSystem.FileSystemSession)">
            <summary>
            Override in particular file systems that support versioning to get version object for session.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetVersionAsync(NFX.IO.FileSystem.FileSystemSession)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetVersion(NFX.IO.FileSystem.FileSystemSession)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetVersion(NFX.IO.FileSystem.FileSystemSession)"/> and 
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetVersion(NFX.IO.FileSystem.FileSystemSession)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoSetVersion(NFX.IO.FileSystem.FileSystemSession,NFX.IO.FileSystem.IFileSystemVersion)">
            <summary>
            Override in particular file systems that support versioning to set seesion to specific version.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoSetVersionAsync(NFX.IO.FileSystem.FileSystemSession,NFX.IO.FileSystem.IFileSystemVersion)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoSetVersion(NFX.IO.FileSystem.FileSystemSession,NFX.IO.FileSystem.IFileSystemVersion)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoSetVersion(NFX.IO.FileSystem.FileSystemSession,NFX.IO.FileSystem.IFileSystemVersion)"/> and 
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoSetVersion(NFX.IO.FileSystem.FileSystemSession,NFX.IO.FileSystem.IFileSystemVersion)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoBeginTransaction(NFX.IO.FileSystem.FileSystemSession)">
            <summary>
            Override in particular file systems that support transactions to begin transaction in specified session.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoBeginTransactionAsync(NFX.IO.FileSystem.FileSystemSession)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoBeginTransaction(NFX.IO.FileSystem.FileSystemSession)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoBeginTransaction(NFX.IO.FileSystem.FileSystemSession)"/> and 
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoBeginTransaction(NFX.IO.FileSystem.FileSystemSession)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoCommitTransaction(NFX.IO.FileSystem.FileSystemSession)">
            <summary>
            Override in particular file systems that support transactions to commit transaction in specified session.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoCommitTransactionAsync(NFX.IO.FileSystem.FileSystemSession)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoCommitTransaction(NFX.IO.FileSystem.FileSystemSession)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoCommitTransaction(NFX.IO.FileSystem.FileSystemSession)"/> and 
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoCommitTransaction(NFX.IO.FileSystem.FileSystemSession)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoRollbackTransaction(NFX.IO.FileSystem.FileSystemSession)">
            <summary>
            Override in particular file systems that support transactions to rollback transaction in specified session.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoRollbackTransactionAsync(NFX.IO.FileSystem.FileSystemSession)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoRollbackTransaction(NFX.IO.FileSystem.FileSystemSession)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoRollbackTransaction(NFX.IO.FileSystem.FileSystemSession)"/> and 
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoRollbackTransaction(NFX.IO.FileSystem.FileSystemSession)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoRefresh(NFX.IO.FileSystem.FileSystemSessionItem)">
            <summary>
            Override to refresh item state, i.e. re-fetch remote information.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoRefreshAsync(NFX.IO.FileSystem.FileSystemSessionItem)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoRefreshAsync(NFX.IO.FileSystem.FileSystemSessionItem)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoRefreshAsync(NFX.IO.FileSystem.FileSystemSessionItem)"/> and 
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoRefreshAsync(NFX.IO.FileSystem.FileSystemSessionItem)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetSubDirectoryNames(NFX.IO.FileSystem.FileSystemDirectory,System.Boolean)">
            <summary>
            Override to get subdirectory names of directory. If directory is null then root is assumed.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetSubDirectoryNamesAsync(NFX.IO.FileSystem.FileSystemDirectory,System.Boolean)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetSubDirectoryNames(NFX.IO.FileSystem.FileSystemDirectory,System.Boolean)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetSubDirectoryNames(NFX.IO.FileSystem.FileSystemDirectory,System.Boolean)"/> and 
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetSubDirectoryNames(NFX.IO.FileSystem.FileSystemDirectory,System.Boolean)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetFileNames(NFX.IO.FileSystem.FileSystemDirectory,System.Boolean)">
            <summary>
            Override to get file names in directory. If directory is null then root is assumed.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetFileNamesAsync(NFX.IO.FileSystem.FileSystemDirectory,System.Boolean)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetFileNames(NFX.IO.FileSystem.FileSystemDirectory,System.Boolean)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetFileNames(NFX.IO.FileSystem.FileSystemDirectory,System.Boolean)"/> and 
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetFileNames(NFX.IO.FileSystem.FileSystemDirectory,System.Boolean)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoNavigate(NFX.IO.FileSystem.FileSystemSession,System.String)">
            <summary>
            Override to get file or directory from specified path. Return null if item does not exist.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoNavigateAsync(NFX.IO.FileSystem.FileSystemSession,System.String)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoNavigate(NFX.IO.FileSystem.FileSystemSession,System.String)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoNavigate(NFX.IO.FileSystem.FileSystemSession,System.String)"/> and 
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoNavigate(NFX.IO.FileSystem.FileSystemSession,System.String)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoRenameItem(NFX.IO.FileSystem.FileSystemSessionItem,System.String)">
            <summary>
            Override to rename item return true on success.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoRenameItemAsync(NFX.IO.FileSystem.FileSystemSessionItem,System.String)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoRenameItem(NFX.IO.FileSystem.FileSystemSessionItem,System.String)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoRenameItem(NFX.IO.FileSystem.FileSystemSessionItem,System.String)"/> and 
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoRenameItem(NFX.IO.FileSystem.FileSystemSessionItem,System.String)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoDeleteItem(NFX.IO.FileSystem.FileSystemSessionItem)">
            <summary>
            Override to delete item.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoDeleteItemAsync(NFX.IO.FileSystem.FileSystemSessionItem)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoDeleteItem(NFX.IO.FileSystem.FileSystemSessionItem)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoDeleteItem(NFX.IO.FileSystem.FileSystemSessionItem)"/> and 
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoDeleteItem(NFX.IO.FileSystem.FileSystemSessionItem)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoCreateFile(NFX.IO.FileSystem.FileSystemDirectory,System.String,System.Int32)">
            <summary>
            Override to create a file.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoCreateFileAsync(NFX.IO.FileSystem.FileSystemDirectory,System.String,System.Int32)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoCreateFile(NFX.IO.FileSystem.FileSystemDirectory,System.String,System.Int32)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoCreateFile(NFX.IO.FileSystem.FileSystemDirectory,System.String,System.Int32)"/> and 
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoCreateFile(NFX.IO.FileSystem.FileSystemDirectory,System.String,System.Int32)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoCreateFile(NFX.IO.FileSystem.FileSystemDirectory,System.String,System.String,System.Boolean)">
            <summary>
            Override to create a file from local file.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoCreateFileAsync(NFX.IO.FileSystem.FileSystemDirectory,System.String,System.String,System.Boolean)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoCreateFile(NFX.IO.FileSystem.FileSystemDirectory,System.String,System.String,System.Boolean)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoCreateFile(NFX.IO.FileSystem.FileSystemDirectory,System.String,System.String,System.Boolean)"/> and 
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoCreateFile(NFX.IO.FileSystem.FileSystemDirectory,System.String,System.String,System.Boolean)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoCreateDirectory(NFX.IO.FileSystem.FileSystemDirectory,System.String)">
            <summary>
            Override to create a directory.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoCreateDirectoryAsync(NFX.IO.FileSystem.FileSystemDirectory,System.String)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoCreateDirectory(NFX.IO.FileSystem.FileSystemDirectory,System.String)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoCreateDirectory(NFX.IO.FileSystem.FileSystemDirectory,System.String)"/> and 
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoCreateDirectory(NFX.IO.FileSystem.FileSystemDirectory,System.String)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoDirectoryDeepCopyAsync(NFX.IO.FileSystem.FileSystemDirectory,NFX.IO.FileSystem.FileSystemDirectory,NFX.IO.FileSystem.FileSystemDirectory.DirCopyFlags,System.Int32,System.Func{NFX.IO.FileSystem.FileSystemSessionItem,System.Boolean},System.Func{NFX.IO.FileSystem.FileSystemSessionItem,System.Boolean})">
            <summary>
            Implements asynchronous deep copy of folders where destination folder may belong to a different file system.
            The specifics of implementation may be dictated by particular file systems, i.e.: asynchronous strategies for getting file
            lists may depend on the particular system.
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetItemSize(NFX.IO.FileSystem.FileSystemSessionItem)">
            <summary>
            Override to get the byte size of item (directory or file).
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetItemSizeAsync(NFX.IO.FileSystem.FileSystemSessionItem)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetItemSize(NFX.IO.FileSystem.FileSystemSessionItem)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetItemSize(NFX.IO.FileSystem.FileSystemSessionItem)"/> and 
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetItemSize(NFX.IO.FileSystem.FileSystemSessionItem)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetPermissionsStream(NFX.IO.FileSystem.FileSystemSessionItem,System.Action{NFX.IO.FileSystem.FileSystemStream})">
            <summary>
            Override to get permissions stream for item (directory or file).
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetPermissionsStreamAsync(NFX.IO.FileSystem.FileSystemSessionItem,System.Action{NFX.IO.FileSystem.FileSystemStream})">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetPermissionsStream(NFX.IO.FileSystem.FileSystemSessionItem,System.Action{NFX.IO.FileSystem.FileSystemStream})"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetPermissionsStream(NFX.IO.FileSystem.FileSystemSessionItem,System.Action{NFX.IO.FileSystem.FileSystemStream})"/> and 
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetPermissionsStream(NFX.IO.FileSystem.FileSystemSessionItem,System.Action{NFX.IO.FileSystem.FileSystemStream})"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetMetadataStream(NFX.IO.FileSystem.FileSystemSessionItem,System.Action{NFX.IO.FileSystem.FileSystemStream})">
            <summary>
            Override to get metadata stream for item (directory or file).
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetMetadataStreamAsync(NFX.IO.FileSystem.FileSystemSessionItem,System.Action{NFX.IO.FileSystem.FileSystemStream})">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetMetadataStream(NFX.IO.FileSystem.FileSystemSessionItem,System.Action{NFX.IO.FileSystem.FileSystemStream})"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetMetadataStream(NFX.IO.FileSystem.FileSystemSessionItem,System.Action{NFX.IO.FileSystem.FileSystemStream})"/> and 
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetMetadataStream(NFX.IO.FileSystem.FileSystemSessionItem,System.Action{NFX.IO.FileSystem.FileSystemStream})"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetFileStream(NFX.IO.FileSystem.FileSystemFile,System.Action{NFX.IO.FileSystem.FileSystemStream})">
            <summary>
            Override to get file stream.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetFileStreamAsync(NFX.IO.FileSystem.FileSystemFile,System.Action{NFX.IO.FileSystem.FileSystemStream})">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetFileStream(NFX.IO.FileSystem.FileSystemFile,System.Action{NFX.IO.FileSystem.FileSystemStream})"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetFileStream(NFX.IO.FileSystem.FileSystemFile,System.Action{NFX.IO.FileSystem.FileSystemStream})"/> and 
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetFileStream(NFX.IO.FileSystem.FileSystemFile,System.Action{NFX.IO.FileSystem.FileSystemStream})"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetCreationTimestamp(NFX.IO.FileSystem.FileSystemSessionItem)">
            <summary>
            Override to get item creation timestamp.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetModificationTimestamp(NFX.IO.FileSystem.FileSystemSessionItem)">
            <summary>
            Override to get item modification timestamp.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetLastAccessTimestamp(NFX.IO.FileSystem.FileSystemSessionItem)">
            <summary>
            Override to get item last access timestamp.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoSetCreationTimestamp(NFX.IO.FileSystem.FileSystemSessionItem,System.DateTime)">
            <summary>
            Override to set item creation timestamp.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoSetCreationTimestampAsync(NFX.IO.FileSystem.FileSystemSessionItem,System.DateTime)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoSetCreationTimestamp(NFX.IO.FileSystem.FileSystemSessionItem,System.DateTime)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoSetCreationTimestamp(NFX.IO.FileSystem.FileSystemSessionItem,System.DateTime)"/> and 
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoSetCreationTimestamp(NFX.IO.FileSystem.FileSystemSessionItem,System.DateTime)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoSetModificationTimestamp(NFX.IO.FileSystem.FileSystemSessionItem,System.DateTime)">
            <summary>
            Override to set item modification timestamp.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoSetModificationTimestampAsync(NFX.IO.FileSystem.FileSystemSessionItem,System.DateTime)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoSetModificationTimestamp(NFX.IO.FileSystem.FileSystemSessionItem,System.DateTime)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoSetModificationTimestamp(NFX.IO.FileSystem.FileSystemSessionItem,System.DateTime)"/> and 
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoSetModificationTimestamp(NFX.IO.FileSystem.FileSystemSessionItem,System.DateTime)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoSetLastAccessTimestamp(NFX.IO.FileSystem.FileSystemSessionItem,System.DateTime)">
            <summary>
            Override to set item last access timestamp.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoSetLastAccessTimestampAsync(NFX.IO.FileSystem.FileSystemSessionItem,System.DateTime)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoSetLastAccessTimestamp(NFX.IO.FileSystem.FileSystemSessionItem,System.DateTime)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoSetLastAccessTimestamp(NFX.IO.FileSystem.FileSystemSessionItem,System.DateTime)"/> and 
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoSetLastAccessTimestamp(NFX.IO.FileSystem.FileSystemSessionItem,System.DateTime)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetReadOnly(NFX.IO.FileSystem.FileSystemSessionItem)">
            <summary>
            Override to get item readonly status.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoSetReadOnly(NFX.IO.FileSystem.FileSystemSessionItem,System.Boolean)">
            <summary>
            Override to set item readonly status.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoSetReadOnlyAsync(NFX.IO.FileSystem.FileSystemSessionItem,System.Boolean)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoSetReadOnly(NFX.IO.FileSystem.FileSystemSessionItem,System.Boolean)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoSetReadOnly(NFX.IO.FileSystem.FileSystemSessionItem,System.Boolean)"/> and 
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoSetReadOnly(NFX.IO.FileSystem.FileSystemSessionItem,System.Boolean)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetCreationUser(NFX.IO.FileSystem.FileSystemSessionItem)">
            <summary>
            Override in particular file systems to get user who created item.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetCreationUserAsync(NFX.IO.FileSystem.FileSystemSessionItem)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetCreationUser(NFX.IO.FileSystem.FileSystemSessionItem)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetCreationUser(NFX.IO.FileSystem.FileSystemSessionItem)"/> and 
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetCreationUser(NFX.IO.FileSystem.FileSystemSessionItem)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetModificationUser(NFX.IO.FileSystem.FileSystemSessionItem)">
            <summary>
            Override in particular file systems to get user who was the last user modifying the item.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetModificationUserAsync(NFX.IO.FileSystem.FileSystemSessionItem)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetModificationUser(NFX.IO.FileSystem.FileSystemSessionItem)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetModificationUser(NFX.IO.FileSystem.FileSystemSessionItem)"/> and 
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetModificationUser(NFX.IO.FileSystem.FileSystemSessionItem)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetLastAccessUser(NFX.IO.FileSystem.FileSystemSessionItem)">
            <summary>
            Override in particular file systems to get user who was the last user accessing the item.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetLastAccessUserAsync(NFX.IO.FileSystem.FileSystemSessionItem)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetLastAccessUser(NFX.IO.FileSystem.FileSystemSessionItem)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetLastAccessUser(NFX.IO.FileSystem.FileSystemSessionItem)"/> and 
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetLastAccessUser(NFX.IO.FileSystem.FileSystemSessionItem)"/>
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystem.Instances">
            <summary>
            Returns the read-only registry view of file systems currently activated
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystem.Name">
            <summary>
            Provides name for file system instance
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystem.Sessions">
            <summary>
            Returns a list of sessions. This accessor is thread-safe
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystem.GeneralCapabilities">
            <summary>
            Returns capabilities for this file system in general
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystem.InstanceCapabilities">
            <summary>
            Returns capabilities for this file system instance, that may or may not be the same as GeneralCapabilities
            </summary>
        </member>
        <member name="T:NFX.IO.FileSystem.FileSystemSessionConnectParams">
            <summary>
            Provides parameters for new sessions establishment
            </summary>
        </member>
        <member name="T:NFX.IO.FileSystem.FileSystemSession">
            <summary>
            Represents a user-impersonated session of working with a file system. This class is NOT thread-safe  
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSession.#ctor(NFX.IO.FileSystem.FileSystem,NFX.IO.FileSystem.IFileSystemHandle,NFX.IO.FileSystem.FileSystemSessionConnectParams)">
            <summary>
            Starts new file system session
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSession.GetItemAsync(System.String)">
            <summary>
            Async version of <see cref="P:Item(string)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSession.SetFileSystemVersionAsync(NFX.IO.FileSystem.IFileSystemVersion)">
            <summary>
            Async version of <see cref="P:Version"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSession.GetLatestVersionAsync">
            <summary>
            Async version of <see cref="P:LatestVersion"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSession.BeginTransaction">
            <summary>
            Starts a transaction returning its' transaction handle object, otherwise does nothing
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSession.BeginTransactionAsync">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystemSession.BeginTransaction"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSession.CommitTransaction">
            <summary>
            Commits active transaction, does nothing otherwise
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSession.CommitTransactionAsync">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystemSession.CommitTransaction"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSession.RollbackTransaction">
            <summary>
            Cancels active transaction changes, does nothing otherwise
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSession.RollbackTransactionAsync">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystemSession.RollbackTransaction"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSession.GetVersions(NFX.IO.FileSystem.IFileSystemVersion,System.Int32)">
            <summary>
            Returns specified number of versions going back from the specific version. This call is thread-safe 
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSession.GetVersionsAsync(NFX.IO.FileSystem.IFileSystemVersion,System.Int32)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystemSession.GetVersions(NFX.IO.FileSystem.IFileSystemVersion,System.Int32)"/>
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSession.Name">
            <summary>
            Returns session name
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSession.Handle">
            <summary>
            Returns file system handle for this session
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSession.FileSystem">
            <summary>
            Returns file system instance that this session operates under
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSession.User">
            <summary>
            Returns user that this file system session is for
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSession.TransactionHandle">
            <summary>
            Returns transaction object if transaction has been started or null
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSession.Items">
            <summary>
            Returns file system items initialized through this session
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSession.Item(System.String)">
            <summary>
            Navigates to the specified path
            </summary>
            <param name="path">Path to navigate to</param>
            <returns>FileSystemSessionItem instance - a directory or a file or null if it does not exist</returns>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSession.Version">
            <summary>
            Gets/sets version of the file system that this session works against (a changeset that session "sees")
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSession.LatestVersion">
            <summary>
            Returns latest version for file systems that support versioning, null otherwise
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSession.SecurityManager">
            <summary>
            Returns security manager that services this file system session. This may be useful in cases when file system implements
             its own permission structure and user directory
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSession.UniqueSequenceProvider">
            <summary>
            Returns unique sequence provider for the system or null if it is not supported
            </summary>
        </member>
        <member name="T:NFX.IO.FileSystem.FileSystemStarter">
            <summary>
            Represents a starter that launches file systems on startup
            </summary>
        </member>
        <member name="T:NFX.IO.FileSystem.FileSystemStream">
            <summary>
            Represents a stream that can work with contents of FileSystem. This class is NOT thread-safe
            </summary>
        </member>
        <member name="F:NFX.IO.FileSystem.FileSystemStream.Item">
            <summary>
            Item that this stream is for
            </summary>
        </member>
        <member name="T:NFX.IO.FileSystem.IFileSystemVersion">
            <summary>
            Decorates entities that represent version for file systems that support versioning
            </summary>
        </member>
        <member name="T:NFX.IO.FileSystem.IFileSystemHandle">
            <summary>
            Denotes a handle for item in a file system.
            For example: in a distributed system this may be some form of unique file/directory id (i.e. a GUID) or
             object instance internal to implementation
            </summary>
        </member>
        <member name="T:NFX.IO.FileSystem.IFileSystemTransactionHandle">
            <summary>
            Denotes a handle for transaction in a file system.
            For example: in a distributed system this may be an object instance holding information about transaction which is internal to implementation
            </summary>
        </member>
        <member name="T:NFX.IO.FileSystem.Local.LocalFileSystem">
            <summary>
            Implements NFX.IO.FileSystem support around local machine file system. This is needed for
             components that may need to work with various file systems i.e. Apache HDFS or Aum Cluster File System (ACFS).
            This particular implementation uses traditional System.IO.* and does not support transactions, versioning, metadata and NFX security 
            </summary>
        </member>
        <member name="T:NFX.IO.FileSystem.Local.LocalFileSystemCapabilities">
            <summary>
            Describes local file system capabilities
            </summary>
        </member>
        <member name="T:NFX.IO.FileSystem.Packaging.LocalInstallation">
            <summary>
            Represents the local installation - facilitates working with locally installed packages
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.Packaging.LocalInstallation.#ctor(System.String,System.String)">
            <summary>
            Initializes local installation, tries to read local manifest from rootPath or localManifestDir if it is !=null
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.Packaging.LocalInstallation.BeginInstallation">
            <summary>
            Starts the installation so InstallPackage() can be called
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.Packaging.LocalInstallation.InstallPackage(NFX.IO.FileSystem.Packaging.LocalInstallation.PackageInfo)">
            <summary>
            Unconditionally installs a package - copies a set of files contained in the FileSystemDirectory assigning it some mnemonic name
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.Packaging.LocalInstallation.EndInstallation">
            <summary>
            Updates local installation manifest if changes have been made (Modified=true)
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.Packaging.LocalInstallation.FindMissingOrDifferentPackage(System.Collections.Generic.IEnumerable{NFX.IO.FileSystem.Packaging.LocalInstallation.PackageInfo})">
            <summary>
            Finds a package form the install set which is either missing on local machine or is not the same as the one in installSet.
            Returns the package info from install set
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.Packaging.LocalInstallation.CheckLocalAndInstallIfNeeded(System.Collections.Generic.IEnumerable{NFX.IO.FileSystem.Packaging.LocalInstallation.PackageInfo},System.Boolean)">
            <summary>
            Checks local installation first for missing of different packages and if there are no differences then returns false,
            otherwise re-installs all packages defined by in install-set locally and returns true.
            Pass force=true to re-install regardless of manifest comparison (false by default)
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.Packaging.LocalInstallation.RootPath">
            <summary>
            Root path of the installation
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.Packaging.LocalInstallation.InstallationStarted">
            <summary>
            Returns true to indicate that BeginInstallation() has been called
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.Packaging.LocalInstallation.Modified">
            <summary>
            Returns true to indicate that local installation has changed as the result of package installation
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.Packaging.LocalInstallation.PackageNames">
            <summary>
            Gets package names
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.Packaging.LocalInstallation.PackageManifests">
            <summary>
            Gets package manifests
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.Packaging.LocalInstallation.Item(System.String)">
            <summary>
            Returns installed package manifest by name or null
            </summary>
        </member>
        <member name="T:NFX.IO.FileSystem.Packaging.LocalInstallation.PackageInfo">
            <summary>
            Provides package descriptor
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.Packaging.LocalInstallation.PackageInfo.#ctor(System.String,NFX.IO.FileSystem.FileSystemDirectory,System.String)">
            <summary>Provides package descriptor</summary>
            <param name="name">Mnemonic name of the package (i.e. application name)</param>
            <param name="source">Source directory where to take files from</param>
            <param name="relPath">Relative path which is appended to the root path where files will be placed</param>
        </member>
        <member name="T:NFX.IO.FileSystem.Packaging.ManifestUtils">
            <summary>
            Provides utilities for manifest generation
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.Packaging.ManifestUtils.GeneratePackagingManifest(NFX.IO.FileSystem.FileSystemDirectory,System.String,System.String,System.String)">
            <summary>
            Generates packaging manifest for the specified directory. Optionally may specify root node name
            </summary>
            <param name="directory">Source directory to generate manifest for</param>
            <param name="rootNodeName">Name of root manifest node, if omitted then 'package' is defaulted</param>
            <param name="packageName">Optional 'name' attribute value under root node</param>
            <param name="packageLocalPath">Optional 'local-path' attribute value under root node</param>
        </member>
        <member name="M:NFX.IO.FileSystem.Packaging.ManifestUtils.HasTheSameContent(NFX.Environment.IConfigSectionNode,NFX.Environment.IConfigSectionNode,System.Boolean)">
            <summary>
            Returns true when both config nodes represents the same manifest - that is the same file structure
            </summary>
            <param name="master">Master sample copy</param>
            <param name="comparand">The second manifest being compared to the master</param>
            <param name="oneWay">If true iterates on master, so extra files in comparand will not be detected. False by default in whoch case iterates on master first then on comparand</param>
            <returns>True when comparand has all files/directories that the master lists</returns>
        </member>
        <member name="T:NFX.IO.Net.Gate.NetGateException">
            <summary>
            Throw by NetGate
            </summary>
        </member>
        <member name="T:NFX.IO.Net.Gate.GateAction">
            <summary>
            Allow/Deny
            </summary>
        </member>
        <member name="T:NFX.IO.Net.Gate.INetGate">
            <summary>
            Stipulates general contract for nrtwork gates - entities similar to firewall.
            Network gates allow/deny in/out traffic based on a set of rules
            </summary>
        </member>
        <member name="M:NFX.IO.Net.Gate.INetGate.CheckTraffic(NFX.IO.Net.Gate.ITraffic)">
            <summary>
            Checks whether the specified traffic is allowed or denied
            </summary>
        </member>
        <member name="M:NFX.IO.Net.Gate.INetGate.CheckTraffic(NFX.IO.Net.Gate.ITraffic,NFX.IO.Net.Gate.Rule@)">
            <summary>
            Checks whether the specified traffic is allowed or denied.
            Returns the rule that determined the allow/deny outcome or null when no rule matched
            </summary>
        </member>
        <member name="M:NFX.IO.Net.Gate.INetGate.IncreaseVariable(NFX.IO.Net.Gate.TrafficDirection,System.String,System.String,System.Int32)">
            <summary>
            Increases the named variable in the network scope which this specified traffic falls under
            </summary>
        </member>
        <member name="M:NFX.IO.Net.Gate.INetGate.SetVariable(NFX.IO.Net.Gate.TrafficDirection,System.String,System.String,System.Int32)">
            <summary>
            Sets the named variable in the network scope which this specified traffic falls under
            </summary>
        </member>
        <member name="P:NFX.IO.Net.Gate.INetGate.Enabled">
            <summary>
            When gate is not enabled it allows all traffic bypassing any rules
            </summary>
        </member>
        <member name="T:NFX.IO.Net.Gate.NOPNetGate">
            <summary>
            Represents an implementation of INetGate that allows all traffic
            </summary>
        </member>
        <member name="F:NFX.IO.Net.Gate.NOPNetGate.Instance">
            <summary>
            Default instance of INetGate implementation that allows all traffic
            </summary>
        </member>
        <member name="T:NFX.IO.Net.Gate.NetGate">
            <summary>
            Represents a network gate - a logical filter of incoming network traffic.
            Network gate is somewhat similar to a firewall - it allows/denies the int/out traffic based on the set of rules
            </summary>
        </member>
        <member name="M:NFX.IO.Net.Gate.NetGate.CheckTraffic(NFX.IO.Net.Gate.ITraffic)">
            <summary>
            Checks whether the specified traffic is allowed or denied
            </summary>
        </member>
        <member name="M:NFX.IO.Net.Gate.NetGate.CheckTraffic(NFX.IO.Net.Gate.ITraffic,NFX.IO.Net.Gate.Rule@)">
            <summary>
            Checks whether the specified traffic is allowed or denied.
            Returns the rule that determined the allow/deny outcome or null when no rule matched
            </summary>
        </member>
        <member name="M:NFX.IO.Net.Gate.NetGate.IncreaseVariable(NFX.IO.Net.Gate.TrafficDirection,System.String,System.String,System.Int32)">
            <summary>
            Increases the named variable in the network scope which this specified traffic falls under
            </summary>
        </member>
        <member name="M:NFX.IO.Net.Gate.NetGate.SetVariable(NFX.IO.Net.Gate.TrafficDirection,System.String,System.String,System.Int32)">
            <summary>
            Sets the named variable in the network scope which this specified traffic falls under
            </summary>
        </member>
        <member name="M:NFX.IO.Net.Gate.NetGate.Log(NFX.Log.MessageType,System.String,System.String,System.Exception,System.String,System.Nullable{System.Guid})">
            <summary>
            Facilitates net gate logging
            </summary>
        </member>
        <member name="P:NFX.IO.Net.Gate.NetGate.Item(NFX.IO.Net.Gate.TrafficDirection)">
            <summary>
            Returns gate state 
            </summary>
        </member>
        <member name="P:NFX.IO.Net.Gate.NetGate.Enabled">
            <summary>
            Enables/diables the protection. When protection is disabled then all traffic is allowed
            </summary>
        </member>
        <member name="M:NFX.IO.Net.Gate.NetGate.State.FindGroupForAddress(System.String)">
            <summary>
            Returns the first matching group for address, or null
            </summary>
        </member>
        <member name="M:NFX.IO.Net.Gate.NetGate.State.FindNetSiteStateForAddress(System.String,NFX.IO.Net.Gate.Group@)">
            <summary>
            Returns existing NetSiteState object for specified address, first checking group membership or null
            </summary>
        </member>
        <member name="T:NFX.IOrdered">
            <summary>
            Denotes an entity that has a relative Order property within a collection of entities
            </summary>
        </member>
        <member name="M:NFX.IO.Net.Gate.Group.Match(System.String)">
            <summary>
            Tries to find an address in group and returns it or null
            </summary>
        </member>
        <member name="P:NFX.IO.Net.Gate.Group.Key">
            <summary>
            Returns group key for lookup in State.NetState object
            </summary>
        </member>
        <member name="P:NFX.IO.Net.Gate.Group.Addresses">
            <summary>
            Addresses that are part of the group
            </summary>
        </member>
        <member name="T:NFX.IO.Net.Gate.Group.Address">
            <summary>
            Represents the address node of the group
            </summary>
        </member>
        <member name="T:NFX.IO.Net.Gate.NetSiteState">
            <summary>
            Represents the state of the metwrk site - it can be a particular address or group
            </summary>
        </member>
        <member name="T:NFX.IO.Net.Gate.ITraffic">
            <summary>
            Represents a traffic that passes through network gate
            </summary>
        </member>
        <member name="T:NFX.IO.Net.Gate.HTTPIncomingTraffic">
            <summary>
            Represents HTTP traffic that arrives via HttpListener
            </summary>
        </member>
        <member name="T:NFX.IO.Net.Gate.GeneralTraffic">
            <summary>
            Represents general kind of traffic not bound to any particular technology
            </summary>
        </member>
        <member name="T:NFX.IO.Net.Gate.Rule">
            <summary>
            Represents the named rule for NetGate
            </summary>
        </member>
        <member name="M:NFX.IO.Net.Gate.Rule.Check(NFX.IO.Net.Gate.NetGate.State,NFX.IO.Net.Gate.ITraffic,NFX.IO.Net.Gate.Group@,NFX.IO.Net.Gate.Group@)">
            <summary>
            Cheks whether the rule is satisfied - all listed conditions are met. May lazily resolve addresses to groups
            </summary>
        </member>
        <member name="T:NFX.IO.Net.Gate.VarDef">
            <summary>
            Provides variable definition - the name and parameters how fast a variable decays - loses its value towards 0 when it gets deleted
            </summary>
        </member>
        <member name="T:NFX.IO.NonClosingStreamWrap">
            <summary>
            Implements a stream wrapper that does not close/get disposed.
            This stream is needed for TextWriter defect that always closes stream in its destructor
            </summary>
        </member>
        <member name="M:NFX.IO.NonClosingStreamWrap.#ctor(System.IO.Stream)">
            <summary>
            Allocates a wrapper around some other stream so it can be used with TextWriter that always closes the underlying stream
            in cases when the underlying stream needs to remain open after TextWriter is done
            </summary>
        </member>
        <member name="F:NFX.IO.NonClosingStreamWrap.Target">
            <summary>
            Target stream that this stream wraps
            </summary>
        </member>
        <member name="M:NFX.Media.TagCodes.QR.QREncoderMatrix.WriteTerminationSection(System.Int32,NFX.Collections.BitList)">
            <summary>
            Write termination section according 8.4.8 and 8.4.9 of JISX0510:2004 (p.24).
            </summary>
        </member>
        <member name="M:NFX.Media.TagCodes.QR.QREncoderMatrix.GetNumDataBytesAndNumCorrectionBytesByBlockID(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32[],System.Int32[])">
            <summary>
            According to JISX0510:2004 (p.30) tbl 12 in 8.5.1 
            Calculate data and correction bytes for block
            </summary>
            <param name="numTotalBytes">Total bytes count</param>
            <param name="numDataBytes">Data bytes count</param>
            <param name="numRSBlocks">Reed/Solomon blocks count</param>
            <param name="blockID">Block Id</param>
            <param name="numDataBytesInBlock">Data bytes count in this block</param>
            <param name="numECBytesInBlock">Correction bytes count in this block</param>
        </member>
        <member name="M:NFX.Media.TagCodes.QR.QREncoderMatrix.MixWithCorrectionBytes(NFX.Collections.BitList,System.Int32,System.Int32,System.Int32)">
            <summary>
            According to JISX0510:2004 8.6 p.37 bits are mixed mixes with their correction bytes.
            </summary>
            <param name="bits">Data bits</param>
            <param name="numTotalBytes">Total bytes count</param>
            <param name="numDataBytes">Data bytes count</param>
            <param name="rsBlocksQty">Reed/Solomon blocks count</param>
            <returns>Mixed bits</returns>
        </member>
        <member name="T:NFX.Log.Destinations.MemoryBufferDestination">
            <summary>
            Implements a destination that caches up to specified number of latest log messages in memory
            </summary>
        </member>
        <member name="T:NFX.Log.Destinations.Destination">
            <summary>
            Represents logging message destination - an abstract entity that messages are written to by LogService.
            Destinations must be efficient as they block logger thread. They provide failover mechanism when
             processing can not be completed. Once failed, the processing can try to be resumed after configurable interval. 
            Destinations also provide optional SLA on the time it takes to perform actual message write - once exceeded destination is considered to have failed.
            Basic efficient filtering is provided for times, dates and levels. Complex C# expression-based filtering is also supported
            </summary>
        </member>
        <member name="F:NFX.Log.Destinations.Destination.PROCESSING_TIME_EMA_FILTER">
            <summary>
            Defines how much smoothing the processing time filter does - the lower the number the more smoothing is done.
            Smoothing makes MaxProcessingTimeMs detection insensitive to some seldom delays that may happen every now and then
            while destination performs actual write into its sink
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.Destination.ExternalParametersForGroups(System.String[])">
            <summary>
            Returns named parameters that can be used to control this component
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.Destination.Configure(NFX.Environment.IConfigSectionNode)">
            <summary>
            Configures specified destination
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.Destination.Open">
            <summary>
            Activates destination by preparing it to start operation
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.Destination.Close">
            <summary>
            Deactivates destination
            </summary>
        </member>
        <member name="F:NFX.Log.Destinations.Destination.Before">
            <summary>
            Allows to insert a destination right before this one
            </summary>
        </member>
        <member name="F:NFX.Log.Destinations.Destination.After">
            <summary>
            Allows to insert a destination right after this one
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.Destination.Send(NFX.Log.Message)">
            <summary>
            Sends the message into destination doing filter checks first.
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.Destination.Pulse">
            <summary>
            Provides periodic notification of destinations from central Log thread even if there are no messages to write.
            Override DoPulse to commit internal batching buffers provided by particular destinations
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.Destination.TimeChanged">
            <summary>
            Notifies destination about pivotal time change (i.e. every 12 hrs).
            Implementors may choose to create a different log file or catalog etc.
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.Destination.SettingsChanged">
            <summary>
            Notifies destination about fundamental settings change that may need to create a differently named file,
             database or other storage medium
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.Destination.ParseLevels(System.String)">
            <summary>
            Parses levels into a tuple list of level ranges
            </summary>
            <param name="levels">String representation of levels using ',' or ';' or '|'
            as range group delimiters, and '-' as range indicators.  If first/second bound of the range
            is empty, the min/max value of that bound is assumed.
            Examples: "Debug-DebugZ | Error", "-DebugZ | Info | Warning", "Info-", "DebugB-DebugC, Error"</param>
        </member>
        <member name="M:NFX.Log.Destinations.Destination.ExternalGetParameter(System.String,System.Object@,System.String[])">
            <summary>
            Gets external parameter value returning true if parameter was found
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.Destination.ExternalSetParameter(System.String,System.Object,System.String[])">
            <summary>
            Sets external parameter value returning true if parameter was found and set
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.Destination.DoConfigure(NFX.Environment.IConfigSectionNode)">
            <summary>
            Override to perform derivative-specific configuration
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.Destination.SetError(System.Exception,NFX.Log.Message)">
            <summary>
            Notifies log service of exception that surfaced during processing of a particular message
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.Destination.DoSend(NFX.Log.Message)">
            <summary>
            Performs physical send, i.e. storage in file for FileDestinations
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.Destination.DoPulse">
            <summary>
            Provides periodic notification of destinations from central Log thread even if there are no messages to write.
            Override to commit internal batching buffers provided by particular destinations
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.Service">
            <summary>
            References a log service that this destination services
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.Owner">
            <summary>
            Returns a composite destination that ownes this destination or null
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.Name">
            <summary>
            Provides mnemonic destination name
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.Filter">
            <summary>
            Gets/sets filter expression for this destination. 
            Filter expressions get dynamically compiled into filter assembly, 
            consequently it is not a good practice to create too many different filters.
            Filters are heavyweight, and it is advisable to use them ONLY WHEN regular destination filtering (using Min/Max levels, dates and times) can not be used
             to achieve the desired result
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.FilterMethod">
            <summary>
            References message filtering method or null
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.LastError">
            <summary>
            Returns last error that this destination has encountered
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.LastErrorTimestamp">
            <summary>
            Returns last error timestamp (if any)
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.MinLevel">
            <summary>
            Imposes a minimum log level constraint
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.MaxLevel">
            <summary>
            Imposes a maximum log level constraint
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.DaysOfWeek">
            <summary>
            Imposes a filter on days when this destination handles messages
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.StartDate">
            <summary>
            Imposes a filter that specifies the starting date and time
            after which this destination will start processing log messages
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.EndDate">
            <summary>
            Imposes a filter that specifies the ending date and time
            before which this destination will be processing log messages
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.StartTime">
            <summary>
            Imposes a filter that specifies the starting time of the day
            after which this destination will start processing log messages
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.EndTime">
            <summary>
            Imposes a filter that specifies the ending time of the day
            before which this destination will be processing log messages
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.OnlyFailures">
            <summary>
            Indicates whether this destination should only process failures - messages that crashed other destinations.
            When set to true regular messages (dispatched by Send(msg)) are ignored
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.GenerateFailoverMessages">
            <summary>
            Determines whether additional co-related error message should be generated when this destination fails or when it is
             used as failover by some other destination. When this property is true an additional error message gets written into failover destination that
              describes what message caused failure (error is co-related to original) at what destination. False by default.
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.Failover">
            <summary>
            Sets destination name used for failover of this one 
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.TestOnStart">
            <summary>
            Indicates whether this destination should try to test the underlying sink on startup.
            For example DB-based destinations will try to connect to server upon log service launch when this property is true
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.MaxProcessingTimeMs">
            <summary>
            Imposes a time limit on internal message processing (writing into actual sink) by this destination.
            If this limit is exceeded, this destination fails and processing is re-tried to be resumed after RestartProcessingAfterMs interval.
            The minimum value for this property is 25 ms as lower values compromise timer accuracy 
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.AverageProcessingTimeMs">
            <summary>
            Returns average time it takes destination implementation to write the log message to actual sink.
            This property is only computed when MaxProcessingTimeMs limit is imposed, otherwise it returns 0f
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.RestartProcessingAfterMs">
            <summary>
            Specifies how much time must pass before processing will be tried to resume after failure.
            The default value is 60000 ms
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.ExternalParameters">
            <summary>
            Returns named parameters that can be used to control this component
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.MemoryBufferDestination.ClearBuffer">
            <summary>
            Deletes all buffered messages
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.MemoryBufferDestination.Buffered">
            <summary>
            Returns all buffered log messages, where X = BufferSize property
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.MemoryBufferDestination.BufferedTimeAscending">
            <summary>
            Returns all buffered log messages ordered by timestamp ascending
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.MemoryBufferDestination.BufferedTimeDescending">
            <summary>
            Returns all buffered log messages ordered by timestamp descending
            </summary>
        </member>
        <member name="T:NFX.ConvertErrorHandling">
            <summary>
            Specifies how to handle errors during object value conversion
            </summary>
        </member>
        <member name="T:NFX.ObjectValueConversion">
            <summary>
            Provides extension methods for converting object values to different scalar types
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.QueryResolver">
            <summary>
            Infrastructure class - not for app developers.
            Resolves Query objects into query handlers. Query names are case-insensitive.
            This class is thread-safe 
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.ICRUDQueryResolver">
            <summary>
            Represents a class that resolves Query into suitable handler that can execute it
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.ICRUDQueryResolver.Resolve(NFX.DataAccess.CRUD.Query)">
            <summary>
            Retrieves a handler for supplied query. The implementation must be thread-safe
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.ICRUDQueryResolver.RegisterHandlerLocation(System.String)">
            <summary>
            Registers handler location.
            The Resolver must be not started yet. This method is NOT thread safe
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.ICRUDQueryResolver.UnregisterHandlerLocation(System.String)">
            <summary>
            Unregisters handler location returning true if it was found and removed.
            The Resolve must be not started yet. This method is NOT thread safe
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.QueryResolver.RegisterHandlerLocation(System.String)">
            <summary>
            Registers handler location. The Resolver must be not started yet. This method is NOT thread safe
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.QueryResolver.UnregisterHandlerLocation(System.String)">
            <summary>
            Unregisters handler location returning true if it was found and removed. The Resolve must be not started yet. This method is NOT thread safe
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.QueryResolver.ScriptAssembly">
            <summary>
            Gets sets name of assembly that query scripts resolve from
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.QuerySource">
             <summary>
             Represents query source code with pre-processed pragmas
             </summary>
             <example>
            #pragma
            modify=tbl_patient
            key=counter,ssn
            ignore=doctor_phone,doctor_id
            load=
            store=
            @last_name=lname
            @first_name=fname
            .doctor_id=This is description for column
            
            select                     
             t1.ssn,                   
             t1.lname as last_name,
             t1.fname as first_name,
             t1.c_doctor, 
             t2.phone as doctor_phone, 
             t2.NPI	as doctor_id       
            from
             tbl_patient t1
              left outer join tbl_doctor t2 on t1.c_doctor = t2.counter
            where
             t1.lname like ?LN
             </example>
        </member>
        <member name="P:NFX.DataAccess.CRUD.QuerySource.Name">
            <summary>
            Rerurns name of query source
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.QuerySource.OriginalSource">
            <summary>
            Returns original source of query including pragma text (if any)
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.QuerySource.StatementSource">
            <summary>
            Returns source of query excluding pragma text (if any was present in the original)
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.QuerySource.HasPragma">
            <summary>
            Returns true when #pragma was defined in source
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.QuerySource.ReadOnly">
            <summary>
            Returns true when pragma does not specify any modification target (table name to insert/update/delete against)
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.QuerySource.ModifyTarget">
            <summary>
            Returns modification target (table name to insert/update/delete against) if query is not read-only
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.QuerySource.ColumnDefs">
            <summary>
            Returns column definitions defined by #pragma
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.QuerySource.ColumnDef">
            <summary>
            Provides column definition in QuerySource
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.RowChangeType">
            <summary>
            Describes what kind of modification was done
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.RowChange">
            <summary>
            Describes row modification
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.RowsetBase">
            <summary>
            Provides base for rowset implementation. 
            Rowsets are mutable lists of rows where all rows must have the same schema, however a rowset may contain a mix of
             dynamic and typed rows as long as they have the same schema.
            Rowsets are not thread-safe
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.#ctor(NFX.DataAccess.CRUD.Schema)">
            <summary>
            Creates an empty rowset
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.Insert(NFX.DataAccess.CRUD.Row)">
            <summary>
            Inserts the row. Returns insertion index
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.Update(NFX.DataAccess.CRUD.Row,NFX.DataAccess.IDataStoreKey)">
            <summary>
            Updates the row, Returns the row index or -1
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.Upsert(NFX.DataAccess.CRUD.Row,System.Func{NFX.DataAccess.CRUD.Row,System.Boolean})">
            <summary>
            Tries to find a row for update and if found, updates it and returns true,
             otherwise inserts the row (if schemas match) and returns false. Optionally pass updateWhere condition
              that may check whether update needs to be performed
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.Delete(NFX.DataAccess.CRUD.Row,NFX.DataAccess.IDataStoreKey)">
            <summary>
            Tries to find a row with the same set of key fields in this table and if found, deletes it and returns its index, otherwise -1
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.Delete(System.Object[])">
            <summary>
            Tries to find a row with the same set of key fields in this table and if found, deletes it and returns its index, otherwise -1
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.Purge">
            <summary>
            Deletes all rows from table without logging the deleted modifications even when LogModifications=true
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.DeleteAll">
            <summary>
            Deletes all rows from table. This method is similar to Purge() but does logging (when enabled)
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.PurgeChanges">
            <summary>
            Clears modifications accumulated by this instance
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.KeyRowFromValues(System.Object[])">
            <summary>
            Creates key row out of field values for keys
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.FindByKey(NFX.DataAccess.CRUD.Row)">
            <summary>
            Tries to find a row by specified keyset and returns it or null if not found
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.FindByKey(System.Object[])">
            <summary>
            Tries to find a row by specified keyset and returns it or null if not found.
            This method does not perform well on Rowsets instances as a rowset is unordered list which does linear search.
            In contrast, Tables are always ordered and perform binary search instead
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.FindByKey(NFX.DataAccess.CRUD.Row,System.Func{NFX.DataAccess.CRUD.Row,System.Boolean})">
            <summary>
            Tries to find a row by specified keyset and extra WHERE clause and returns it or null if not found.
            This method does not perform well on Rowsets instances as a rowset is unordered list which does linear search.
            In contrast, Tables are always ordered and perform binary search instead
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.FindByKey(System.Func{NFX.DataAccess.CRUD.Row,System.Boolean},System.Object[])">
            <summary>
            Tries to find a row by specified keyset and extra WHERE clause and returns it or null if not found
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.GetChangeAt(System.Int32)">
            <summary>
            Retrievs a change by index or null if index is out of bounds or changes are not logged
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.Validate(System.String)">
            <summary>
            Validates all rows in this rowset.
            Override to perform custom validations.
            The method is not expected to throw exception in case of failed validation, rather return exception instance because
             throwing exception really hampers validation performance when many rows need to be validated
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.Compare(NFX.DataAccess.CRUD.Row,NFX.DataAccess.CRUD.Row)">
            <summary>
            Compares two rows
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.Insert(System.Int32,NFX.DataAccess.CRUD.Row)">
            <summary>
            Inserts row at index
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.RemoveAt(System.Int32)">
            <summary>
            Deletes row
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.Add(NFX.DataAccess.CRUD.Row)">
            <summary>
            Inserts a row
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.Clear">
            <summary>
            Purges table
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.Remove(NFX.DataAccess.CRUD.Row)">
            <summary>
            Performs row delete
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.WriteAsJSON(System.IO.TextWriter,System.Int32,NFX.Serialization.JSON.JSONWritingOptions)">
            <summary>
            Writes rowset as JSON including schema information. Do not call this method directly, instead call rowset.ToJSON() or use JSONWriter class
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.Check(NFX.DataAccess.CRUD.Row)">
            <summary>
            Checks argument for being non-null and of the same schema with this rowset
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.SearchForRow(NFX.DataAccess.CRUD.Row,System.Int32@)">
            <summary>
            Provides rowsearching. Override to do binary search in sorted rowsets
            </summary>
            <param name="row">A row to search for</param>
            <param name="index">An index where search collapsed without finding the match. Used for sorted insertions</param>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.DoInsert(NFX.DataAccess.CRUD.Row)">
            <summary>
            Tries to insert a row. If another row with the same set of key fields already in the table returns -1, otherwise
             returns insertion index
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.DoUpdate(NFX.DataAccess.CRUD.Row,NFX.DataAccess.IDataStoreKey)">
            <summary>
            Tries to find a row with the same set of key fields in this table and if found, replaces it and returns its index,
             otherwise returns -1
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.DoUpsert(NFX.DataAccess.CRUD.Row,System.Func{NFX.DataAccess.CRUD.Row,System.Boolean})">
            <summary>
            Tries to find a row with the same set of key fields in this table and if found, replaces it and returns true,
             otherwise inserts the row (if schemas match) and returns false. Optionally pass updateWhere condition
              that may check whether update needs to be performed
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.DoDelete(NFX.DataAccess.CRUD.Row,NFX.DataAccess.IDataStoreKey)">
            <summary>
            Tries to find a row with the same set of key fields in this table and if found, deletes it and returns its index, otherwise -1
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.RowsetBase.InstanceGUID">
            <summary>
            Returns globaly-unique instance ID.
            This ID is useful as a key for storing rowsets in object stores and posting data back from web client to server.
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.RowsetBase.Schema">
            <summary>
            Returns a schema for rows that this rowset contains
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.RowsetBase.Count">
            <summary>
            Returns row count in this rowset
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.RowsetBase.LogChanges">
            <summary>
            Gets/Sets whether this rowset keeps track of all modifications done to it. 
            This property must be set to true to be able to save changes into ICRUDDataStore
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.RowsetBase.Changes">
            <summary>
            Returns accumulated modifications performed on the rowset, or empty enumerator if no modifications have been made or
             LogModifications = false
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.RowsetBase.ChangeCount">
            <summary>
            Returns a count of accumulated modifications performed on the rowset, or zero when no modifications have been made or
             LogModifications = false
             </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.RowsetBase.Item(System.Int32)">
            <summary>
            This method performs update on set
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.TransactionDisposeBehavior">
            <summary>
            Specifies how transaction scope behaves on scope exit
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.TransactionStatus">
            <summary>
            Denotes transaction statuses
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.CRUDTransaction">
            <summary>
            Represents an abstract base for CRUDTransactions that perform particular backend CRUD work in overriden classes
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.ICRUDOperations">
            <summary>
            Describes an entity that performs single (not in transaction/batch)CRUD operations
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.CRUDTransaction.DataStore">
            <summary>
            References the store instance that started this transaction
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.CRUDTransaction.Status">
            <summary>
            Returns current transaction status
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.CRUDTransaction.DisposeBehavior">
            <summary>
            Specifies how transaction should be finalized on dispose: comitted or rolledback if it is still open
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.CRUDDataStoreType">
            <summary>
            Denotes types of CRUD stores
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.ICRUDDataStore">
            <summary>
            Represents a DataStore that supports CRUD operations
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.ICRUDDataStore.BeginTransaction(System.Data.IsolationLevel,NFX.DataAccess.CRUD.TransactionDisposeBehavior)">
            <summary>
            Returns a transaction object for backend. Even if backend does not support transactions internally, CRUDTransactions save changes
             into the store on commit only
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.ICRUDDataStore.ScriptFileSuffix">
            <summary>
            Returns default script file suffix, which some providers may use to locate script files
             i.e. for MySql:  ".my.sql" which gets added to script files like so:  name.[suffix].[script ext (i.e. sql)].
            This name should uniquely identify the provider
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.ICRUDDataStore.SupportsTransactions">
            <summary>
            Returns true when backend supports transactions. Even if false returned, CRUDDatastore supports CRUDTransaction return from BeginTransaction()
             in which case statements may not be sent to destination until a call to Commit()
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.ICRUDDataStore.StoreType">
            <summary>
            Provides classification for the underlying store
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.ICRUDDataStore.QueryResolver">
            <summary>
            Reolver that turns query into handler
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.ICRUDQueryHandler">
            <summary>
            Represents an entity that can execute a query. The implementation may be called by multiple threads and must be safe
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.ICRUDQueryHandler.GetSchema(NFX.DataAccess.CRUD.ICRUDQueryExecutionContext,NFX.DataAccess.CRUD.Query)">
            <summary>
            Executes query without fetching any data but schema. The implementation may be called by multiple threads and must be safe
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.ICRUDQueryHandler.Execute(NFX.DataAccess.CRUD.ICRUDQueryExecutionContext,NFX.DataAccess.CRUD.Query,System.Boolean)">
            <summary>
            Executes query. The implementation may be called by multiple threads and must be safe
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.ICRUDQueryHandler.ExecuteWithoutFetch(NFX.DataAccess.CRUD.ICRUDQueryExecutionContext,NFX.DataAccess.CRUD.Query)">
            <summary>
            Executes query that dows not return results. The implementation may be called by multiple threads and must be safe.
            Returns rows affected
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.ICRUDQueryHandler.Store">
            <summary>
            Store instance that handler is under
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.ICRUDQueryExecutionContext">
            <summary>
            Represents a context (such as Sql Server connection + transaction scope, or Hadoop connect string etc.) for query execution.
            This is a marker interface implemented by particular providers
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.Query">
            <summary>
            Defines a query sent into ICRUDDataStore implementor to retrieve data.
            A Query is a named bag of paremeters where every parameter has a name and the value. 
            </summary>
            <remarks>
             Keep in mind that a particular datastore implementation may have to deal with hybrid distributed backends where different tables get stored 
             in different repositories (different architectures i.e. NoSQL, HDFS, and some RDB SQL all in different locations),
             consequently one can not make assumption about writing SQLs of any kind in business code - that is what CRUD concept is for as it abstracts 
             this into provider implementation.
             Architectural note: unlike Hibernate, LinqTo* and the like, the NFX.CRUD architecture purposely does not allow developers 
             to write query scripts in higher-language like C#. This is because translation of such a high-level language abstraction into
              highly optimized SQL/(and or other script) per particular backend is impossible because such language can not incapsulate
             the optimization features of all possible data backends (i.e. ORACLE vs MongoDB vs Redis vs Files in HDFS).
            CRUD queries need to support selects from tables with millions of rows, or reads from collections with millions of documents,
            or parse millions of lines from files stored in Hadooop servers, thus every particular provider for every particular business app
            must expose custom-written queries by name. Those queries are usually highly optimized for particular platform 
            (i.e. using db-specific hints, common table subexpressions, groupping sets etc.).
            Also, a provider may elect to SELECT * from a table named like Query object, when a hand-written script with such name is not found
            </remarks>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Query.Name">
            <summary>
            Returns Query name, providers use it to locate SQL/scripts particular to backend implementation that they represent.
            QueryResolver resolves query by its name into ICRUDQueryHandler. Name is case-insensitive
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Query.StoreKey">
            <summary>
            Returns the key if one was passed in .ctor when key is set the parameters are ignored
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Query.ResultRowType">
            <summary>
            Returns a type of result row requested in .ctor which is always a TypedRow derivative type, or null
             if no particular type was requested
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Query.Extra">
            <summary>
            Returns extra parameters that provider may need to render the query. May be null
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Query.Item(System.String)">
            <summary>
            Returns parameter by its name or null
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.Query.Param">
            <summary>
            Represents a CRUD query parameter
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.Rowset">
            <summary>
            Implements a rowset that supports row change logging and CRUD operations.
            Rowsets are not optimal for data replication as they perform linear search which is slow, however
            Rowset class supports sorting. In contrast, Tables are kind of rowsets that keep data pre-sorted by key
            thus facilitating quick searching
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Rowset.#ctor(NFX.DataAccess.CRUD.Schema)">
            <summary>
            Creates an empty rowset
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Rowset.#ctor(NFX.DataAccess.CRUD.RowsetBase,System.Func{NFX.DataAccess.CRUD.Row,System.Boolean})">
            <summary>
            Creates a shallow copy from another rowset, optionally applying a filter
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Rowset.SortDefinition">
            <summary>
            Sort definition is a comma-separated field name list where every field may optionally be prefixed with 
            `+` for ascending or `-` for descending sort order specifier. Example: "FirstName,-DOB"
            </summary>
        </member>
        <member name="T:NFX.Erlang.AtomTable">
            <summary>
            Non-garbage collected hash table for atoms.
            
            It stores strings as atoms so that atoms can be quickly compared to
            with O(1) complexity.  The instance of this table is statically maintained
            and its content is never cleared.  The table contains a unique
            list of strings represented as atoms added throughout the lifetime
            of the application.
            </summary>
        </member>
        <member name="M:NFX.Erlang.AtomTable.Exists(System.String)">
            <summary>
            Returns true if given atom is present in the atom table
            </summary>
        </member>
        <member name="M:NFX.Erlang.AtomTable.IndexOf(System.String)">
            <summary>
            Returns index of atom in the atom table. If atom is not
            found returns -1
            </summary>
        </member>
        <member name="M:NFX.Erlang.AtomTable.defaultCapacity">
            <summary>
            Returns the default atom table maximum size. The value can be
            changed by setting the EI_ATOM_TABLE_SIZE environment variable
            </summary>
        </member>
        <member name="P:NFX.Erlang.AtomTable.Initialized">
            <summary>
            Returns true if AtomTable.Instance is initialized
            </summary>
        </member>
        <member name="P:NFX.Erlang.AtomTable.Instance">
            <summary>
            Returns singleton instance of the atom table
            </summary>
        </member>
        <member name="P:NFX.Erlang.AtomTable.Count">
            <summary>
            Returns the current number of atoms stored in the atom table
            </summary>
        </member>
        <member name="P:NFX.Erlang.AtomTable.Item(System.Int32)">
            <summary>
            Lookup an atom in the atom table by index
            </summary>
        </member>
        <member name="P:NFX.Erlang.AtomTable.Item(System.String)">
            <summary>
            Lookup an atom in the atom table by name. If the atom is not
            present in the atom table - add it.  Return the index of the 
            atom in the atom table
            </summary>
        </member>
        <member name="T:NFX.Erlang.ErlConsts">
            <summary>
            Provides non-localizable Erlang constants
            </summary>
        </member>
        <member name="F:NFX.Erlang.ErlConsts.ERL_INT_MAX">
            <summary>
            The largest value that can be encoded as an integer
            </summary>
        </member>
        <member name="F:NFX.Erlang.ErlConsts.ERL_INT_MIN">
            <summary>
            The smallest value that can be encoded as an integer
            </summary>
        </member>
        <member name="T:NFX.Erlang.NotEnoughDataException">
            <summary>
            Exception thrown when decoding an Erlang term if there's not enough
            data in the buffer to construct the term
            </summary>
        </member>
        <member name="T:NFX.Erlang.ErlConnectionException">
            <summary>
            Exception thrown when he connection with a given node gets broken
            </summary>
        </member>
        <member name="F:NFX.Erlang.ErlConnectionException.Node">
            <summary>
            Name of the node that experienced connectivity loss
            </summary>
        </member>
        <member name="F:NFX.Erlang.ErlConnectionException.Reason">
            <summary>
            Get the reason associated with this exit signal
            </summary>
        </member>
        <member name="T:NFX.Erlang.ErlExit">
            <summary>
            Special message sent when a linked pid dies
            </summary>
        </member>
        <member name="F:NFX.Erlang.ErlExit.Pid">
            <summary>
            The pid that sent this exit
            </summary>
        </member>
        <member name="T:NFX.Erlang.ErlDown">
            <summary>
            Message sent when the monitored Pid dies
            </summary>
        </member>
        <member name="T:NFX.Erlang.ErlOutputStream">
            <summary>
            Provides a stream for encoding Erlang terms to external format for
            transmission or storage
            </summary>
        </member>
        <member name="F:NFX.Erlang.ErlOutputStream.DEFAULT_INITIAL_SIZE">
            <summary>
            The default initial size of the stream
            </summary>
        </member>
        <member name="F:NFX.Erlang.ErlOutputStream.DEFAULT_INCREMENT">
            <summary>
            The default increment used when growing the stream
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlOutputStream.#ctor(NFX.Erlang.IErlObject,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Create a stream containing the serialized Erlang term.
            Optionally include in the beginning Erlang protocol version byte
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlOutputStream.ToBinaryString">
            <summary>
            Convert stream content to printable binary string (i.e. &lt;&lt;131,10,...>>)
            </summary>
            <returns></returns>
        </member>
        <member name="M:NFX.Erlang.ErlOutputStream.Reset">
            <summary>
            Reset the stream so that it can be reused
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlOutputStream.GetBuffer">
            <summary>
            Get internal buffer
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlOutputStream.Write(NFX.Erlang.IErlObject)">
            <summary>
            Write an arbitrary Erlang term to the stream.
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlOutputStream.Write(System.Byte)">
            <summary>
            Write one byte to the stream
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlOutputStream.WriteTo(System.IO.Stream)">
            <summary>
            Write the contents of the stream to an OutputStream
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlOutputStream.WriteAtom(NFX.Erlang.ErlAtom,System.Text.Encoding)">
            <summary>
            Write atom to the stream
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlOutputStream.WriteAtom(System.String,System.Text.Encoding)">
            <summary>
            Write string value as atom to the stream
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlOutputStream.WriteBinary(NFX.Erlang.ErlBinary)">
            <summary>
            Write an array of bytes to the stream as an Erlang binary
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlOutputStream.WriteBoolean(NFX.Erlang.ErlBoolean)">
            <summary>
            Write a boolean value to the stream as the Erlang atom 'true' or 'false'
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlOutputStream.WriteByte(NFX.Erlang.ErlByte)">
            <summary>
            Write a single byte to the stream as an Erlang integer
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlOutputStream.WriteChar(System.Char)">
            <summary>
            Write a character to the stream as an Erlang integer
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlOutputStream.WriteDouble(NFX.Erlang.ErlDouble)">
            <summary>
            Write a double value to the stream
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlOutputStream.WriteLong(NFX.Erlang.ErlLong)">
            <summary>
            Write an Erlang long to the stream
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlOutputStream.WriteLong(System.Int64)">
            <summary>
            Write a long to stream
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlOutputStream.WriteInt(System.Int32)">
            <summary>
            Write an integer to the stream
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlOutputStream.WriteList(NFX.Erlang.ErlList)">
            <summary>
            Write Erlang list to stream
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlOutputStream.WriteListHead(System.Int32)">
            <summary>
            Write an Erlang list header to the stream. After calling this
            method, you must write 'arity' elements to the stream followed by
            nil, or it will not be possible to decode it later.
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlOutputStream.WriteNil">
            <summary>
            Write an empty Erlang list to the stream
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlOutputStream.WriteTuple(NFX.Erlang.ErlTuple)">
            <summary>
            Write Erlang tuple to stream
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlOutputStream.WriteTupleHead(System.Int32)">
            <summary>
            Write an Erlang tuple header to the stream. After calling this
            method, you must write 'arity' elements to the stream or it will
            not be possible to decode it later.
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlOutputStream.WriteTrace(NFX.Erlang.ErlTrace)">
            <summary>
            Write Erlang tuple to stream
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlOutputStream.WritePid(NFX.Erlang.ErlPid)">
            <summary>
            Write an Erlang PID to the stream
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlOutputStream.WritePort(NFX.Erlang.ErlPort)">
            <summary>
            Write an Erlang port to the stream
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlOutputStream.WriteRef(NFX.Erlang.ErlRef)">
            <summary>
            Write a new style (R6 and later) Erlang ref to the stream
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlOutputStream.WriteString(NFX.Erlang.ErlString,System.Text.Encoding)">
            <summary>
            Write a string to the stream
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlOutputStream.WriteString(System.String,System.Text.Encoding)">
            <summary>
            Write a string to the stream
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlOutputStream.Write1(System.Int64)">
            <summary>
            Write the low byte of a value to the stream
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlOutputStream.Write2BE(System.Int64)">
            <summary>
            Write the low two bytes of a value to the stream in big endian order
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlOutputStream.Write4BE(System.Int64)">
            <summary>
            Write the low four bytes of a value to the stream in big endian order
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlOutputStream.Write(System.Byte[])">
            <summary>
            Write an array of bytes to the stream
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlOutputStream.InputStream(System.Int32)">
            <summary>
            
            </summary>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:NFX.Erlang.ErlOutputStream.Poke4BE(System.Int32,System.Int32)">
            <summary>
            Write the low four bytes of a value to the stream in bif endian
            order, at the specified position. If the position specified is
            beyond the end of the stream, this method will have no effect
            </summary>
            <remarks>
            Normally this method should be used in conjunction with
            <see cref="P:NFX.Erlang.ErlOutputStream.Position"/>, when is is necessary to insert data into
            the stream before it is known what the actual value should be.
            For example:
            
            <pre>
            int pos = s.Position;
            s.Write4BE(0); // make space for length data,
            // but final value is not yet known
            
            [ ...more write statements...]
            
            // later... when we know the length value
            s.Poke4BE(pos, length);
            </pre>
            </remarks>
        </member>
        <member name="P:NFX.Erlang.ErlOutputStream.Capacity">
            <summary>
            Get the current capacity of the stream. As bytes are added the
            capacity of the stream is increased automatically, however this
            method returns the current size
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlOutputStream.Position">
            <summary>
            Get the current position in the stream
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlOutputStream.Length">
            <summary>
            Get the number of bytes in the stream
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlList.#ctor(NFX.Erlang.IErlObject[],System.Boolean)">
            <summary>
            Create an Erlang string from the given string
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlList.op_Implicit(NFX.Erlang.ErlList)~System.Collections.Generic.List{NFX.Erlang.IErlObject}">
            <summary>
            Implicit conversion of atom to string
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlList.Equals(NFX.Erlang.IErlObject)">
            <summary>
            Determine if two Erlang objects are equal
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlList.Equals(NFX.Erlang.ErlList)">
            <summary>
            Determine if two Erlang lists are equal
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlString.#ctor(System.String)">
            <summary>
            Create an Erlang string from the given string
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlString.op_Implicit(NFX.Erlang.ErlString)~System.String">
            <summary>
            Implicit conversion of ErlString to string
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlString.op_Implicit(System.String)~NFX.Erlang.ErlString">
            <summary>
            Implicit conversion of string to ErlString
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlString.ToString">
            <summary>
            Get the printname of the atom represented by this object. The
            difference between this method and {link #atomValue atomValue()}
            is that the printname is quoted and escaped where necessary,
            according to the Erlang rules for atom naming
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlString.Equals(System.Object)">
            <summary>
            Determine if this atom equals to the object
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlString.Equals(NFX.Erlang.IErlObject)">
            <summary>
            Determine if two Erlang objects are equal
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlString.Equals(NFX.Erlang.ErlString)">
            <summary>
            Determine if two Erlang objects are equal
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlString.GetHashCode">
            <summary>
            Get internal hash code
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlString.CompareTo(System.Object)">
            <summary>
            Compare this instance to the object.
            Negative value means that the atom is less than obj, positive - greater than the obj
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlString.CompareTo(NFX.Erlang.IErlObject)">
            <summary>
            Compare this instance to the IErlObject.
            Negative value means that the atom is less than obj, positive - greater than the obj
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlString.Clone">
            <summary>
            Clone an instance of the object (non-scalar immutable objects are copied by reference)
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlString.Match(NFX.Erlang.IErlObject)">
            <summary>
            Perform pattern match on this Erlang term returning null if match fails
            or a dictionary of matched variables bound in the pattern
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlString.Match(NFX.Erlang.IErlObject,NFX.Erlang.ErlVarBind)">
            <summary>
            Perform pattern match on this Erlang term, storing matched variables
            found in the pattern into the binding.
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlString.Matches(NFX.Erlang.IErlObject)">
            <summary>
            Perform pattern match on this Erlang term without binding any variables
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlString.Value">
            <summary>
            Get the actual string contained in this object
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlString.Empty">
            <summary>
            Returns true if Value is a non-empty string
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlString.Length">
            <summary>
            Length of the string
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlString.IsScalar">
            <summary>
            Determines whether the underlying type is scalar or complex (i.e. tuple, list)
            </summary>
        </member>
        <member name="T:NFX.Erlang.ErlRef">
            <summary>
            Provides a C# representation of Erlang integer types
            </summary>
        </member>
        <member name="F:NFX.Erlang.ErlRef.Null">
            <summary>
            Special value non-existing Pid used for "null" ref comparison
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlRef.#ctor(System.String,System.Int32[],System.Int32)">
            <summary>
            Create an Erlang reference from the given values
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlRef.#ctor(NFX.Erlang.ErlAtom,System.Int32[],System.Int32)">
            <summary>
            Create an Erlang reference from the given values
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlRef.#ctor(NFX.Erlang.ErlAtom,System.UInt32[],System.Int32)">
            <summary>
            Create an Erlang reference from the given values
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlRef.Equals(System.Object)">
            <summary>
            Determine if this instance equals to the object
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlRef.Equals(NFX.Erlang.IErlObject)">
            <summary>
            Determine if two instances are equal
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlRef.Equals(NFX.Erlang.ErlRef)">
            <summary>
            Determine if two instances are equal
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlRef.GetHashCode">
            <summary>
            Get internal hash code
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlRef.CompareTo(System.Object)">
            <summary>
            Compare this instance to the object.
            Negative value means that the value is less than obj, positive - greater than the obj
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlRef.CompareTo(NFX.Erlang.IErlObject)">
            <summary>
            Compare this instance to the IErlObject.
            Negative value means that the value is less than obj, positive - greater than the obj
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlRef.Clone">
            <summary>
            Clone an instance of the object (non-scalar immutable objects are copied by reference)
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlRef.Match(NFX.Erlang.IErlObject)">
            <summary>
            Perform pattern match on this Erlang term returning null if match fails
            or a dictionary of matched variables bound in the pattern
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlRef.Match(NFX.Erlang.IErlObject,NFX.Erlang.ErlVarBind)">
            <summary>
            Perform pattern match on this Erlang term, storing matched variables
            found in the pattern into the binding.
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlRef.Matches(NFX.Erlang.IErlObject)">
            <summary>
            Perform pattern match on this Erlang term without binding any variables
            </summary>
        </member>
        <member name="T:NFX.Erlang.ErlPort">
            <summary>
            Provides a C# representation of Erlang integer types
            </summary>
        </member>
        <member name="F:NFX.Erlang.ErlPort.Null">
            <summary>
            Special value non-existing Port used for "null" pid comparison
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlPort.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Create an Erlang port from the given values
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlPort.#ctor(NFX.Erlang.ErlAtom,System.Int32,System.Int32)">
            <summary>
            Create an Erlang port from the given values
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlPort.Equals(System.Object)">
            <summary>
            Determine if this instance equals to the object
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlPort.Equals(NFX.Erlang.IErlObject)">
            <summary>
            Determine if two instances are equal
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlPort.Equals(NFX.Erlang.ErlPort)">
            <summary>
            Determine if two instances are equal
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlPort.GetHashCode">
            <summary>
            Get internal hash code
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlPort.CompareTo(System.Object)">
            <summary>
            Compare this instance to the object.
            Negative value means that the value is less than obj, positive - greater than the obj
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlPort.CompareTo(NFX.Erlang.IErlObject)">
            <summary>
            Compare this instance to the IErlObject.
            Negative value means that the value is less than obj, positive - greater than the obj
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlPort.Clone">
            <summary>
            Clone an instance of the object (non-scalar immutable objects are copied by reference)
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlPort.Match(NFX.Erlang.IErlObject)">
            <summary>
            Perform pattern match on this Erlang term returning null if match fails
            or a dictionary of matched variables bound in the pattern
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlPort.Match(NFX.Erlang.IErlObject,NFX.Erlang.ErlVarBind)">
            <summary>
            Perform pattern match on this Erlang term, storing matched variables
            found in the pattern into the binding.
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlPort.Matches(NFX.Erlang.IErlObject)">
            <summary>
            Perform pattern match on this Erlang term without binding any variables
            </summary>
        </member>
        <member name="T:NFX.Erlang.ErlPid">
            <summary>
            Provides a C# representation of Erlang integer types
            </summary>
        </member>
        <member name="F:NFX.Erlang.ErlPid.Null">
            <summary>
            Special value non-existing Pid used for "null" pid comparison
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlPid.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Create an Erlang pid from the given values
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlPid.#ctor(NFX.Erlang.ErlAtom,System.Int32,System.Int32,System.Int32)">
            <summary>
            Create an Erlang pid from the given values
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlPid.#ctor(NFX.Erlang.ErlAtom,System.Int32,System.Int32)">
            <summary>
            Create an Erlang pid from a monotonically increasing integer in range
            [1 ... 
            </summary>
            <param name="node"></param>
            <param name="id"></param>
            <param name="creation"></param>
        </member>
        <member name="M:NFX.Erlang.ErlPid.Equals(System.Object)">
            <summary>
            Determine if this instance equals to the object
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlPid.Equals(NFX.Erlang.IErlObject)">
            <summary>
            Determine if two instances are equal
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlPid.Equals(NFX.Erlang.ErlPid)">
            <summary>
            Determine if two instances are equal
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlPid.GetHashCode">
            <summary>
            Get internal hash code
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlPid.CompareTo(System.Object)">
            <summary>
            Compare this instance to the object.
            Negative value means that the value is less than obj, positive - greater than the obj
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlPid.CompareTo(NFX.Erlang.IErlObject)">
            <summary>
            Compare this instance to the IErlObject.
            Negative value means that the value is less than obj, positive - greater than the obj
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlPid.Clone">
            <summary>
            Clone an instance of the object (non-scalar immutable objects are copied by reference)
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlPid.Match(NFX.Erlang.IErlObject)">
            <summary>
            Perform pattern match on this Erlang term returning null if match fails
            or a dictionary of matched variables bound in the pattern
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlPid.Match(NFX.Erlang.IErlObject,NFX.Erlang.ErlVarBind)">
            <summary>
            Perform pattern match on this Erlang term, storing matched variables
            found in the pattern into the binding.
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlPid.Matches(NFX.Erlang.IErlObject)">
            <summary>
            Perform pattern match on this Erlang term without binding any variables
            </summary>
        </member>
        <member name="T:NFX.Erlang.ErlBinary">
            <summary>
            Provides a C# representation of Erlang integer types
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlBinary.#ctor(System.Byte[],System.Boolean)">
            <summary>
            Create an Erlang binary from the given value
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlBinary.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Create an Erlang binary by copying its value from the given buffer
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlBinary.op_Implicit(NFX.Erlang.ErlBinary)~System.Byte[]">
            <summary>
            Implicit conversion of ErlBinary to byte[]
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlBinary.ToBinaryString">
            <summary>
            Returns binary representation of the string encoded as &lt;&lt;...&gt;&gt;
            </summary>
            <returns></returns>
        </member>
        <member name="M:NFX.Erlang.ErlBinary.ToBinaryString(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Convert a byte buffer to printable binary representation (i.e. &lt;&lt;131,15,12,...>>)
            </summary>
            <param name="buf">Buffer to convert</param>
            <param name="offset">Offset in the buffer</param>
            <param name="count">Number of bytes to convert</param>
            <param name="maxLen">Maximum allowed length of returned string. If given, and
            resulting string exceeds this value, it'll be trimmed to this length ending
            with "...>>"</param>
            <returns></returns>
        </member>
        <member name="M:NFX.Erlang.ErlBinary.Equals(System.Object)">
            <summary>
            Determine if this instance equals to the object
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlBinary.Equals(NFX.Erlang.IErlObject)">
            <summary>
            Determine if two instances are equal
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlBinary.Equals(NFX.Erlang.ErlBinary)">
            <summary>
            Determine if two instances are equal
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlBinary.GetHashCode">
            <summary>
            Get internal hash code
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlBinary.CompareTo(System.Object)">
            <summary>
            Compare this instance to the object.
            Negative value means that the value is less than obj, positive - greater than the obj
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlBinary.CompareTo(NFX.Erlang.IErlObject)">
            <summary>
            Compare this instance to the IErlObject.
            Negative value means that the value is less than obj, positive - greater than the obj
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlBinary.Clone">
            <summary>
            Clone an instance of the object (non-scalar immutable objects are copied by reference)
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlBinary.Match(NFX.Erlang.IErlObject)">
            <summary>
            Perform pattern match on this Erlang term returning null if match fails
            or a dictionary of matched variables bound in the pattern
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlBinary.Match(NFX.Erlang.IErlObject,NFX.Erlang.ErlVarBind)">
            <summary>
            Perform pattern match on this Erlang term, storing matched variables
            found in the pattern into the binding.
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlBinary.Matches(NFX.Erlang.IErlObject)">
            <summary>
            Perform pattern match on this Erlang term without binding any variables
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlBinary.Length">
            <summary>
            Return length of the binary byte array
            </summary>
        </member>
        <member name="T:NFX.Erlang.ErlByte">
            <summary>
            Provides a C# representation of Erlang integer types
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlByte.#ctor(System.Byte)">
            <summary>
            Create an Erlang integer from the given value
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlByte.op_Implicit(NFX.Erlang.ErlByte)~System.Byte">
            <summary>
            Implicit conversion of ErlByte to byte
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlByte.op_Explicit(System.Int32)~NFX.Erlang.ErlByte">
            <summary>
            Implicit conversion of byte/char to ErlByte
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlByte.Equals(System.Object)">
            <summary>
            Determine if this atom equals to the object
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlByte.Equals(NFX.Erlang.IErlObject)">
            <summary>
            Determine if two atoms are equal
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlByte.Equals(NFX.Erlang.ErlByte)">
            <summary>
            Determine if two atoms are equal
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlByte.GetHashCode">
            <summary>
            Get internal hash code
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlByte.CompareTo(System.Object)">
            <summary>
            Compare this instance to the object.
            Negative value means that the value is less than obj, positive - greater than the obj
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlByte.CompareTo(NFX.Erlang.IErlObject)">
            <summary>
            Compare this instance to the IErlObject.
            Negative value means that the value is less than obj, positive - greater than the obj
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlByte.Clone">
            <summary>
            Clone an instance of the object (non-scalar immutable objects are copied by reference)
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlByte.Match(NFX.Erlang.IErlObject)">
            <summary>
            Perform pattern match on this Erlang term returning null if match fails
            or a dictionary of matched variables bound in the pattern
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlByte.Match(NFX.Erlang.IErlObject,NFX.Erlang.ErlVarBind)">
            <summary>
            Perform pattern match on this Erlang term, storing matched variables
            found in the pattern into the binding.
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlByte.Matches(NFX.Erlang.IErlObject)">
            <summary>
            Perform pattern match on this Erlang term without binding any variables
            </summary>
        </member>
        <member name="T:NFX.Erlang.ErlBoolean">
            <summary>
            Provides a C# representation of Erlang floats and doubles. Erlang
            defines only one floating point numeric type
            </summary>	
        </member>
        <member name="M:NFX.Erlang.ErlBoolean.#ctor(System.Boolean)">
            <summary>
            Create an Erlang boolean from the given boolean value.
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlBoolean.op_Implicit(NFX.Erlang.ErlBoolean)~System.Boolean">
            <summary>
            Implicit conversion of ErlBoolean to bool
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlBoolean.op_Implicit(System.Boolean)~NFX.Erlang.ErlBoolean">
            <summary>
            Implicit conversion of bool to ErlBoolean
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlBoolean.Equals(System.Object)">
            <summary>
            Determine if this atom equals to the object
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlBoolean.Equals(NFX.Erlang.IErlObject)">
            <summary>
            Determine if two atoms are equal
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlBoolean.Equals(NFX.Erlang.ErlBoolean)">
            <summary>
            Determine if two atoms are equal
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlBoolean.GetHashCode">
            <summary>
            Get internal hash code
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlBoolean.CompareTo(System.Object)">
            <summary>
            Compare this instance to the object.
            Negative value means that the atom is less than obj, positive - greater than the obj
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlBoolean.CompareTo(NFX.Erlang.IErlObject)">
            <summary>
            Compare this instance to the IErlObject.
            Negative value means that the atom is less than obj, positive - greater than the obj
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlBoolean.Clone">
            <summary>
            Clone an instance of the object (non-scalar immutable objects are copied by reference)
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlBoolean.Match(NFX.Erlang.IErlObject)">
            <summary>
            Perform pattern match on this Erlang term returning null if match fails
            or a dictionary of matched variables bound in the pattern
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlBoolean.Match(NFX.Erlang.IErlObject,NFX.Erlang.ErlVarBind)">
            <summary>
            Perform pattern match on this Erlang term, storing matched variables
            found in the pattern into the binding.
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlBoolean.Matches(NFX.Erlang.IErlObject)">
            <summary>
            Perform pattern match on this Erlang term without binding any variables
            </summary>
        </member>
        <member name="T:NFX.Erlang.ErlTypeOrder">
            <summary>
            Defines ordering semantics for Erlang types
            </summary>
        </member>
        <member name="T:NFX.Erlang.ErlExternalTag">
            <summary>
            Tags used for external format serialization
            </summary>
            <remarks>
            https://github.com/erlang/otp/blob/master/lib/erl_interface/include/ei.h
            </remarks>
        </member>
        <member name="M:NFX.Erlang.ErlAtom.#ctor(System.String)">
            <summary>
            Create an atom from the given string
            </summary>
        </member>
        <member name="F:NFX.Erlang.ErlAtom.Index">
            <summary>
            The index of this atom in the global atom table
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlAtom.op_Implicit(NFX.Erlang.ErlAtom)~System.String">
            <summary>
            Implicit conversion of atom to string
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlAtom.op_Implicit(System.String)~NFX.Erlang.ErlAtom">
            <summary>
            Implicit conversion of string to atom
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlAtom.ToString">
            <summary>
            Get the printname of the atom represented by this object. The
            difference between this method and {link #atomValue atomValue()}
            is that the printname is quoted and escaped where necessary,
            according to the Erlang rules for atom naming
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlAtom.Equals(System.Object)">
            <summary>
            Determine if this atom equals to the object
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlAtom.Equals(NFX.Erlang.IErlObject)">
            <summary>
            Determine if two atoms are equal
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlAtom.GetHashCode">
            <summary>
            Get internal hash code
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlAtom.CompareTo(System.Object)">
            <summary>
            Compare this instance to the object.
            Negative value means that the atom is less than obj, positive - greater than the obj
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlAtom.CompareTo(NFX.Erlang.IErlObject)">
            <summary>
            Compare this instance to the IErlObject.
            Negative value means that the atom is less than obj, positive - greater than the obj
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlAtom.Clone">
            <summary>
            Clone an instance of the object (non-scalar immutable objects are copied by reference)
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlAtom.Match(NFX.Erlang.IErlObject)">
            <summary>
            Perform pattern match on this Erlang term returning null if match fails
            or a dictionary of matched variables bound in the pattern
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlAtom.Match(NFX.Erlang.IErlObject,NFX.Erlang.ErlVarBind)">
            <summary>
            Perform pattern match on this Erlang term, storing matched variables
            found in the pattern into the binding.
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlAtom.Matches(NFX.Erlang.IErlObject)">
            <summary>
            Perform pattern match on this Erlang term without binding any variables
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlAtom.Empty">
            <summary>
            Returns true if this instance equals ErlAtom.Null
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlAtom.Value">
            <summary>
            Get the actual string contained in this object
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlAtom.IsScalar">
            <summary>
            Determines whether the underlying type is scalar or complex (i.e. tuple, list)
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlAtom.Length">
            <summary>
            Return the length of the atom string
            </summary>
        </member>
        <member name="T:NFX.Erlang.ErlDouble">
            <summary>
            Provides a C# representation of Erlang floats and doubles. Erlang
            defines only one floating point numeric type
            </summary>	
        </member>
        <member name="M:NFX.Erlang.ErlDouble.#ctor(System.Double)">
            <summary>
            Create an Erlang float from the given double value.
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlDouble.op_Implicit(NFX.Erlang.ErlDouble)~System.Double">
            <summary>
            Implicit conversion of ErlLong to double
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlDouble.Equals(System.Object)">
            <summary>
            Determine if this instance equals to the object
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlDouble.Equals(NFX.Erlang.IErlObject)">
            <summary>
            Determine if two instances are equal
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlDouble.Equals(NFX.Erlang.ErlDouble,System.Double)">
            <summary>
            Determine if two instances are equal
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlDouble.GetHashCode">
            <summary>
            Get internal hash code
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlDouble.CompareTo(System.Object)">
            <summary>
            Compare this instance to the object.
            Negative value means that the value is less than obj, positive - greater than the obj
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlDouble.CompareTo(NFX.Erlang.IErlObject)">
            <summary>
            Compare this instance to the IErlObject.
            Negative value means that the value is less than obj, positive - greater than the obj
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlDouble.Clone">
            <summary>
            Clone an instance of the object (non-scalar immutable objects are copied by reference)
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlDouble.Match(NFX.Erlang.IErlObject)">
            <summary>
            Perform pattern match on this Erlang term returning null if match fails
            or a dictionary of matched variables bound in the pattern
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlDouble.Match(NFX.Erlang.IErlObject,NFX.Erlang.ErlVarBind)">
            <summary>
            Perform pattern match on this Erlang term, storing matched variables
            found in the pattern into the binding.
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlDouble.Matches(NFX.Erlang.IErlObject)">
            <summary>
            Perform pattern match on this Erlang term without binding any variables
            </summary>
        </member>
        <member name="T:NFX.Erlang.ErlLong">
            <summary>
            Provides a C# representation of Erlang integer types
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlLong.#ctor(System.Int64)">
            <summary>
            Create an Erlang integer from the given value
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlLong.op_Implicit(NFX.Erlang.ErlLong)~System.Int32">
            <summary>
            Implicit conversion of ErlLong to int
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlLong.Equals(System.Object)">
            <summary>
            Determine if this instance equals to the object
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlLong.Equals(NFX.Erlang.IErlObject)">
            <summary>
            Determine if two instances are equal
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlLong.Equals(NFX.Erlang.ErlLong)">
            <summary>
            Determine if two instances are equal
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlLong.GetHashCode">
            <summary>
            Get internal hash code
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlLong.CompareTo(System.Object)">
            <summary>
            Compare this instance to the object.
            Negative value means that the value is less than obj, positive - greater than the obj
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlLong.CompareTo(NFX.Erlang.IErlObject)">
            <summary>
            Compare this instance to the IErlObject.
            Negative value means that the value is less than obj, positive - greater than the obj
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlLong.Clone">
            <summary>
            Clone an instance of the object (non-scalar immutable objects are copied by reference)
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlLong.Match(NFX.Erlang.IErlObject)">
            <summary>
            Perform pattern match on this Erlang term returning null if match fails
            or a dictionary of matched variables bound in the pattern
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlLong.Match(NFX.Erlang.IErlObject,NFX.Erlang.ErlVarBind)">
            <summary>
            Perform pattern match on this Erlang term, storing matched variables
            found in the pattern into the binding.
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlLong.Matches(NFX.Erlang.IErlObject)">
            <summary>
            Perform pattern match on this Erlang term without binding any variables
            </summary>
        </member>
        <member name="T:NFX.Erlang.ErlObject">
            <summary>
            Class defines extension methods on types implementing IErlObject interface
            and static methods dealing with IErlObject
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlObject.IsInt(NFX.Erlang.IErlObject)">
            <summary>
            Determines if Erlang object is of type ErlByte or ErlLong
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlObject.Subst(NFX.Erlang.IErlObject,NFX.Erlang.ErlVarBind)">
            <summary>
            Substibute all variables in the given object using provided binding
            and return the resulting object
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlObject.ToErlString(System.String)">
            <summary>
            Convert C# string to ErlString
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlObject.ErlArgs(System.String,System.Object[])">
            <summary>
            Convert C# string to ErlString
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlObject.Format(NFX.Erlang.ErlList)">
            <summary>
            Substitute variables in the args[0] string
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlObject.Parse(System.String,System.Object[])">
            <summary>
            Parse a string into an Erlang term
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlObject.Parse``1(System.String,System.Object[])">
            <summary>
            Parse a string into an Erlang term
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlObject.ParseMFA(System.String,System.Object[])">
            <summary>
            Parse a string representation of an Erlang function call
            "Module:Function(Arg1, ..., ArgN)" to a 3-element (Module, Function, Arguments) tuple
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlObject.ToErlObject(System.String,System.Object[])">
            <summary>
            String extension method to parse a string into an Erlang term
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlObject.To``1(System.String,System.Object[])">
            <summary>
            Parse a string into an Erlang term
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlObject.ToErlMFA(System.String,System.Object[])">
            <summary>
            Parse a string representation of an Erlang function call
            "Module:Function(Arg1, ..., ArgN)" to a 3-element (Module, Function, Arguments) tuple
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlObject.AsType(NFX.Erlang.IErlObject,System.Type)">
            <summary>
            Tries to convert an Erlang term as specified native type.
            Throw exception if conversion is not possible
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlObject.ToErlObject(System.Object)">
            <summary>
            Try to convert .NET native object type to corresponding Erlang term.
            Throw exception if conversion is not possible
            </summary>
        </member>
        <member name="T:NFX.Erlang.ErlVar">
            <summary>
            Provides a C# representation of an Erlang variable
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlVar.#ctor(System.String)">
            <summary>
            Create an Erlang named variable
            </summary>
            <param name="name">Variable name</param>
        </member>
        <member name="M:NFX.Erlang.ErlVar.#ctor(System.String,NFX.Erlang.ErlTypeOrder)">
            <summary>
            Create an Erlang typed named variable
            </summary>
            <param name="name">Variable name</param>
            <param name="type">Value type</param>
        </member>
        <member name="M:NFX.Erlang.ErlVar.#ctor(NFX.Erlang.ErlAtom,NFX.Erlang.ErlTypeOrder)">
            <summary>
            Create an Erlang typed named variable using ErlAtom as name
            </summary>
            <param name="name">Variable name</param>
            <param name="type">Value type</param>
        </member>
        <member name="F:NFX.Erlang.ErlVar.ValueType">
            <summary>
            Type of value stored in this variable
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlVar.ToString">
            <summary>
            Get the printable version of the string contained in this object
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlVar.Match(NFX.Erlang.IErlObject)">
            <summary>
            Perform pattern match on this Erlang term returning null if match fails
            or a dictionary of matched variables bound in the pattern
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlVar.Match(NFX.Erlang.IErlObject,NFX.Erlang.ErlVarBind)">
            <summary>
            Perform pattern match on this Erlang term, storing matched variables
            found in the pattern into the binding.
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlVar.Matches(NFX.Erlang.IErlObject)">
            <summary>
            Match this variable with given pattern merely by performing type check
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlVar.Equals(System.Object)">
            <summary>
            Determine if this var equals to the object
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlVar.Equals(NFX.Erlang.IErlObject)">
            <summary>
            Determine if two vars are equal
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlVar.GetHashCode">
            <summary>
            Get internal hash code
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlVar.CompareTo(System.Object)">
            <summary>
            Compare this instance to the object.
            Negative value means that the atom is less than obj, positive - greater than the obj
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlVar.CompareTo(NFX.Erlang.IErlObject)">
            <summary>
            Compare this instance to the IErlObject.
            Negative value means that the atom is less than obj, positive - greater than the obj
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlVar.Clone">
            <summary>
            Clone an instance of the object (non-scalar immutable objects are copied by reference)
            </summary>
        </member>
        <member name="P:NFX.Erlang.ErlVar.Name">
            <summary>
            Variable name
            </summary>
        </member>
        <member name="T:NFX.Erlang.ErlVarBind">
            <summary>
            Dictionary of variables bound to terms
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.TargetedAttribute">
            <summary>
            Provides a base for attributes which ar targeted for particular techlology (i.e. "ORACLE")
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.TargetedAttribute.TargetName">
            <summary>
            Returns the name of target, i.e. the name of database engine i.e. "ORACLE11g" or "MySQL"
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.TargetedAttribute.ParseMetadataContent(System.String)">
            <summary>
            Parses content with or without root node
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.TargetedAttribute.MetadataContent">
            <summary>
            Returns metadata content string in Laconic format or null. Root not is not specified. I.e.: 'a=1 b=true c{...}'
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.TargetedAttribute.Metadata">
            <summary>
            Returns structured metadata or null if there is no metadata defined
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.TableAttribute">
            <summary>
            Provides information about table schema that this row is a part of
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.TableAttribute.Name">
            <summary>
            Returns the name of schema that decorated class represents, i.e. the name of database table i.e. "TBL_PERSON".
            This value is set so datastore implementation can use it instead of inferring table name from declaring class name
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.TableAttribute.Immutable">
            <summary>
            Indicates whether the data represented by the decorated instance can only be created (and possibly deleted) but can not change(no update).
            This attribute allows some backends to perform some optimizations (such as better failover data handling and caching) as any version of the data
            that could be found is valid and the latest
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.DataKind">
            <summary>
            Provides hint/classification for field textual data
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.FieldAttribute">
            <summary>
            Provides information about table schema that this typed row is a part of
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FieldAttribute.StoreFlag">
            <summary>
            Determines whether field should be loaded/stored from/to storage
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FieldAttribute.BackendName">
            <summary>
            Provides an overriden name for this field
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FieldAttribute.Key">
            <summary>
            Determines whether this field is a part of the primary key
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FieldAttribute.Kind">
            <summary>
            Provides hint/classification for textual field data
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FieldAttribute.Required">
            <summary>
            Determines whether the field must have data
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FieldAttribute.Visible">
            <summary>
            Determines whether the field is shown to user (i.e. as a grid column)
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FieldAttribute.ValueList">
            <summary>
            Returns a ";/,/|"-delimited list of permitted field values - used for lookup validation
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.FieldAttribute.ParseValueList(System.Boolean)">
            <summary>
            Returns a ValueList parsed into key values as:  val1: descr1,val2: desc2...
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.FieldAttribute.ParseValueListString(System.String,System.Boolean)">
            <summary>
            Returns a string parsed into key values as:  val1: descr1,val2: desc2...
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FieldAttribute.Min">
            <summary>
            Provides low-bound validation check
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FieldAttribute.Max">
            <summary>
            Provides high-bound validation check
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FieldAttribute.Default">
            <summary>
            Provides default value
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FieldAttribute.MinLength">
            <summary>
            Imposes a limit on minimum amount of characters in a textual field
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FieldAttribute.MaxLength">
            <summary>
            Imposes a limit on maximum amount of characters in a textual field
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FieldAttribute.CharCase">
            <summary>
            Controls character casing of textual fields
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FieldAttribute.Description">
            <summary>
            Provides description
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FieldAttribute.NonUI">
            <summary>
            If true indicates that this field is ignored when generating UI and ignored when UI supplies the value to the server.
            Pass true to protect server-only structures from being modified by client
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.DynamicRow">
            <summary>
            Represents a row of data which has a schema only known at run-time. 
            Dynamic rows store data in object[] internally, providing better flexibility(ability to define schema at runtime) than TypedRows at the expense of performance.
            This class is not sealed so implementors may override configuration persistence
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.DynamicRow.Schema">
            <summary>
            References a schema for a table that this row is a part of
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.DynamicRow.Data">
            <summary>
            Provides access to raw array of values that this row contains
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.AmorphousDynamicRow">
            <summary>
            Represents a row of data which has a schema only known at run-time that also implements IAmorphousData
            interface that allows this row to store "extra" data that does not comply with the current schema.
            Dynamic rows store data in object[] internally, providing better flexibility(ability to define schema at runtime) than TypedRows at the expense of performance.
            This class is not sealed so implementors may override configuration persistence
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.AmorphousDynamicRow.BeforeSave(System.String)">
            <summary>
            Invoked to allow the row to transform its state into AmorphousData bag.
            For example, this may be usefull to store extra data that is not a part of established business schema.
            The operation is performed per particular targetName (name of physical backend). Simply put, this method allows
             business code to "specify what to do before object gets saved in THE PARTICULAR TARGET backend store"
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.AmorphousDynamicRow.AfterLoad(System.String)">
            <summary>
            Invoked to allow the row to hydrate its fields/state from AmorphousData bag.
            For example, this may be used to reconstruct some temporary object state that is not stored as a part of established business schema.
            The operation is performed per particular targetName (name of physical backend).
            Simply put, this method allows business code to "specify what to do after object gets loaded from THE PARTICULAR TARGET backend store".
            An example: suppose current MongoDB collection stores 3 fields for name, and we want to collapse First/Last/Middle name fields into one field.
            If we change rowschema then it will only contain 1 field which is not present in the database, however those 'older' fields will get populated 
            into AmorphousData giving us an option to merge older 3 fields into 1 within AfterLoad() implementation
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.AmorphousDynamicRow.AmorphousDataEnabled">
            <summary>
            True by default for rows
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.AmorphousDynamicRow.AmorphousData">
            <summary>
            Returns data that does not comply with known schema (dynamic data). The field names are NOT case-sensitive
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.CRUDException">
            <summary>
            Thrown by CRUD data access classes 
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.CRUDValidationException">
            <summary>
            Thrown by CRUD data access classes when validation does not pass
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.CRUDRowValidationException">
            <summary>
            Thrown by CRUD data access classes when field validation does not pass
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.CRUDFieldValidationException">
            <summary>
            Thrown by CRUD data access classes when field validation does not pass
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.Schema">
            <summary>
            Describes a schema for rows: TypedRows and DynamicRows.
            DynamicRows are "shaped" in memory from schema, whereas, TypedRows define schema.
            Schema for Typedrows is cached in static dictionary for speed
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Schema.GetFieldMembers(System.Type)">
            <summary>
            Gets all property members of TypedRow that are tagged as [Field]
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Schema.GetForTypedRow(NFX.DataAccess.CRUD.TypedRow)">
            <summary>
            Returns schema instance for the TypedRow instance by fetching schema object from cache or
             creating it if it has not been cached yet
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Schema.GetForTypedRow(System.Type)">
            <summary>
            Returns schema instance for the TypedRow instance by fetching schema object from cache or
             creating it if it has not been cached yet
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Schema.GetFieldDefByIndex(System.Int32)">
            <summary>
            Finds fielddef by name or throws if name is not found
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Schema.GetFieldDefByName(System.String)">
            <summary>
            Finds fielddef by name or throws if name is not found
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Schema.GetKeyFieldDefsForTarget(System.String)">
            <summary>
            Returns FieldDefs in their order within rows that are declared as key fields for particular target
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Schema.GetTableAttrForTarget(System.String)">
            <summary>
            Returns a TableAttribute that matches the supplied targetName, or if one was not defined then
             returns TableAttribute which matches any target or null
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Schema.IsEquivalentTo(NFX.DataAccess.CRUD.Schema)">
            <summary>
            Performs logical equivalence testing of two schemas
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Schema.WriteAsJSON(System.IO.TextWriter,System.Int32,NFX.Serialization.JSON.JSONWritingOptions)">
            <summary>
            Writes schema as JSON. Do not call this method directly, instead call rowset.ToJSON() or use JSONWriter class
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.Name">
            <summary>
            For TypedRows, returns a unique fully-qualified row type name, whichs is the global identifier of this schema instance
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.ReadOnly">
            <summary>
            Specifies that target that this schema represents (i.e. db table) is not updatable so DataStore will not be able to save row changes made in ram
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.TypedRowType">
            <summary>
            Returns a type of TypedRow if schema was created for TypedRow, or null 
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.TableAttrs">
            <summary>
            Returns table-level attributes
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.FieldDefs">
            <summary>
            Returns FieldDefs in their order within rows that this schema describes
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.AnyTargetKeyFieldDefs">
            <summary>
            Returns FieldDefs in their order within rows that are declared as key fields in any target
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.Item(System.String)">
            <summary>
            Returns a field definition by a unique case-insensitive field name within schema
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.Item(System.Int32)">
            <summary>
            Returns a field definition by a positional index within the row
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.FieldCount">
            <summary>
            Returns field count
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.SchemaEquivalenceEqualityComparer">
            <summary>
            Returns an instance of IEqualityComparer(Schema) that performs logical equivalence testing
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.Schema.FieldDef">
            <summary>
            Provides a definition for a single field of a row
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Schema.FieldDef.GetBackendNameForTarget(System.String)">
            <summary>
            Returns the name of the field in backend that was possibly overriden for a particular target
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Schema.FieldDef.WriteAsJSON(System.IO.TextWriter,System.Int32,NFX.Serialization.JSON.JSONWritingOptions)">
            <summary>
            Writes fielddef as JSON. Do not call this method directly, instead call rowset.ToJSON() or use JSONWriter class
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.FieldDef.Name">
            <summary>
            Returns the name of the field
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.FieldDef.Type">
            <summary>
            Returns the field type
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.FieldDef.NonNullableType">
            <summary>
            For nullable value types returns the field type regardless of nullability, it is the type argument of Nullable struct;
            For reference types returns the same type as Type property
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.FieldDef.Attrs">
            <summary>
            Returns field attributes
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.FieldDef.Order">
            <summary>
            Gets absolute field order index in a row
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.FieldDef.MemberInfo">
            <summary>
            For TypedRow-descendants returns a PropertyInfo object for the underlying property
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.FieldDef.AnyTargetKey">
            <summary>
            Returns true when this field is attributed as being a key field in an attribute that targets ANY_TARGET
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.FieldDef.Description">
            <summary>
            Returns description from field attribute or parses it from field name
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.FieldDef.NonUI">
            <summary>
            Returns true when at least one attribute was marked as NonUI - meaning that this field must not be serialized-to/deserialized-from client UI
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.FieldDef.Item(System.String)">
            <summary>
            Returns a FieldAttribute that matches the supplied targetName, or if one was not defined then
             returns FieldAttribute which matches any target or null
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.Table">
            <summary>
            Implements a master table. Tables are rowsets that are pre-sorted by keys. They are used in scenarios
             when in-memory data replication is needed. A  table supports efficient FindKey() operation but does not
              support sorting. This class is not thread-safe 
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Table.#ctor(NFX.DataAccess.CRUD.Schema)">
            <summary>
            Creates an empty table
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Table.#ctor(NFX.DataAccess.CRUD.Table,System.Func{NFX.DataAccess.CRUD.Row,System.Boolean})">
            <summary>
            Creates a shallow copy from another table, optionally applying a filter
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Table.#ctor(NFX.DataAccess.CRUD.Rowset,System.Func{NFX.DataAccess.CRUD.Row,System.Boolean})">
            <summary>
            Creates a shallow copy from another rowset resorting data per schema key definition, optionally applying a filter
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Table.SearchForRow(NFX.DataAccess.CRUD.Row,System.Int32@)">
            <summary>
            Performs binary search on a sorted table
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Table.Compare(NFX.DataAccess.CRUD.Row,NFX.DataAccess.CRUD.Row)">
            <summary>
            Compares two rows based on their key fields. Always compares in ascending direction
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Table.CompareRows(NFX.DataAccess.CRUD.Schema,NFX.DataAccess.CRUD.Row,NFX.DataAccess.CRUD.Row)">
            <summary>
            Compares two rows based on their key fields. Always compares in ascending direction
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Table.Insert(System.Int32,NFX.DataAccess.CRUD.Row)">
            <summary>
            This is IList member implementation, index is ignored
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Table.Item(System.Int32)">
            <summary>
            This method does not support setting rows in table
            </summary>
        </member>
        <member name="T:NFX.Erlang.ErlInputStream">
            <summary>
            Provides a stream for decoding Erlang terms from external format
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlInputStream.Read(System.Boolean)">
            <summary>
            Read arbitraty Erlang term from the stream, optionally checking protocol
            version byte
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlInputStream.Read">
            <summary>
            Read arbitraty Erlang term from the stream
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlInputStream.ReadByte">
            <summary>
            Read an Erlang byte from the stream
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlInputStream.ReadBoolean">
            <summary>
            Read an Erlang atom from the stream and interpret the value as a boolean
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlInputStream.ReadAtom">
            <summary>
            Read an Erlang atom from the stream
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlInputStream.ReadBinary">
            <summary>
            Read an Erlang binary from the stream
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlInputStream.ReadDouble">
            <summary>
            Read an Erlang float from the stream
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlInputStream.ReadList">
            <summary>
            Read Erlang list from the stream
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlInputStream.ReadTuple">
            <summary>
            Read Erlang tuple from the stream
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlInputStream.ReadPid">
            <summary>
            Read Erlang pid from the stream
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlInputStream.ReadPort">
            <summary>
            Read Erlang port from the stream
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlInputStream.ReadRef">
            <summary>
            Read Erlang reference from the stream
            </summary>
        </member>
        <member name="M:NFX.Erlang.ErlInputStream.ReadString">
            <summary>
            Read Erlang string from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:NFX.Erlang.ErlInputStream.readListHead">
            <summary>
            Reads list head from the stream
            </summary>
            <returns>Arity of the list</returns>
        </member>
        <member name="M:NFX.Erlang.ErlInputStream.readTupleHead">
            <summary>
            Read tuple header from stream
            </summary>
            <returns>Arity of the tuple</returns>
        </member>
        <member name="T:NFX.OS.OSFamily">
            <summary>
            Denots primary OS Families: Win/Mac/Lin*nix
            </summary>
        </member>
        <member name="T:NFX.OS.MemoryStatus">
            <summary>
            Provides current memory status snapshot
            </summary>
        </member>
        <member name="T:NFX.OS.Computer">
            <summary>
            Facilitates various computer-related tasks such as CPU usage, memory utilization etc.
            </summary>
        </member>
        <member name="P:NFX.OS.Computer.CurrentProcessorUsagePct">
            <summary>
            Returns current computer-wide CPU utilization percentage
            </summary>
        </member>
        <member name="P:NFX.OS.Computer.CurrentAvailableMemoryMb">
            <summary>
            Returns current computer-wide RAM availability in mbytes
            </summary>
        </member>
        <member name="P:NFX.OS.Computer.OSFamily">
            <summary>
            Rsturns OS family for this computer: Linux vs Win vs Mac
            </summary>
        </member>
        <member name="P:NFX.OS.Computer.UniqueNetworkSignature">
            <summary>
            Returns network signature for this machine which is unique in the eclosing network segment (MAC-based)
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.ICPUInstrument">
            <summary>
            CPU-related operations
            </summary>
        </member>
        <member name="T:NFX.OS.ManyReadersOneWriterSynchronizer">
            <summary>
            This struct is for ADVANCED SYSTEM use-cases. DEVELOPERS: do not use this in a business application code.
            Represents an efficient SpinWait/Yield-based lock that allows many readers to operate concurrently
             and only one single concurrent writer. This struct must be used ONLY with a very fast/tight operations that 
             do not block on IO and other locks, and are expected to complete under a tenth fraction of a second.
            Warning: this lock CAN NOT be held for longer than 5 hrs by design. DO NOT use this lock with IO-dependent operations.
            This is not really a limitation as this class is used to guard operations which are very fast (fractions of a second) and 
            should fail faster otherwise
            </summary>
        </member>
        <member name="M:NFX.OS.ManyReadersOneWriterSynchronizer.GetReadLock(System.Func{System.Object,System.Boolean},System.Object)">
            <summary>
            Obtains a read lock returning true on success.
            Many threads may obtain a read lock at the same time, however a single write lock excludes any read locks,
            corollary any single read lock held excludes anyone obtaining a write lock.
            False is returned if cancel func was supplied and returned true to cancel-out the waiting 
            </summary>
        </member>
        <member name="M:NFX.OS.ManyReadersOneWriterSynchronizer.ReleaseReadLock">
            <summary>
            Releases the read lock that was previously obtained by a call to GetReadLock()
            </summary>
        </member>
        <member name="M:NFX.OS.ManyReadersOneWriterSynchronizer.GetWriteLock(System.Func{System.Object,System.Boolean},System.Object)">
            <summary>
            Obtains a write lock returning true on success. Only one thread may hold a write lock at a time,
            and noone else can obtain a read lock until the write lock is released.
            False is returned if cancel func was supplied and returned true to cancel-out the waiting 
            </summary>
        </member>
        <member name="M:NFX.OS.ManyReadersOneWriterSynchronizer.ReleaseWriteLock">
            <summary>
            Releases the write lock that was previously obtained by a call to GetWriteLock()
            </summary>
        </member>
        <member name="T:NFX.OS.NetworkUtils">
            <summary>
            Provides network-related utilities
            </summary>
        </member>
        <member name="M:NFX.OS.NetworkUtils.GetMachineUniqueMACSignature">
            <summary>
            Gets a string which represents a unique signature of this machine based on MAC addresses of interfaces.
            The signature has a form of: [intf.count]-[CRC32 of all MACs]-[convoluted MD5 of all MACs]
            </summary>
        </member>
        <member name="T:NFX.OS.HostNetInfo">
            <summary>
            Provides information about IP network host
            </summary>
        </member>
        <member name="P:NFX.OS.HostNetInfo.Name">
            <summary>
            Full host name including domain
            </summary>
        </member>
        <member name="P:NFX.OS.HostNetInfo.HostNameSegment">
            <summary>
            Host name segment of Name
            </summary>
        </member>
        <member name="P:NFX.OS.HostNetInfo.DomainNameSegment">
            <summary>
            Domain name segment of Name
            </summary>
        </member>
        <member name="P:NFX.OS.HostNetInfo.Adapters">
            <summary>
            Network adapters on the host
            </summary>
        </member>
        <member name="T:NFX.OS.HostNetInfo.NetAddrInfo">
            <summary>
            Describes an address supported by net adapter
            </summary>
        </member>
        <member name="T:NFX.OS.HostNetInfo.NetAdapterInfo">
            <summary>
            Describes a network adapter on subordinate host
            </summary>
        </member>
        <member name="T:NFX.Parsing.NaturalTextGenerator">
            <summary>
            Generates human-readable English text for tests
            </summary>
        </member>
        <member name="M:NFX.Parsing.NaturalTextGenerator.Generate(System.Int32)">
            <summary>
            Generates human-readable English text of up to specified length which is of 10 chars at minimum.
            If zero passed then generates msg of random length
            </summary>
        </member>
        <member name="M:NFX.Parsing.NaturalTextGenerator.GenerateWord(System.Int32,System.Int32)">
            <summary>
            Generates a random English word which is of the specified size. The min size must be of at least 4 chars
            </summary>
        </member>
        <member name="M:NFX.Parsing.NaturalTextGenerator.GenerateFirstName">
            <summary>
            Generates a string that resembles a human first name
            </summary>
        </member>
        <member name="M:NFX.Parsing.NaturalTextGenerator.GenerateLastName">
            <summary>
            Generates a string that resembles a human last name
            </summary>
        </member>
        <member name="M:NFX.Parsing.NaturalTextGenerator.GenerateCityName">
            <summary>
            Generates a string that resembles a city name
            </summary>
        </member>
        <member name="M:NFX.Parsing.NaturalTextGenerator.GenerateUSCityStateZip">
            <summary>
            Generates a string that resembles a city/state/zip in a US address.
            The states/zips are NOT consistent
            </summary>
        </member>
        <member name="M:NFX.Parsing.NaturalTextGenerator.GenerateAddressLine">
            <summary>
            Generates a string that resembles an address line
            </summary>
        </member>
        <member name="M:NFX.Parsing.NaturalTextGenerator.GenerateFullName(System.Boolean)">
            <summary>
            Generates a string that looks like a human name
            </summary>
        </member>
        <member name="M:NFX.Parsing.NaturalTextGenerator.GenerateEMail">
            <summary>
            Generates a string that looks like an email
            </summary>
        </member>
        <member name="T:NFX.FID">
            <summary>
            Represents an ultra-efficient 64 bit in-process-wide unique identifier "Fast Id".
            The ID is going to wrap-around after at least 2 weeks (19 days).
            The ID consists of 3 segments: [timestamp: 24bit][threadseed: 24bit][counter: 16 bit].
            This is needed because: 
             a). FID stays unique after process restarts  
             b). This design does not use interlock on global seed, but uses thread-static vars which is 10-20 times faster
             
            The timestamp is the number of 100ms intervals elapsed since Jan 1 2015 expressed as a 24 bit unsigned int, which gives 2^24 = 16,777,216 combinations
            which covers 19 days (around 2 weeks) at 100 msec resolution, consequently the ID will generate duplicates after this period.
            This struct is useful for creating unique IDs for protocol/traffic messages that live for a limited time (no more than 2 weeks).
            Caution: This ID does not identify the machine or process, only items within the process, however when a hosting process restarts(i.e. crash or reboot)
            the new IDs will not collide with IDs generated right before the crash for at least 14 days (14 day sliding window).
            In a parallel test on 6 Core i7 3.2 GHz this class generates 405 million IDs/sec, which is 57 times faster than Guid that only generates 7 million IDs/sec
            </summary>
        </member>
        <member name="M:NFX.FID.#ctor(System.UInt64)">
            <summary>
            Creates instance from ULONG value. Use FID.Generate() to create new IDs instead
            </summary>
        </member>
        <member name="F:NFX.FID.ID">
            <summary>
            Returns 64 bit process-wide unique ID which is unique for up to 2 weeks
            </summary>
        </member>
        <member name="M:NFX.FID.Generate">
            <summary>
            Generates new process-wide unique ID which is unique for up to 2 weeks
            </summary>
        </member>
        <member name="M:NFX.FID.ToGuid">
            <summary>
            Converts to Guid by copying ID twice
            </summary>
        </member>
        <member name="T:NFX.Security.CAPTCHA.PuzzleKeypad">
            <summary>
            Provides methods for generation, storing, and interpretation of user actions with a keypad of random layout.
            This .ctor is supplied some code that user has to punch-in(touch/click) on a randomly laid-out keypad which is usually rendered as
             an image. Use DecipherCoordinates() methods to convert user click/touch coordinates into characters
            </summary>
        </member>
        <member name="M:NFX.Security.CAPTCHA.PuzzleKeypad.DecipherCoordinates(NFX.Serialization.JSON.JSONDataArray,System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Translates user action coordinates (i.e. screen touches or mouse clicks) into a string.
            The coordinates must be supplied as a JSON array of json objects that have '{x: [int], y: [int]}' structure
            </summary>
        </member>
        <member name="M:NFX.Security.CAPTCHA.PuzzleKeypad.DecipherCoordinates(System.Collections.Generic.IEnumerable{System.Drawing.Point},System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Translates user action coordinates (i.e. screen touches or mouse clicks) into a string.
            The coordinates are supplied as IEnumerable(Point)
            </summary>
        </member>
        <member name="M:NFX.Security.CAPTCHA.PuzzleKeypad.DefaultRender(System.Nullable{System.Drawing.Color},System.Boolean)">
            <summary>
            Renders default image of the keypad suitable for user entry (i.e. touch or mouse clicks)
            </summary>
        </member>
        <member name="P:NFX.Security.CAPTCHA.PuzzleKeypad.Code">
            <summary>
            Returns the original secret code that this keypad was created for
            </summary>
        </member>
        <member name="P:NFX.Security.CAPTCHA.PuzzleKeypad.Boxes">
            <summary>
            Returns char boxes
            </summary>
        </member>
        <member name="P:NFX.Security.CAPTCHA.PuzzleKeypad.Size">
            <summary>
            Returns the size of rectangle that covers all boxes
            </summary>
        </member>
        <member name="T:NFX.Security.GDIDCredentials">
            <summary>
            Represents credentials based on Global Distributed ID
            </summary>
        </member>
        <member name="T:NFX.Security.Credentials">
            <summary>
            User credentials base class. A credentials may be as simple as user+password, access card codes, door key, Twitter account token etc...
            </summary>
        </member>
        <member name="M:NFX.Security.Credentials.Forget">
            <summary>
            Deletes sensitive information (such as password).
            This method is mostly used on client (vs. server) to prevent process memory-inspection attack.
            Its is usually called right after Login() was called.
            Implementers may consider forcing post-factum GC.Collect() on all generations to make sure that orphaned 
            memory buff with sensitive information, that remains in RAM even after all references are killed, gets
            compacted; consequently, this method may take considerable time to execute.
            </summary>
        </member>
        <member name="P:NFX.Security.Credentials.Forgotten">
            <summary>
            Indicates whether Forget() was called on this instance
            </summary>
        </member>
        <member name="T:NFX.Security.PasswordUtils">
            <summary>
            Facilitates working with password strings
            </summary>
        </member>
        <member name="M:NFX.Security.PasswordUtils.PasswordStrengthScore(System.String)">
            <summary>
            Calculates password strength as int score which gets computed per set of rules
            </summary>
        </member>
        <member name="M:NFX.Security.PasswordUtils.PasswordStrengthPercent(System.String,System.Int32)">
            <summary>
            Calculates password strength as int percentage 0..100%
            </summary>
        </member>
        <member name="T:NFX.Security.SocialNetTokenCredentials">
            <summary>
            Represents credentials supplied from/to Social Net site (i.e. Facebook, Twitter etc.)
            </summary>
        </member>
        <member name="P:NFX.Security.SocialNetTokenCredentials.NetName">
            <summary>
            Name of social network that returned the token
            </summary>
        </member>
        <member name="P:NFX.Security.SocialNetTokenCredentials.Token">
            <summary>
            Auth token returned by the network
            </summary>
        </member>
        <member name="P:NFX.Security.SocialNetTokenCredentials.UserName">
            <summary>
            Optional user name as returned from social network (i.e. email or account screen name)
            </summary>
        </member>
        <member name="T:NFX.Serialization.JSON.JSONExtensions">
            <summary>
            Provides JSON extension methods
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONExtensions.JSONToDynamic(System.String)">
            <summary>
             Deserializes JSON content into dynamic JSON object
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONExtensions.JSONToDynamic(System.IO.Stream,System.Text.Encoding)">
            <summary>
             Deserializes JSON content into dynamic JSON object
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONExtensions.JSONToDynamic(NFX.CodeAnalysis.Source.ISourceText)">
            <summary>
             Deserializes JSON content into dynamic JSON object
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONExtensions.JSONToDataObject(System.String)">
            <summary>
             Deserializes JSON content into IJSONDataObject
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONExtensions.JSONToDataObject(System.IO.Stream,System.Text.Encoding)">
            <summary>
             Deserializes JSON content into IJSONDataObject
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONExtensions.JSONToDataObject(NFX.CodeAnalysis.Source.ISourceText)">
            <summary>
             Deserializes JSON content into IJSONDataObject
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONExtensions.ToJSON(System.Object,NFX.Serialization.JSON.JSONWritingOptions)">
            <summary>
             Serializes object into JSON string
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONExtensions.ToJSON(System.Object,System.IO.TextWriter,NFX.Serialization.JSON.JSONWritingOptions)">
            <summary>
             Serializes object into JSON format using provided TextWriter
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONExtensions.ToJSON(System.Object,System.IO.Stream,NFX.Serialization.JSON.JSONWritingOptions,System.Text.Encoding)">
            <summary>
             Serializes object into JSON format using provided stream and optional encoding
            </summary>
        </member>
        <member name="T:NFX.Serialization.JSON.IJSONReadable">
            <summary>
            Denotes a CLR type-safe entity (class or struct) that can directly read itself from IJSONDataObject which is supplied by JSON parser.
            This mechanism bypasses all of the reflection/dynamic code.
            This approach may be far more performant for some classes that need to de-serialize their state/data from JSON format, 
            than relying on general-purpose JSON serializer that can deserialize any type but is slower.
            The particular type has to be allocated first, then it's instance can be hydrated with data/state using this method
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.IJSONReadable.ReadAsJSON(NFX.Serialization.JSON.IJSONDataObject)">
            <summary>
            Reads entitie's data/state from low-level IJSONDataObject which is supplied right by JSONParser.
            An implementer may elect to throw various types of esceptions to signal such conditions as:
             unknown key map, or too many fields not supplied etc.
            </summary>
            <param name="data">JSONParser-supplied object</param>
        </member>
        <member name="T:NFX.CodeAnalysis.JSON.JSONPatternMatchAttribute">
            <summary>
            Base class for JSON pattern matching 
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.JSON.JSONPatternMatchAttribute.Check(System.Reflection.MemberInfo,NFX.CodeAnalysis.JSON.JSONLexer)">
            <summary>
            Checks all pattern match attributes against specified member info until first match found
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.JSON.JSONPatternMatchAttribute.Match(NFX.CodeAnalysis.JSON.JSONLexer)">
            <summary>
            Override to perform actual pattern matching, i.e. the one that uses FSM
            </summary>
        </member>
        <member name="T:NFX.Serialization.JSON.JSONWriter">
            <summary>
            Writes primitive types, JSONDataObjects, JSONDynamicObjects, IEnumerable and IDictionary - implementers into string or stream.
            Can also write IJSONWritable-implementing types that directly serialize their state into JSON.
            This class does not serialize regular CLR types (that do not implement IJSONWritable), use JSONSerializer for full functionality
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONWriter.Write(System.Object,System.IO.Stream,NFX.Serialization.JSON.JSONWritingOptions,System.Text.Encoding)">
            <summary>
            Writes JSON data to the stream
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONWriter.Write(System.Object,NFX.Serialization.JSON.JSONWritingOptions,System.IFormatProvider)">
            <summary>
            Writes JSON data to the string
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONWriter.Write(System.Object,System.IO.TextWriter,NFX.Serialization.JSON.JSONWritingOptions)">
            <summary>
            Appends JSON data into the instance of StringBuilder
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONWriter.WriteMap(System.IO.TextWriter,System.Collections.IDictionary,System.Int32,NFX.Serialization.JSON.JSONWritingOptions)">
            <summary>
            Appends JSON representation of a map(IDictionary)
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONWriter.WriteArray(System.IO.TextWriter,System.Collections.IEnumerable,System.Int32,NFX.Serialization.JSON.JSONWritingOptions)">
            <summary>
            Appends JSON representation of an IEnumerable
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONWriter.EncodeString(System.IO.TextWriter,System.String,NFX.Serialization.JSON.JSONWritingOptions)">
            <summary>
            Writes a string in JSON format (a la "JSON encode string") - using quotes and escaping charecters that need it
            </summary>
            <param name="wri">TextWriter instance to append data into</param>
            <param name="data">Original string to encode as JSON</param>
            <param name="opt">JSONWriting options instance, if omitted then JSONWritingOptions.Compact is used</param>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONWriter.EncodeDateTime(System.IO.TextWriter,System.DateTime,NFX.Serialization.JSON.JSONWritingOptions,System.Nullable{System.TimeSpan})">
            <summary>
            Writes a string in JSON format (a la "JSON encode string") - using quotes and escaping charecters that need it
            </summary>
            <param name="wri">TextWriter instance to append data into</param>
            <param name="data">Original string to encode as JSON</param>
            <param name="opt">JSONWriting options instance, if omitted then JSONWritingOptions.Compact is used</param>
            <param name="utcOffset">UTC offset override. If not supplied then offset form local time zone is used</param>
        </member>
        <member name="T:NFX.CodeAnalysis.Laconfig.LaconfigData">
            <summary>
            Represets laconfig parser result
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.ObjectResultAnalysisContext`1">
            <summary>
            A context that can hold analysis result as TObject. 
            This class is useful for cases like dynamic language parsers (i.e. JSON)
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.CommonCodeProcessor">
            <summary>
            Provides base implementation for common code processors
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.ICodeProcessor">
            <summary>
            Describes an entity that may process source code in some language
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.ICodeProcessor.MessageCodeToString(System.Int32)">
            <summary>
            Returns string representation of message code which is output by this processor
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.ICodeProcessor.Context">
            <summary>
            Returns context that this processor operates under
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.ICodeProcessor.Language">
            <summary>
            References language that this entity supports
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.ICodeProcessor.Messages">
            <summary>
            References message list that processor emitts messages into.
            May be null, in which case errors are always thrown because they can not get logged into message list
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.ICodeProcessor.ThrowErrors">
            <summary>
            When true, throws an exception on the first error even when MessageList is set.
            When MessageList is not set any error is always thrown regardless of this parameter
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.CommonCodeProcessor.MessageCodeToString(System.Int32)">
            <summary>
            Returns string representation of message code which is output by this processor
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.CommonCodeProcessor.Context">
            <summary>
            Returns context that this processor operates under -
            an entity that retains state during analysis, such as: module compiler, project compiler, code unit translator etc.
            This entity may also contain compiler/parser/lexer options etc.
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.CommonCodeProcessor.Messages">
            <summary>
            References message list that lexer emitts messages into. May be null
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.CommonCodeProcessor.ThrowErrors">
            <summary>
            When true, throws an exception on the first error even when MessageList is set.
            When MessageList is not set any lexing error is always thrown regardless of this parameter
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.CommonCodeProcessor.Language">
            <summary>
            Returns language that this processor is capable of processing
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.IAnalysisContext">
            <summary>
            Describes an entity that retains state during analysis, such as: module compiler, project compiler, code unit translator etc.
            This entity may also contain compiler/parser/lexer options etc.
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Laconfig.LaconfigKeywords">
            <summary>
            Provides Laconfig keyword resolution services, this class is thread safe
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Laconfig.LaconfigKeywords.Resolve(System.String)">
            <summary>
            Resolves a Laconfig keyword
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Laconfig.LaconfigLanguage">
            <summary>
            Represents Laconic + Config = Laconfig terse configuration language 
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Laconfig.LaconfigLexer">
            <summary>
            Performs lexical analysis on source supplied in Laconfig syntax.
            This class supports lazy analysis that happens gradually as result tokens are consumed through IEnumerable interface.
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Lexer`1">
            <summary>
            Performs lexical analysis of the source code in particular language
            Allows to enumerate over source as typed Token stream - depending on implementation enumeration may do 
            lexical analysis token-by-token or in chunks with every enumerator advance
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.SourceRefCommonCodeProcessor">
            <summary>
            Provides base implementation for common code processors
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.SourceRefCommonCodeProcessor.SourceCodeReference">
            <summary>
            References source code that is processed
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.ILexer">
            <summary>
            Describes general lexer interface. 
            Lexers turn string source input which is obtained via ISourceText implementation (i.e. FileSource,WebSource...)
             into tokenized stream. Some lexer implementations may support lazy analysis, that is - source text analysis which is done
              in chunks when lexer is iterated over, others may lex the whole source text at once
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.ILexer.AnalyzeAll">
            <summary>
            If lexer supports lazy analysis, forces analysis of the whole source
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.ILexer.SourceCodeReference">
            <summary>
            References source code that was lexed
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.ILexer.Source">
            <summary>
            References source code text that was lexed
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.ILexer.TokenStream">
            <summary>
            Enumerates Token stream - depending on implementation enumeration may do 
            lexical analysis token-by-token or in chunks with every enumerator advance
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.ILexer.AllAnalyzed">
            <summary>
            Returns true when the shole input source has been analyzed. This property is always true for lexers that do not support lazy analysis
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Lexer`1.AnalyzeAll">
            <summary>
            If lexer supports lazy analysis, forces analysis of the whole source
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Lexer`1.DoLexingChunk">
            <summary>
            Lexes more source and returns true when EOF has been reached.
            Depending on particular implementation, a chunk may contain more than one token.
            Tokens are added into m_Tokens
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Lexer`1.Source">
            <summary>
            References source code text that was lexed
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Lexer`1.AllAnalyzed">
            <summary>
            Returns true when the whole input source has been analyzed. This property is always true for lexers that do not support lazy analysis
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Lexer`1.Tokens">
            <summary>
            Returns tokenized source as indexable list. 
            Accessing this property causes lexical analysis to complete on the whole source if it has not been completed yet
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Lexer`1.TokenStream">
            <summary>
            Enumerates Token stream - depending on implementation enumeration may do 
            lexical analysis token-by-token or in chunks with every enumerator advance
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Laconfig.LaconfigMsgCode">
            <summary>
            Message codes for Laconfig code processors
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Laconfig.LaconfigParser">
            <summary>
            Parses Laconfig lexer output into laconic configuration node graph
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Parser`1">
            <summary>
            Performs parsing of token streams provided by lexers
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.IParser">
            <summary>
            Describes general parser interface
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.IParser.Parse">
            <summary>
            Performs parsing and sets HasParsed to true if it has not been performed yet
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.IParser.SourceInput">
            <summary>
            Lists source lexers that supply token stream for parsing
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.IParser.HasParsed">
            <summary>
            Indicates whether Parse() already happened
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Parser`1.Parse">
            <summary>
            Performs parsing if it has not been performed yet
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Parser`1.DoParse">
            <summary>
            Override to perform actual parsing
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Parser`1.Input">
            <summary>
            Returns lexers that feed this parser
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Parser`1.SourceInput">
            <summary>
            Lists source lexers that supply token stream for parsing
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Parser`1.HasParsed">
            <summary>
            Indicates whether Parse() already happened
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Laconfig.LaconfigToken">
            <summary>
            Represents a token of Laconfig language
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Token">
            <summary>
            Represents a lexical token of the language. This is an abstract class that particular language implementations must extend
             to define language-specific token types
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Token.Language">
            <summary>
            Returns language that this token is a part of
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Token.Kind">
            <summary>
            Provides language-agnostic classification for token type
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Token.IsPrimary">
            <summary>
            Returns true for tokens that are primary part of the language, not control, metadata, directive, comment etc...
            For example BOF,EOF markers are not primary part of the language, compiler directives, comments are not either.
            This property is useful for pattern searches, when comments and other non-primary tokens need to be quickly skipped
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Token.IsNonLanguage">
            <summary>
            This property is needed due to the fact that language lexers may be used to analyze special supersets of regular 
             language grammars i.e. for pattern matches, template parser etc. Code compilers may elect to throw errors when this property is true.
            Returns true for tokens that are not part of the valid language grammar, however they exist for other reasons,
            for example - for pattern capture match analysis, or for template processing 
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Token.OrdinalType">
            <summary>
            Returns token type as a grammar-agnostic ordinal 
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Token.IsBOF">
            <summary>
            Indicates whether this token indicates an BEGINNING-OF-FILE condition
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Token.IsEOF">
            <summary>
            Indicates whether this token indicates an END-OF-FILE condition
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Token.IsDirective">
            <summary>
            Indicates whether this token represents a directive
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Token.IsComment">
            <summary>
            Indicates whether this token represents a comment
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Token.IsLiteral">
            <summary>
            Indicates whether this token represents a literal
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Token.IsTextualLiteral">
            <summary>
            Indicates whether this token represents a literal, which is a string or a character sequence.
            This flag is useful for pattern searches that examine comments and strings for sub-patterns
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Token.IsNumericLiteral">
            <summary>
            Indicates whether this token represents a literal, which is a numeric literal (i.e. int, double)
            This flag is useful for pattern searches that look for particular constant values in numbers (i.e. year = 2000)
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Token.IsIdentifier">
            <summary>
            Indicates whether this token represents an identifier
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Token.IsKeyword">
            <summary>
            Indicates whether this token represents a language keyword
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Token.IsOperator">
            <summary>
            Indicates whether this token represents an operator
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Token.IsSymbol">
            <summary>
            Indicates whether this token represents a symbol
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Laconfig.LaconfigTokenType">
            <summary>
            Denotes Laconfig token types
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Laconfig.LaconfigWritingOptions">
            <summary>
            Specifies how Laconic configuration should be written as text. Use LaconfigWritingOptions.Compact or LaconfigWritingOptions.PrettyPrint
             static properties for typical options
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Laconfig.LaconfigWritingOptions.Compact">
            <summary>
            Writes Laconfig without line breaks between members and no indenting. Suitable for data transmission
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Laconfig.LaconfigWritingOptions.PrettyPrint">
            <summary>
            Writes Laconfig suitable for printing/screen display
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Laconfig.LaconfigWriter">
            <summary>
            Writes Laconic Configuration into a stream or string
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Laconfig.LaconfigWriter.Write(NFX.Environment.Configuration,System.IO.Stream,NFX.CodeAnalysis.Laconfig.LaconfigWritingOptions,System.Text.Encoding)">
            <summary>
            Writes LaconicConfiguration data to the stream
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Laconfig.LaconfigWriter.Write(NFX.Environment.IConfigSectionNode,System.IO.Stream,NFX.CodeAnalysis.Laconfig.LaconfigWritingOptions,System.Text.Encoding)">
            <summary>
            Writes LaconicConfiguration data to the stream
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Laconfig.LaconfigWriter.Write(NFX.Environment.Configuration,NFX.CodeAnalysis.Laconfig.LaconfigWritingOptions)">
            <summary>
            Writes LaconicConfiguration data to the string
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Laconfig.LaconfigWriter.Write(NFX.Environment.IConfigSectionNode,NFX.CodeAnalysis.Laconfig.LaconfigWritingOptions)">
            <summary>
            Writes LaconicConfiguration data to the string
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Laconfig.LaconfigWriter.Write(NFX.Environment.Configuration,System.Text.StringBuilder,NFX.CodeAnalysis.Laconfig.LaconfigWritingOptions)">
            <summary>
            Appends LaconicConfiguration data into the instance of StringBuilder
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Laconfig.LaconfigWriter.Write(NFX.Environment.IConfigSectionNode,System.Text.StringBuilder,NFX.CodeAnalysis.Laconfig.LaconfigWritingOptions)">
            <summary>
            Appends LaconicConfiguration data into the instance of StringBuilder
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Laconfig.LaconfigWriter.Indent(System.Int32,NFX.CodeAnalysis.Laconfig.LaconfigWritingOptions)">
            <summary>
            Returns a padding string for specified level per set options
            </summary>
        </member>
        <member name="T:NFX.Environment.Behavior">
            <summary>
            Represents a piece of logic that can be applied to different entities declaratively as attribute or through configuration.
            Behaviors are a form of inversion-of-control that allows to configure entities by code which itself can be injected by name from configuration. 
            Behaviors are a form of aspect-oriented programming as they allow to proclaim certain "behavior" that knows how to implement itself on various
             application components (i.e. some behavior may inject Glue message inspector or log destination).
            Behaviors can be used to enforce policies by performing pre-run checks  and throw exceptions if certain required providers are not injected/configured
            </summary>
        </member>
        <member name="M:NFX.Environment.Behavior.ApplyConfiguredBehaviors(System.Object,NFX.Environment.IConfigSectionNode)">
            <summary>
            Applies behaviors to instance as configured from config section node
            </summary>
        </member>
        <member name="M:NFX.Environment.Behavior.ApplyBehaviorAttributes(System.Object)">
            <summary>
            Applies behaviors as declared using attributes on target isntance's type
            </summary>
        </member>
        <member name="M:NFX.Environment.Behavior.Apply(System.Object)">
            <summary>
            Override to apply particular behavior to the target
            </summary>
        </member>
        <member name="P:NFX.Environment.Behavior.Order">
            <summary>
            Returns application order
            </summary>
        </member>
        <member name="P:NFX.Environment.Behavior.Cascade">
            <summary>
            Returns true when this instance was configured to cascade down the configuration tree - applied to child items
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.CSharp.CSLanguage">
            <summary>
            Represents C# language
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.CSharp.CSLexer">
            <summary>
            Performs lexical analysis on source supplied in C# syntax.
            This class supports lazy analysis that happens gradually as result tokens are consumed through IEnumerable interface.
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.CSharp.CSMsgCode">
            <summary>
            Message codes for CSharp code processors
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.CSharp.CSToken">
            <summary>
            Represents a C# token
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.CSharp.CSTokenType">
            <summary>
            Denotes CSharp token types
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.CSharp.CSIdentifiers">
            <summary>
            Identifier validation in a context of C# grammar
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.CSharp.CSIdentifiers.ValidateDigit(System.Char)">
            <summary>
            Checks to see whether supplied char is a digit
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.CSharp.CSIdentifiers.ValidateChar(System.Char)">
            <summary>
            Checks whether supplied char is suitable for a part of C# id
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.CSharp.CSIdentifiers.Validate(System.String)">
            <summary>
            Checks whether supplied string is a valid C# ident
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.CSharp.CSKeywords">
            <summary>
            Provides C# keyword resolution services, this class is thread safe
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.CSharp.CSKeywords.Resolve(System.String)">
            <summary>
            Resolves a C# keyword - this method IS thread safe
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.CSharp.CSNumbers">
            <summary>
            Provides C# number parsing
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.CSharp.CSNumbers.Convert(System.String,NFX.CodeAnalysis.CSharp.CSTokenType@)">
            <summary>
            Tries to convert string to number, returns null if conversion could not be made.
            Raises exception if operand is wider than specifier allows
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.CSharp.CSNumbers.strToInt(System.String,System.UInt64@)">
            <summary>
             Converts number string into int respectibg prefixes
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.CSharp.CSStrings">
            <summary>
            Provides C# string escape parsing
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.JSON.JSONParser">
            <summary>
            Parses JSON lexer output into object graphs.
            NOTE: Although called JSON, this is really a JSON superset implementation that includes extra features:
             comments, directives, verbatim strings(start with $), ' or " string escapes, unquoted object key names 
            </summary>
        </member>
        <member name="T:NFX.Serialization.JSON.IJSONDataObject">
            <summary>
            Represents a data transfer object (DTO) abstraction used to read/write JSON data
            </summary>
        </member>
        <member name="T:NFX.Serialization.JSON.JSONDataMap">
            <summary>
            Represents a data transfer object (DTO) JSON map, that associates keys with values
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONDataMap.FromURLEncodedStream(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Turns URL encoded content into JSONDataMap
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONDataMap.FromURLEncodedString(System.String)">
            <summary>
            Turns URL encoded content into JSONDataMap
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONDataMap.Append(NFX.Serialization.JSON.JSONDataMap,System.Boolean)">
            <summary>
            Appends contents of another JSONDataMap for keys that do not exist in this one or null.
            Only appends references, does not provide deep reference copy
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONDataMap.ToConfigNode(System.String)">
            <summary>
            Returns this object as a config tree
            </summary>
        </member>
        <member name="T:NFX.Serialization.JSON.JSONDataArray">
            <summary>
            Represents a data transfer object (DTO) JSON array, that holds a list of values
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.JSON.JSONIdentifiers">
            <summary>
            Identifier validation and other utilities in context of JSON grammar
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.JSON.JSONIdentifiers.ValidateChar(System.Char)">
            <summary>
            Checks whether supplied char is suitable for a part of JSON identifier
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.JSON.JSONIdentifiers.ValidateDigit(System.Char)">
            <summary>
            Checks to see whether supplied char is a digit
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.JSON.JSONIdentifiers.Validate(System.String)">
            <summary>
            Checks whether supplied string is a valid JSON grammar identifier
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.JSON.JSONData">
            <summary>
            Represents JSONDataParser result
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.JSON.JSONMsgCode">
            <summary>
            Message codes for JSON code processors
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.JSON.JSONKeywords">
            <summary>
            Provides JSON keyword resolution services, this class is thread safe
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.JSON.JSONKeywords.Resolve(System.String)">
            <summary>
            Resolves a JSON keyword - this method IS thread safe
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.JSON.JSONNumbers.Convert(System.String,NFX.CodeAnalysis.JSON.JSONTokenType@)">
            <summary>
            Tries to convert string to number, returns null if conversion could not be made
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.JSON.JSONStrings">
            <summary>
            Provides JSON string escape parsing
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.FSMI">
            <summary>
            Describes transition instructions for Finate State Machine (FSM) 
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.LazyFSMPredicate`1">
            <summary>
            Lazy Finate State Machine (FSM) predicate, tries to match condition and returns appropriate next action
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.PatternSearch">
            <summary>
            Provides Token-pattern matching utilities
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.LazyFSM``1(System.Collections.Generic.IEnumerable{``0},NFX.CodeAnalysis.LazyFSMPredicate{``0}[])">
            <summary>
            Makes finite state machine fed from IEnumerable(Token) only considering primary language tokens
            </summary>
            <typeparam name="TToken">Concrete language-typed token</typeparam>
            <param name="tokens">Token enumerable</param>
            <param name="predicates">Predicates that supply machine state transition instructions</param>
            <returns>Resulting token fetched by FSMI.Take instruction or null</returns>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.LazyFSM``1(System.Collections.Generic.IEnumerable{``0},System.Boolean,NFX.CodeAnalysis.LazyFSMPredicate{``0}[])">
            <summary>
            Makes finite state machine fed from IEnumerable(Token)
            </summary>
            <typeparam name="TToken">Concrete language-typed token</typeparam>
            <param name="tokens">Token enumerable</param>
            <param name="onlyPrimary">Sets filter to consider only primary language tokens (skip comments, directives, etc.)</param>
            <param name="predicates">Predicates that supply machine state transition instructions</param>
            <returns>Resulting token fetched by FSMI.Take instruction or null</returns>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.LazyFSM``1(System.Collections.Generic.IEnumerable{``0},System.Boolean,NFX.CodeAnalysis.LazyFSMState{``0}@,NFX.CodeAnalysis.LazyFSMPredicate{``0}[])">
            <summary>
            Makes finite state machine fed from IEnumerable(Token)
            </summary>
            <typeparam name="TToken">Concrete language-typed token</typeparam>
            <param name="tokens">Token enumerable</param>
            <param name="onlyPrimary">Sets filter to consider only primary language tokens (skip comments, directives, etc.)</param>
            <param name="state">Machine's state which will be allocated if null passed</param>
            <param name="predicates">Predicates that supply machine state transition instructions</param>
            <returns>Resulting token fetched by FSMI.Take instruction or null</returns>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.Skip``1(NFX.CodeAnalysis.LazyFSMState{``0},System.Int32)">
            <summary>
            Skips specified number of tokens by returning FSMI.Loop count times
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.TypeIsAnyOf``1(``0,System.Int32[])">
            <summary>
            Returns true when token's type is any of the specified
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.TypeIsAnyOf``2(``0,``1[])">
            <summary>
            Returns true when token's type is any of the specified
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.TextIsAnyOf``1(``0,System.String[])">
            <summary>
            Returns true when token's text is any of specified
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.TextIsAnyOf``1(``0,System.StringComparison,System.String[])">
            <summary>
            Returns true when token's text is any of specified
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.IsAnyOrAbort``1(``0,System.Int32[])">
            <summary>
            Advances FSM when token's type is any of specified or aborts FSM
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.IsAnyOrAbort``2(``0,``1[])">
            <summary>
            Advances FSM when token's type is any of specified or aborts FSM
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.IsAnyOrAbort``1(``0,System.String[])">
            <summary>
            Advances FSM when token's text is any of specified or aborts FSM
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.IsAnyOrAbort``1(``0,System.StringComparison,System.String[])">
            <summary>
            Advances FSM when token's text is any of specified or aborts FSM
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.LoopUntilAny``1(``0,System.Int32[])">
            <summary>
            Advances FSM when token's type is any of specified or loops FSM
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.LoopUntilAny``2(``0,``1[])">
            <summary>
            Advances FSM when token's type is any of specified or loops FSM
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.LoopUntilAny``1(``0,System.String[])">
            <summary>
            Advances FSM when token's text is any of specified or loops FSM
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.LoopUntilAny``1(``0,System.StringComparison,System.String[])">
            <summary>
            Advances FSM when token's text is any of specified or loops FSM
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.DoUntilAny``1(``0,NFX.CodeAnalysis.FSMI,System.Int32[])">
            <summary>
            Performs FSM instruction unless token's type is any of the specified, then advances FSM
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.DoUntilAny``2(``0,NFX.CodeAnalysis.FSMI,``1[])">
            <summary>
            Performs FSM instruction unless token's type is any of the specified, then advances FSM
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.DoUntilAny``1(``0,NFX.CodeAnalysis.FSMI,System.String[])">
            <summary>
            Performs FSM instruction unless token's text is any of the specified, then advances FSM
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.DoUntilAny``1(``0,NFX.CodeAnalysis.FSMI,System.StringComparison,System.String[])">
            <summary>
            Performs FSM instruction unless token's text is any of the specified, then advances FSM
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.LoopWhileAnyOrAbort``1(``0,System.Int32[])">
            <summary>
            Loops FSM while token's type is any of the specified or aborts
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.LoopWhileAnyOrAbort``2(``0,``1[])">
            <summary>
            Loops FSM while token's type is any of the specified or aborts
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.LoopWhileAnyOrAbort``1(``0,System.String[])">
            <summary>
            Loops FSM while token's text is any of the specified or aborts
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.LoopWhileAnyOrAbort``1(``0,System.StringComparison,System.String[])">
            <summary>
            Loops FSM while token's text is any of the specified or aborts
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.LoopUntilMatch``1(NFX.CodeAnalysis.LazyFSMState{``0},NFX.CodeAnalysis.LazyFSMPredicate{``0}[])">
            <summary>
            Loops until token pattern match succeeds, considering only primary language tokens.
            Keeps state machine if match was found on the first matching token
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.LoopUntilMatch``1(NFX.CodeAnalysis.LazyFSMState{``0},System.Boolean,NFX.CodeAnalysis.LazyFSMPredicate{``0}[])">
            <summary>
            Loops until token pattern match succeeds, conditionaly considering only primary language tokens.
            Keeps state machine if match was found on the first matching token
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.LoopUntilAfterMatch``1(NFX.CodeAnalysis.LazyFSMState{``0},NFX.CodeAnalysis.LazyFSMPredicate{``0}[])">
            <summary>
            Loops until token pattern match succeeds.
            This method matches using the same primary token filter as the parent match.
            Keeps state machine if match was found on the first token that follows the match
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.LazyFSMState`1">
            <summary>
            Represents a state object for Lazy Finate State Machine that enumerates tokes from IEnumerable(Token)
             and does not support a notion of index addressing
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.LazyFSMState`1.Get``1(System.Object)">
            <summary>
            Gets typecasted value for a key
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.LazyFSMState`1.CurrentToken">
            <summary>
            Returns token that machine is at now
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.LazyFSMState`1.OnlyPrimary">
            <summary>
            Returns true when state machine only considers language-primary tokens
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.LazyFSMState`1.CurrentTokenIndex">
            <summary>
            Returns an index for token that machine is on now
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.LazyFSMState`1.PatternTokenLength">
            <summary>
            Returns how many tokens have been covered by the current match pattern, i.e. if we loop until first int literal,
             this property will count how many tokens have been looped + int literal itself
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.LazyFSMState`1.Tokens">
            <summary>
            Returns token enumerable that analysis is performed on
            </summary>
        </member>
        <member name="T:NFX.DataAccess.NOPDataStore">
            <summary>
            Represents data store that does not do anything
            </summary>
        </member>
        <member name="P:NFX.DataAccess.NOPDataStore.Instance">
            <summary>
            Returns a singlelton instance of the data store that does not do anything
            </summary>
        </member>
        <member name="T:NFX.DebugAction">
            <summary>
            Specifies how to handle Assertion and other failures
            </summary>
        </member>
        <member name="F:NFX.DebugAction.Default">
            <summary>Default to the value of Debugging.DefaultDebugAction</summary>
        </member>
        <member name="F:NFX.DebugAction.Throw">
            <summary>Throw exception</summary>
        </member>
        <member name="F:NFX.DebugAction.Log">
            <summary>Write message to log</summary>
        </member>
        <member name="F:NFX.DebugAction.ThrowAndLog">
            <summary>Shortcut for throwing exception and writing a message to log</summary>
        </member>
        <member name="T:NFX.Debug">
            <summary>
            Facilitates debugging tasks enabled by DEBUG conditional define
            </summary>
        </member>
        <member name="M:NFX.Debug.Write(System.Func{System.String},NFX.Log.MessageType,System.Nullable{System.Guid})">
            <summary>
            A simplified method for tracing that doesn't evaluate text generation function
            if tracing is disabled by configuration
            </summary>
            <param name="textFunc">Functor to evaluate to get the text sent to logger</param>
            <param name="type">Message type to log</param>
            <param name="correlationContext">Optional correlation token to relate log entries</param>
        </member>
        <member name="T:NFX.Trace">
            <summary>
            Facilitates debugging tasks enabled by TRACE conditional define
            </summary>
        </member>
        <member name="M:NFX.Trace.Write(System.Func{System.String},NFX.Log.MessageType,System.Nullable{System.Guid})">
            <summary>
            A simplified method for tracing that doesn't evaluate text generation function
            if tracing is disabled by configuration
            </summary>
            <param name="textFunc">Functor to evaluate to get the text sent to logger</param>
            <param name="type">Message type to log</param>
            <param name="correlationContext">Optional correlation token to relate log entries</param>
        </member>
        <member name="M:NFX.Trace.Write``1(System.Func{``0,System.String},``0,NFX.Log.MessageType,System.Nullable{System.Guid})">
            <summary>
            A simplified method for tracing that doesn't evaluate text generation function
            if tracing is disabled by configuration. It takes context argument that can be passed to the
            text-generating textFunc functor
            </summary>
            <param name="textFunc">Functor to evaluate to get the text sent to logger</param>
            <param name="ctx">Context object</param>
            <param name="type">Message type to log</param>
            <param name="correlationContext">Optional correlation token to relate log entries</param>
        </member>
        <member name="T:NFX.Debugging">
            <summary>
            Facilitates debugging tasks that do not depend on any conditional defines
            </summary>
        </member>
        <member name="P:NFX.Debugging.DefaultDebugAction">
            <summary>
            Returns the global default setting, and optionally
            reads default debug action from global application's configuration
            if its value is DefaultFromConfig (default). Application can override
            this value at startup in order to avoid dynamic configuration lookups
            on every call
            </summary>
        </member>
        <member name="P:NFX.Debugging.TraceDisabled">
            <summary>
            Controls wether to send Trace.Write() and Debug.Write() output to LogService
            </summary>
        </member>
        <member name="T:NFX.DumpFormat">
            <summary>
            Format of the String Dump
            </summary>
        </member>
        <member name="F:NFX.DumpFormat.Binary">
            <summary>
            Perform no conversion - data copied as is
            </summary>
        </member>
        <member name="F:NFX.DumpFormat.Decimal">
            <summary>
            Decimal string representation. E.g. "&lt;&lt;39, 16, 25, ...>>"
            </summary>
        </member>
        <member name="F:NFX.DumpFormat.Hex">
            <summary>
            Hex string representation. E.g. "A1 B9 16 ..."
            </summary>
        </member>
        <member name="F:NFX.DumpFormat.Printable">
            <summary>
            Human readable string representation. E.g. "...Test 123\n..."
            </summary>
        </member>
        <member name="T:NFX.Environment.ConfigMacroContextAttribute">
            <summary>
            Decorates classes or structs that act as a context object for macro evaluation - passed as context parameter to MacroRunner.Run(...context) method
            </summary>
        </member>
        <member name="T:NFX.Environment.ConfigAttribute">
            <summary>
            Specifies how to apply configuration values to classes/fields/props
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigAttribute.#ctor">
            <summary>
            Decorates members so that path is defaulted from member's name with prepended '$' attribute symbol
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigAttribute.#ctor(System.String)">
            <summary>
            Decorates members that will be configured from supplied path
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigAttribute.#ctor(System.String,System.Object)">
            <summary>
            Decorates members that will be configured from supplied path and defaulted in case
             the supplied path does not resolve to existing node
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigAttribute.Apply(System.Object,NFX.Environment.IConfigSectionNode)">
            <summary>
            Applies config values to fields/properties as specified by config attributes
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigAttribute.GetConfigPathsForMember(System.Reflection.MemberInfo)">
            <summary>
            Generates 2 attribute paths for named member. This first path is just the member name converted to lower case.
            The seconfd path is "OR"ed with the first one and is taken from member name where all case transitions are prefixed with "-".
            For private fields 'm_' and 's_' prefixes are removed
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigAttribute.Path">
            <summary>
            String path of configuration source i.e. 'log/machine-name'.
            Path is relative to item root
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigAttribute.Default">
            <summary>
            Default value used when configuration does not specify any other value
            </summary>
        </member>
        <member name="T:NFX.Environment.ConfigException">
            <summary>
            Configuration-related exception
            </summary>
        </member>
        <member name="T:NFX.Environment.BehaviorApplyException">
            <summary>
            Thrown by Behavior class to indicate behavior apply error
            </summary>
        </member>
        <member name="T:NFX.Environment.LaconicConfiguration">
             <summary>
             Provides implementation of configuration based on Laconic content format
             </summary>
             <example>
             Example Laconic Configuration Content:
            
             nfx //comments are allowed
             {
               log-root=$"c:\nfx\"
               log-csv="NFX.Log.Destinations.CSVFileDestination, NFX"
               debug-default-action="Log,Throw"
                 
               log
               { 
                 name="Logger"
             
                 destination
                 {  
                   type=$(/$log-csv)
                   name="WinFormsTest Log"//strings in dblquotes
                   path=$(/$log-root) 
                   name-time-format='yyyyMMdd'//strings in snglquotes
                   generate-failover-msg=false
                 }
               }
               /* multiline comments
                data-store {type="NFX.RecordModel.DataAccess.MongoDB.MongoDBModelDataStore, NFX.MongoDB" 
                            connect-string="mongodb://localhost"
                            db-name="test"}  
               */
             }
             </example>
        </member>
        <member name="T:NFX.Environment.FileConfiguration">
            <summary>
            Provides file-based configuration base object used for concrete implementations such as XML or INI file base configurations
            </summary>
        </member>
        <member name="T:NFX.Environment.Configuration">
            <summary>
            Provides top-level configuration abstraction
            </summary>
        </member>
        <member name="M:NFX.Environment.Configuration.ProviderLoadFromFile(System.String)">
            <summary>
            Loads the contents of the supplied file name in an appropriate configuration provider implementation for the supplied extension format
            </summary>
        </member>
        <member name="M:NFX.Environment.Configuration.ProviderLoadFromAnySupportedFormatFile(System.String)">
            <summary>
            Loads the contents of the supplied file name without format extension trying to match any of the supported format extensions.
            When match is found the file is loaded via an appropriate configuration provider
            </summary>
            <example>
            Given "c:\conf\users" as an input:
              if "c:\conf\users.xml" exists then it will be opened as XMLConfiguration
              if "c:\conf\users.laconf" exists then it will be opened as LaconicConfiguration
              and so on... for the rest of supported formats
            </example>
        </member>
        <member name="M:NFX.Environment.Configuration.ProviderLoadFromString(System.String,System.String)">
            <summary>
            Loads the supplied string content in the specified format, which may be format name like "xml" or "laconfig" with or without extension period
            </summary>
        </member>
        <member name="F:NFX.Environment.Configuration.ProcesswideEnvironmentVarResolver">
            <summary>
            Gets/sets global Environment variable resolver that is used by all configurations in this process instance
            </summary>
        </member>
        <member name="M:NFX.Environment.Configuration.Create(System.String)">
            <summary>
            Creates new configuration - creates new configuration root with optional name parameter
            </summary>
        </member>
        <member name="M:NFX.Environment.Configuration.CreateFromMerge(NFX.Environment.ConfigSectionNode,NFX.Environment.ConfigSectionNode,NFX.Environment.NodeOverrideRules)">
            <summary>
            Creates new configuration from ordered merge result of two other nodes - base and override which can be from different configurations
            </summary>
            <param name="baseNode">A base node that data is defaulted from</param>
            <param name="overrideNode">A node that contains overrides/additions of/to data from base node</param>
            <param name="rules">Rules to use or default rules will be used in null is passed</param>
        </member>
        <member name="M:NFX.Environment.Configuration.CreateFromNode(NFX.Environment.IConfigSectionNode)">
            <summary>
            Creates new configuration from other node, which may belong to a different configuration instance
            </summary>
            <param name="otherNode">A base node that data is defaulted from</param>
        </member>
        <member name="M:NFX.Environment.Configuration.Destroy">
            <summary>
            Erases all config data
            </summary>
        </member>
        <member name="M:NFX.Environment.Configuration.Refresh">
            <summary>
            Re-reads configuration from source
            </summary>
        </member>
        <member name="M:NFX.Environment.Configuration.Save">
            <summary>
            Saves configuration to source
            </summary>
        </member>
        <member name="M:NFX.Environment.Configuration.CheckAndAdjustNodeName(System.String)">
            <summary>
            Checks node name for aptitude for particular configuration type.
            For example, XML configuration does not allow nodes with spaces or separator chars.
            When StrictNames is set to true and value is not appropriate then exception is thrown
            </summary>
        </member>
        <member name="M:NFX.Environment.Configuration.ResolveEnvironmentVar(System.String,NFX.Environment.IEnvironmentVariableResolver)">
            <summary>
            Resolves variable name into its value
            </summary>
        </member>
        <member name="M:NFX.Environment.Configuration.RunMacro(NFX.Environment.IConfigSectionNode,System.String,System.String,NFX.Environment.IConfigSectionNode,NFX.Environment.IMacroRunner,System.Object)">
            <summary>
            Runs macro and returns its value
            </summary>
        </member>
        <member name="M:NFX.Environment.Configuration.Clone``1">
            <summary>
            Creates a deep copy of this configuration into new instance of T
            </summary>
        </member>
        <member name="M:NFX.Environment.Configuration.Clone(NFX.Environment.Configuration)">
            <summary>
            Creates a deep copy of this configuration into newInstance which was allocated externally
            </summary>
        </member>
        <member name="M:NFX.Environment.Configuration.Clone">
            <summary>
            Implements IClonable by returning new MemoryConfiguration clone
            </summary>
        </member>
        <member name="M:NFX.Environment.Configuration.Include(NFX.Environment.ConfigSectionNode,NFX.Environment.ConfigSectionNode)">
            <summary>
            Completely replaces this node with another node tree, positioning the new tree in the place of local node.
            Existing node is deleted after this operation completes, in its place child nodes from other node are inserted
            preserving their existing order. Attributes of other node get merged into parent of existing node
            </summary>
        </member>
        <member name="M:NFX.Environment.Configuration.ToLaconicString(NFX.CodeAnalysis.Laconfig.LaconfigWritingOptions)">
            <summary>
            Serializes configuration tree into Laconic format and returns it as a string
            </summary>
        </member>
        <member name="M:NFX.Environment.Configuration.ToLaconicStream(System.IO.Stream,NFX.CodeAnalysis.Laconfig.LaconfigWritingOptions,System.Text.Encoding)">
            <summary>
            Serializes configuration tree into Laconic format and writes it into stream
            </summary>
        </member>
        <member name="M:NFX.Environment.Configuration.ToLaconicFile(System.String,NFX.CodeAnalysis.Laconfig.LaconfigWritingOptions,System.Text.Encoding)">
            <summary>
            Serializes configuration tree into Laconic format and writes it into a file
            </summary>
        </member>
        <member name="M:NFX.Environment.Configuration.AdjustNodeName(System.String)">
            <summary>
            Override to perform transforms on node names so they become suitable for particular configuration type
            </summary>
        </member>
        <member name="P:NFX.Environment.Configuration.AllSupportedFormats">
            <summary>
            Returns all configuration file formats (file extensions without '.') supported 
            by ProviderLoadFromFile/ProviderLoadFromAnySupportedFormatFile/ProviderLoadFromString
            </summary>
        </member>
        <member name="P:NFX.Environment.Configuration.Root">
            <summary>
            Accesses root section configuration node
            </summary>
        </member>
        <member name="P:NFX.Environment.Configuration.StrictNames">
            <summary>
            Determines whether exception is thrown when configuration node name contains
            inappropriate chars for particular configuration type. For example,
             for XMLConfiguration node names may not have spaces and other separator chars.
            When StrictNames is false then particular configurations may replace incompatible
             chars in node names with neutral ones (i.e. "my value"->"my-value" in case of XMLConfiguration).
            </summary>
        </member>
        <member name="P:NFX.Environment.Configuration.IsReadOnly">
            <summary>
            Indicates whether configuration is read-only
            </summary>
        </member>
        <member name="P:NFX.Environment.Configuration.EnvironmentVarResolver">
            <summary>
            References variable resolver. If this property is not set then default Windows environment var resolver is used
            </summary>
        </member>
        <member name="P:NFX.Environment.Configuration.MacroRunner">
            <summary>
            References macro runner. If this property is not set then default macro runner is used
            </summary>
        </member>
        <member name="P:NFX.Environment.Configuration.MacroRunnerContext">
            <summary>
            Gets/sets an object passed by the framework into MacroRunner.Run() method. 
            This property is auto-set for classes decorated with [ConfigMacroContext] attribute
            </summary>
        </member>
        <member name="P:NFX.Environment.Configuration.EmptySection">
            <summary>
            References a special instance of an empty section node (one per configuration).
            Empty nodes are returned by indexers when a real node with specified name does not exist
            </summary>
        </member>
        <member name="P:NFX.Environment.Configuration.EmptyAttr">
            <summary>
            References a special instance of an empty attribute node (one per configuration).
            Empty nodes are returned by indexers when a real node with specified name does not exist
            </summary>
        </member>
        <member name="P:NFX.Environment.Configuration.Variable_ESCAPE">
            <summary>
            Variable escape tag
            </summary>
        </member>
        <member name="P:NFX.Environment.Configuration.Variable_START">
            <summary>
            Variable start tag 
            </summary>
        </member>
        <member name="P:NFX.Environment.Configuration.Variable_END">
            <summary>
            Variable end tag 
            </summary>
        </member>
        <member name="P:NFX.Environment.Configuration.Variable_PATH_MOD">
            <summary>
            Variable path modifier 
            </summary>
        </member>
        <member name="P:NFX.Environment.Configuration.Variable_ENV_MOD">
            <summary>
            Variable environment modifier 
            </summary>
        </member>
        <member name="P:NFX.Environment.Configuration.Variable_MACRO_START">
            <summary>
            Variable get clause modifier
            </summary>
        </member>
        <member name="P:NFX.Environment.Configuration.ContentView">
            <summary>
            Primarily used for debugging - returns the content of the configuration as text in the pretty-printed Laconic format
            </summary>
        </member>
        <member name="M:NFX.Environment.FileConfiguration.#ctor">
            <summary>
            Creates an instance of a new configuration not bound to any file
            </summary>
        </member>
        <member name="M:NFX.Environment.FileConfiguration.#ctor(System.String)">
            <summary>
            Creates an isntance of configuration and reads contents from the file
            </summary>
        </member>
        <member name="M:NFX.Environment.FileConfiguration.SaveAs(System.String)">
            <summary>
            Saves configuration into specified file
            </summary>
        </member>
        <member name="P:NFX.Environment.FileConfiguration.IsReadOnly">
            <summary>
            Indicates whether configuration is readonly or may be modified and saved
            </summary>
        </member>
        <member name="M:NFX.Environment.LaconicConfiguration.#ctor">
            <summary>
            Creates an instance of a new configuration not bound to any laconfig file
            </summary>
        </member>
        <member name="M:NFX.Environment.LaconicConfiguration.#ctor(System.String)">
            <summary>
            Creates an isntance of the new configuration and reads contents from a laconfig file
            </summary>
        </member>
        <member name="M:NFX.Environment.LaconicConfiguration.CreateFromString(System.String)">
            <summary>
            Creates an instance of configuration initialized from laconfig passed as string
            </summary>
        </member>
        <member name="M:NFX.Environment.LaconicConfiguration.SaveAs(System.String)">
            <summary>
            Saves configuration into a file
            </summary>
        </member>
        <member name="M:NFX.Environment.LaconicConfiguration.SaveAs(System.String,NFX.CodeAnalysis.Laconfig.LaconfigWritingOptions)">
            <summary>
            Saves configuration into a file
            </summary>
        </member>
        <member name="M:NFX.Environment.LaconicConfiguration.SaveToString(NFX.CodeAnalysis.Laconfig.LaconfigWritingOptions)">
            <summary>
            Saves laconic configuration into string in Laconfig format and returns it
            </summary>
        </member>
        <member name="T:NFX.Environment.IMacroRunner">
            <summary>
            Represents an entity that runs config var macros
            </summary>
        </member>
        <member name="M:NFX.Environment.IMacroRunner.Run(NFX.Environment.IConfigSectionNode,System.String,System.String,NFX.Environment.IConfigSectionNode,System.Object)">
            <summary>
            Runs macro
            </summary>
        </member>
        <member name="T:NFX.Environment.DefaultMacroRunner">
            <summary>
            Provides default implementation for configuration variable macros.
            NOTE: When serialized a new instance is created which will not equal by reference to static.Instance property
            </summary>
        </member>
        <member name="M:NFX.Environment.DefaultMacroRunner.GetValueAs(System.String,System.String,System.String,System.String)">
            <summary>
            Returns a string value converted to desired type with optional default and format
            </summary>
            <param name="value">String value to convert</param>
            <param name="type">A type to convert string value into i.e. "decimal"</param>
            <param name="dflt">Default value which is used when conversion of original value can not be made</param>
            <param name="fmt">Format string that formats the converted value. Example: 'Goods: {0}'. The '0' index is the value</param>
            <returns>Converted value to desired type then back to string, using optional formatting and default if conversion did not succeed</returns>
        </member>
        <member name="P:NFX.Environment.DefaultMacroRunner.Instance">
            <summary>
            Returns a singleton class instance
            </summary>
        </member>
        <member name="T:NFX.Environment.IEnvironmentVariableResolver">
            <summary>
            Represents an entity that can resolve variables
            </summary>
        </member>
        <member name="M:NFX.Environment.IEnvironmentVariableResolver.ResolveEnvironmentVariable(System.String)">
            <summary>
            Turns named variable into its value or null 
            </summary>
        </member>
        <member name="T:NFX.Environment.WindowsEnvironmentVariableResolver">
            <summary>
            Resolves variables using Windows environment variables. 
            NOTE: When serialized a new instance is created which will not equal by reference to static.Instance property
            </summary>
        </member>
        <member name="P:NFX.Environment.WindowsEnvironmentVariableResolver.Instance">
            <summary>
            Returns a singleton class instance
            </summary>
        </member>
        <member name="T:NFX.Environment.Vars">
            <summary>
            Allows for simple ad-hoc environment var passing to configuration
            </summary>
        </member>
        <member name="T:NFX.Environment.OverrideSpec">
            <summary>
            Override specifications that dictate what to do when another node supplies entity with the same name
            </summary>
        </member>
        <member name="F:NFX.Environment.OverrideSpec.All">
            <summary>
            Override everything: attributes, sections, and value
            </summary>
        </member>
        <member name="F:NFX.Environment.OverrideSpec.Attributes">
            <summary>
            Ovveride attributes only
            </summary>
        </member>
        <member name="F:NFX.Environment.OverrideSpec.Sections">
            <summary>
            Override sections only
            </summary>
        </member>
        <member name="F:NFX.Environment.OverrideSpec.Replace">
            <summary>
            Completely replace node
            </summary>
        </member>
        <member name="F:NFX.Environment.OverrideSpec.Stop">
            <summary>
            Stop override at this level
            </summary>
        </member>
        <member name="F:NFX.Environment.OverrideSpec.Fail">
            <summary>
            Fail the process
            </summary>
        </member>
        <member name="T:NFX.Environment.NodeOverrideRules">
            <summary>
            Contains node override rule definitions such as override specifier names and values.
            This class is used for merging/override of configurations/nodes
            </summary>
        </member>
        <member name="M:NFX.Environment.NodeOverrideRules.StringToOverrideSpec(System.String)">
            <summary>
            Tries to convert a string to OverrideSpec enum. If string is null or empty then "All" is returned, otherwise exception is thrown if 
             the value does not match any of the expected values. The comparison is case-insensitive
            </summary>
        </member>
        <member name="P:NFX.Environment.NodeOverrideRules.Default">
            <summary>
            Default instance that uses default names
            </summary>
        </member>
        <member name="P:NFX.Environment.NodeOverrideRules.OverrideAttrName">
            <summary>
            Provides name for override attribute
            </summary>
        </member>
        <member name="P:NFX.Environment.NodeOverrideRules.OverrideValue_Attributes">
            <summary>
            Provides value for attributes-only override
            </summary>
        </member>
        <member name="P:NFX.Environment.NodeOverrideRules.OverrideValue_Sections">
            <summary>
            Provides value for sections-only override
            </summary>
        </member>
        <member name="P:NFX.Environment.NodeOverrideRules.OverrideValue_All">
            <summary>
            Provides value for all(sections and attributes) override
            </summary>
        </member>
        <member name="P:NFX.Environment.NodeOverrideRules.OverrideValue_Replace">
            <summary>
            Provides value for replace override - when overriding section replaces base completely
            </summary>
        </member>
        <member name="P:NFX.Environment.NodeOverrideRules.OverrideValue_Stop">
            <summary>
            Provides value for stop override - so no section can modify anything in this one
            </summary>
        </member>
        <member name="P:NFX.Environment.NodeOverrideRules.OverrideValue_Fail">
            <summary>
            Provides value for fail override - an exception is thrown when a child tries to override this section
            </summary>
        </member>
        <member name="P:NFX.Environment.NodeOverrideRules.SectionMatchAttrName">
            <summary>
            Provides attribute name for matching of multiple sections with the same name, i.e. a logger may have many 'destinations' 
            subnodes each with different 'name' attribute
            </summary>
        </member>
        <member name="P:NFX.Environment.NodeOverrideRules.SectionClearName">
            <summary>
            Provides a name for clear section - when present it deletes all existing subsections
            </summary>
        </member>
        <member name="T:NFX.Environment.ScriptRunner">
            <summary>
            Executes configuration scripts which are embedded in configuration
            </summary>
        </member>
        <member name="M:NFX.Environment.ScriptRunner.Execute(NFX.Environment.Configuration,NFX.Environment.Configuration)">
            <summary>
            Runs script on the configuration
            </summary>
        </member>
        <member name="P:NFX.Environment.ScriptRunner.KeywordBLOCK">
            <summary>
            Gets/sets BLOCK keyword - used for unconditional script evaluation block
            </summary>
        </member>
        <member name="P:NFX.Environment.ScriptRunner.KeywordIF">
            <summary>
            Gets/sets IF keyword - used for conditional block
            </summary>
        </member>
        <member name="P:NFX.Environment.ScriptRunner.KeywordELSE">
            <summary>
            Gets/sets ELSE keyword - used for IF-complementary conditional block
            </summary>
        </member>
        <member name="P:NFX.Environment.ScriptRunner.KeywordLOOP">
            <summary>
            Gets/sets LOOP keyword - used for repetition block
            </summary>
        </member>
        <member name="P:NFX.Environment.ScriptRunner.KeywordSET">
            <summary>
            Gets/sets SET keyword - used for variable assignment statement
            </summary>
        </member>
        <member name="P:NFX.Environment.ScriptRunner.KeywordCALL">
            <summary>
            Gets/sets CALL keyword - used for sub-routine invocation
            </summary>
        </member>
        <member name="P:NFX.Environment.ScriptRunner.AttributeScriptOnly">
            <summary>
            Gets/sets attribute name that indicates that marked entity should not be brough over into script output target
            </summary>
        </member>
        <member name="P:NFX.Environment.ScriptRunner.TimeoutMs">
            <summary>
            Gets/sets script execution timeout
            </summary>
        </member>
        <member name="T:NFX.Glue.GluedAttribute">
            <summary>
            Decorates interfaces that represent glued contract points
            </summary>
        </member>
        <member name="T:NFX.Glue.ArgsMarshallingAttribute">
            <summary>
            Decorates methods stipulating type of RequestMsg-derivative used for method call arguments marshalling
            </summary>
        </member>
        <member name="F:NFX.Glue.ArgsMarshallingAttribute.RequestMsgType">
            <summary>
            Thr type of RequestMsg-derivative used to marshall the request arguments
            </summary>
        </member>
        <member name="T:NFX.Glue.OneWayAttribute">
            <summary>
            Decorates methods that do not generate response message after execution.
            They must return void and if exception occurs it is not reported to the caller
            </summary>
        </member>
        <member name="T:NFX.Glue.ConstructorAttribute">
            <summary>
            Decorates methods that initialize instance of the server class and retain class instance
             in the server runtime
            </summary>
        </member>
        <member name="T:NFX.Glue.DestructorAttribute">
            <summary>
            Decorates methods that finalize instance of the server class and release class instance
             in the server runtime
            </summary>
        </member>
        <member name="T:NFX.Glue.ServerInstanceMode">
            <summary>
            Denotes server instance modes - how server instances relate to calls
            </summary>
        </member>
        <member name="F:NFX.Glue.ServerInstanceMode.Singleton">
            <summary>
            Indicates that the same single process-wide instance will serve all request for particular contract.
            The server MUST be thread-safe
            </summary>
        </member>
        <member name="F:NFX.Glue.ServerInstanceMode.PerCall">
            <summary>
            Indicates that every request for a particular contract will create an instance which will live until the method exits
            </summary>
        </member>
        <member name="F:NFX.Glue.ServerInstanceMode.Stateful">
            <summary>
            Indicates that the instance is stateful and will live between a call to 
             [Constructor]-decorated method and [Destructor]-decorated method, or until timeout interval has passed.
            The implementation may or may not be thread-safe, if it is, then [ThreadSafe] attribute may be used to avoid instance locking
            </summary>
        </member>
        <member name="F:NFX.Glue.ServerInstanceMode.AutoConstructedStateful">
            <summary>
            Indicates that the instance is stateful and will live between a call to 
             either [Constructor]-decorated method or first call to any method, and [Destructor]-decorated method or until timeout interval has passed.
            The implementation may or may not be thread-safe, if it is then [ThreadSafe] attribute may be used to avoid instance locking.
            This mode is simiar to 'Stateful' but does not require the caller to explicitly call the [Constructor]-decorated method first
            </summary>
        </member>
        <member name="T:NFX.Glue.LifeCycleAttribute">
            <summary>
            Specifies the instance mode and timeout values for server classes that implement the decorated contract.
            If server class does not support state then timeout is ignored
            </summary>
        </member>
        <member name="T:NFX.Glue.ThreadSafeAttribute">
            <summary>
            Indicates that server instance should not be lock()-ed by Glue handler because it is implemented in a thread-safe way.
            This attribute has no effect for Glue servers that are not [LifeCycle(Stateful)], because they are never locked.
            Singleton servers must be thread-safe by definition so this attribute is not needed for Singleton servers.
            If the server is implemented in a thread-safe way, then addition of this attribute may give 15-30% performance boost
             from Glue runtime when many parallel requests are trying to work with the same instance, however this benefit
             may be nullified by inefficient user locking code within server implementation. Leaving this attribute out is safer
            </summary>
        </member>
        <member name="T:NFX.Glue.AuthenticationSupportAttribute">
            <summary>
            Indicates that contract supports authentication using AuthenticationHeader. 
            When header is passed then Glue server will use its data to set user context through Application.SecurityManager.
            If this attribute not set then Glue runtime will ignore AuthenticationHeader
            </summary>
        </member>
        <member name="T:NFX.Glue.IMsgInspector">
            <summary>
            Denotes an entity that can inspect messages
            </summary>
        </member>
        <member name="T:NFX.Glue.IClientMsgInspector">
            <summary>
            Inspects messages on the client side. ClientInspectors may be registered on ClientEndPoint, Binding or Glue levels
            </summary>
        </member>
        <member name="M:NFX.Glue.IClientMsgInspector.ClientDispatchCall(NFX.Glue.ClientEndPoint,NFX.Glue.Protocol.RequestMsg)">
            <summary>
            Intercepts client call during dispatch and optionaly allows to change the RequestMsg
            </summary>
        </member>
        <member name="M:NFX.Glue.IClientMsgInspector.ClientDeliverResponse(NFX.Glue.CallSlot,NFX.Glue.Protocol.ResponseMsg)">
            <summary>
            Intercepts server response message before it arrives into CallSlot and optionaly allows to change it
            </summary>
        </member>
        <member name="T:NFX.Glue.IServerMsgInspector">
            <summary>
            Inspects messages on the server side. ServerInspectors may be registered on ServerEndPoint, Binding or Glue levels
            </summary>
        </member>
        <member name="M:NFX.Glue.IServerMsgInspector.ServerDispatchRequest(NFX.Glue.ServerEndPoint,NFX.Glue.Protocol.RequestMsg)">
            <summary>
            Intercepts RequestMsg that arrived from particular ServerEndPoint and optionaly allows to change it
            </summary>
        </member>
        <member name="M:NFX.Glue.IServerMsgInspector.ServerReturnResponse(NFX.Glue.ServerEndPoint,NFX.Glue.Protocol.RequestMsg,NFX.Glue.Protocol.ResponseMsg)">
            <summary>
            Intercepts ResponseMsg generated by server before it is sent to client and optionaly allows to change it
            </summary>
        </member>
        <member name="T:NFX.Glue.MsgInspectorConfigurator">
            <summary>
            Provides general configuration reading logic for message inspectors
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.INetInstrument">
            <summary>
            Network operations (i.e. sockets)
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.IIOInstrumentClass">
            <summary>
            IO-related operations
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.IErrorInstrument">
            <summary>
            Data of this class indicates a definite abnormality, however the system is going to continue functioning
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.IProblemClass">
            <summary>
            A class of problem that decorate instrument represents
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.Consts">
            <summary>
            Constants common to Native/Socket-based family of technologies
            </summary>
        </member>
        <member name="F:NFX.Glue.Native.Consts.PACKET_DELIMITER_LENGTH">
            <summary>
            Size of the packet delimiting field
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.InProcBinding">
            <summary>
            Provides synchronous communication pattern based on in-memory message exchange without serialization.
            This binding is usable for interconnection between NFX-native components in the same app domain
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.InProcBinding.OperationFlow">
            <summary>
            InProc binding is synchronous by definition
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.InProcClientTransport">
            <summary>
            Provides client-side functionality for synchronous communication pattern based on 
             in-memory message exchange without serialization
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.InProcServerTransport">
            <summary>
            Provides server-side functionality for synchronous communication pattern based on 
             in-memory message exchange without serialization
            </summary>
        </member>
        <member name="T:NFX.Glue.Protocol.AuthenticationHeader">
            <summary>
            Marshalls user authentication information 
            </summary>
        </member>
        <member name="T:NFX.Glue.Protocol.Header">
            <summary>
            Represents a header base - custom headers must inherit from this class
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.AuthenticationHeader.#ctor(NFX.Security.Credentials)">
            <summary>
            Inits header with Credentials instance. 
            Note: passing IDPasswordCredentials over public wire is not a good practice,
            pass AuthenticationToken instead 
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.AuthenticationHeader.Token">
            <summary>
            Returns AuthenticationToken
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.AuthenticationHeader.Credentials">
            <summary>
            Returns Credentials
            </summary>
        </member>
        <member name="T:NFX.Glue.ServerCallContext">
            <summary>
            Provides access to server call context. Use to access Headers
            </summary>
        </member>
        <member name="M:NFX.Glue.ServerCallContext.__SetThreadLevelContext(NFX.Glue.Protocol.RequestMsg)">
            <summary>
            Internal framework-only method to bind thread-level context
            </summary>
        </member>
        <member name="M:NFX.Glue.ServerCallContext.__ResetThreadLevelContext">
            <summary>
            Internal framework-only method to clear thread-level context
            </summary>
        </member>
        <member name="P:NFX.Glue.ServerCallContext.Request">
            <summary>
            Returns RequestMsg which is being processed. Access incoming headers through Request.Headers
            </summary>
        </member>
        <member name="P:NFX.Glue.ServerCallContext.ResponseHeaders">
            <summary>
            Returns Headers instance that will be appended to response
            </summary>
        </member>
        <member name="T:NFX.Glue.ServerEndPoint">
            <summary>
            Represents a server endpoint that accepts client requests. This is a sealed class
            </summary>
        </member>
        <member name="F:NFX.Glue.ServerEndPoint.m_ContractImplementers">
            <summary>
            INTERNAL! Maps ContractType -> ServerImplementing class. This is a cache used not to recompute everything on every call 
            </summary>
        </member>
        <member name="M:NFX.Glue.ServerEndPoint.Open">
            <summary>
            Opens endpoint by allocating transports (if necessary).
            ServerEndpoint can be Close() or Dispose() after it was open
            </summary>
        </member>
        <member name="P:NFX.Glue.ServerEndPoint.Name">
            <summary>
            Returns name of the endpoint. Named endpoints must be unique in the context, if name was not supplied in .ctor then it is auto-generated
            </summary>
        </member>
        <member name="P:NFX.Glue.ServerEndPoint.Transport">
            <summary>
            Returns server transport that services this endpoint
            </summary>
        </member>
        <member name="P:NFX.Glue.ServerEndPoint.MsgInspectors">
            <summary>
            Returns server message inspectors for this instance
            </summary>
        </member>
        <member name="P:NFX.Glue.ServerEndPoint.ContractServers">
            <summary>
            Returns types that implement/serve contracts that this endpoint accepts
            </summary>
        </member>
        <member name="P:NFX.Glue.ServerEndPoint.IsOpen">
            <summary>
            Indicates whether endpoint is open and is accepting incoming requests
            </summary>
        </member>
        <member name="T:NFX.Registry`1">
            <summary>
            Represents a thread-safe registry of T. This class is efficient for concurrent read access and is not designed for cases when frequent modifications happen.
            It is ideal for lookup of named instances (such as components) that have much longer time span than components that look them up.
            Registry performs lock-free lookup which speeds-up many concurrent operations that need to map names into objects.
            The enumeration over registry makes a snapshot of its data, hence a registry may be modified by other threads while being enumerated.
            </summary>
        </member>
        <member name="T:NFX.IRegistry`1">
            <summary>
            Provides read-only named object lookup capabilities
            </summary>
        </member>
        <member name="M:NFX.IRegistry`1.ContainsName(System.String)">
            <summary>
            Returns true if when this registry contains the specified name
            </summary>
        </member>
        <member name="P:NFX.IRegistry`1.Item(System.String)">
            <summary>
            Returns item by name or default item (such as null) if the named instance could not be found
            </summary>
        </member>
        <member name="P:NFX.IRegistry`1.Count">
            <summary>
            Returns the count of items registered in this instance
            </summary>
        </member>
        <member name="M:NFX.Registry`1.Register(`0)">
            <summary>
            Registers item and returns true if it was registered, false if this named instance already existed in the list 
            </summary>
        </member>
        <member name="M:NFX.Registry`1.RegisterOrReplace(`0)">
            <summary>
            Registers item and returns true if it was registered, false if this named instance already existed and was replaced 
            </summary>
        </member>
        <member name="M:NFX.Registry`1.Unregister(`0)">
            <summary>
            Unregisters item and returns true if it was unregistered, false if it did not exist
            </summary>
        </member>
        <member name="M:NFX.Registry`1.Unregister(System.String)">
            <summary>
            Unregisters item by name and returns true if it was unregistered, false if it did not exist
            </summary>
        </member>
        <member name="M:NFX.Registry`1.Clear">
            <summary>
            Deletes all items from registry
            </summary>
        </member>
        <member name="M:NFX.Registry`1.GetOrRegister``1(System.String,System.Func{``0,`0},``0)">
            <summary>
            Tries to find an item by name, and returns it if it is found, otherwise calls a factory function supplying context value and registers the obtained
             new item. The first lookup is performed in a lock-free way and if an item is found then it is immediately returned.
             The second check and factory call operation is performed atomically under the lock to ensure consistency
            </summary>
        </member>
        <member name="M:NFX.Registry`1.GetOrRegister``1(System.String,System.Func{``0,`0},``0,System.Boolean@)">
            <summary>
            Tries to find an item by name, and returns it if it is found, otherwise calls a factory function supplying context value and registers the obtained
             new item. The first lookup is performed in a lock-free way and if an item is found then it is immediately returned.
             The second check and factory call operation is performed atomically under the lock to ensure consistency
            </summary>
        </member>
        <member name="P:NFX.Registry`1.Item(System.String)">
            <summary>
            Returns a value by name or null if not found
            </summary>
        </member>
        <member name="P:NFX.Registry`1.Count">
            <summary>
            Returns the number of entries in the registry
            </summary>
        </member>
        <member name="T:NFX.Glue.Implementation.Calls">
            <summary>
            Provides thread-safe CallSlot registry where items can be gotten and removed by request ID guid
            </summary>
        </member>
        <member name="M:NFX.Glue.Implementation.Calls.Put(NFX.Glue.CallSlot)">
            <summary>
            Tries to pur CallSlot instance in the internal list if instance with same ID is not already in the list
            </summary>
        </member>
        <member name="M:NFX.Glue.Implementation.Calls.TryGetAndRemove(NFX.FID)">
            <summary>
            Tries to get, return and remove CallSlot instance by its RequestID from the list.
            Returns null if CallSlot with such an id does not exist and nothing was removed
            </summary>
        </member>
        <member name="M:NFX.Glue.Implementation.Calls.PurgeTimedOutSlots">
            <summary>
            Deletes CallSlot entries that have already timed-out. Returns count of slots that got removed.
            This method is thread-safe but may take some time as it has to visit all buckets.
            Should be called by Glue manager not frequently (i.e. every few minutes)
            </summary>
        </member>
        <member name="T:NFX.Glue.Implementation.ServerHandler">
            <summary>
            Executes server work - handles requests synchronously or asynchronously.
            </summary>
        </member>
        <member name="F:NFX.Glue.Implementation.ServerHandler.GLUE_CTOR_SIGNATURE">
            <summary>
            Specifies special signature for glue-specific constructors.
            If a server implementer class implements a public ctor with this signature then it will be called
            instead of default .ctor.
            This is useful when server class needs to distinguish Glue allocations from de-serializations and others
            </summary>
        </member>
        <member name="M:NFX.Glue.Implementation.ServerHandler.HandleRequestAsynchronously(NFX.Glue.Protocol.RequestMsg)">
            <summary>
            Handles request in the context of ServerHandler thread, replying back to result queue
            </summary>
        </member>
        <member name="M:NFX.Glue.Implementation.ServerHandler.HandleRequestSynchronously(NFX.Glue.Protocol.RequestMsg)">
            <summary>
            Handles request synchronously in the context of the calling thread. Returns NULL for one-way calls
            </summary>
        </member>
        <member name="M:NFX.Glue.Implementation.ServerHandler.HandleRequestFailure(NFX.FID,System.Boolean,System.Exception,System.Object)">
            <summary>
            Handles request synchronously in the context of the calling thread. Returns NULL for one-way calls
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.SyncBinding">
            <summary>
            Provides synchronous communication pattern based on TCP blocking sockets and Slim serializer
            for maximum serialization performance and lowest latency.
            This binding is usable for interconnection between NFX-native components on LANs (i.e. server clusters)
            in scenarios when low latency is more important than total call invocation throughput
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.SyncBinding.OperationFlow">
            <summary>
            Sync binding is synchronous by definition
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.SyncBinding.MaxMsgSize">
            <summary>
            Imposes a limit on maximum message size in bytes
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.SyncClientTransport">
            <summary>
            Provides client-side functionality for synchronous communication pattern based on TCP blocking sockets and Slim serializer
            for maximum serialization performance and lowest latency.
            The SyncBinding is usable for interconnection between NFX-native components on LANs (i.e. server clusters) in scenarios when
             low latency is more important than total call invocation throughput
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.SyncServerTransport">
            <summary>
            Provides server-side functionality for synchronous communication pattern based on TCP blocking sockets and Slim serializer
            for maximum serialization performance and lowest latency.
            The SyncBinding is usable for interconnection between NFX-native components on LANs (i.e. server clusters) in scenarios when
             low latency is more important than total call invocation throughput.
            SyncServerTransport uses dedicated thread for request processing and is not scalable beyond a few hundred connections by design,
             however it provides low latency benefit
            </summary>
        </member>
        <member name="M:NFX.Glue.Native.SyncServerTransport.#ctor(NFX.Glue.Native.SyncBinding,NFX.Glue.ServerEndPoint,System.Net.IPAddress,System.Int32)">
            <summary>
            Allocates a listener transport
            </summary>
        </member>
        <member name="T:NFX.Glue.Protocol.CallOptions">
            <summary>
            Specifies additional options for call like timeouts
            </summary>
        </member>
        <member name="T:NFX.Glue.Protocol.HashUtils">
            <summary>
            Hash helpers used by Glue protocol for type resolution
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.HashUtils.StringIDHash(System.String)">
            <summary>
            Converts string identifier into uint64 stable hash that does not depend on a platform.
            This functions optimized for hashing identifiers/type names 
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.HashUtils.TypeHash(System.Type)">
            <summary>
            Returns stable ulong hash for a type that does not depend on a platform
            </summary>
        </member>
        <member name="T:NFX.Glue.Protocol.TypeSpec">
            <summary>
            Type specification for marshalling contract types between glued peers
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.TypeSpec.GetSpecifiedType">
            <summary>
            Returns the type or throws if it can't be found 
            </summary>
            <returns>The type or throws exception if actual type could not be gotten</returns>
        </member>
        <member name="T:NFX.Glue.Protocol.MethodSpec">
            <summary>
            Method specification for marshalling method information between glued peers
            </summary>
        </member>
        <member name="T:NFX.Glue.CallReactor">
            <summary>
            Facilititates execution of asynchronous client calls and their corresponding callback functions.
            This class introduces callback execution latency and is handy for cases where eventual event flow need to execute regardless of timing.
            The latency depends on other callback implementation as the reactor services all calls from a single thread 
            </summary>
        </member>
        <member name="M:NFX.Glue.CallReactor.Wait">
            <summary>
            Blocks until all calls managed by this reactor instance have ended
            </summary>
        </member>
        <member name="M:NFX.Glue.CallReactor.WaitAll(System.Collections.Generic.IEnumerable{NFX.Glue.CallReactor})">
            <summary>
            Waits for all reactors to finish
            </summary>
        </member>
        <member name="P:NFX.Glue.CallReactor.Calls">
            <summary>
            Enumerates all calls that this reactor instance services
            </summary>
        </member>
        <member name="P:NFX.Glue.CallReactor.Context">
            <summary>
            Gets/sets reactor-wide context which is originally supplied in .ctor or null
            </summary>
        </member>
        <member name="P:NFX.Glue.CallReactor.Finished">
            <summary>
            Retunrs true when all calls have finished processing
            </summary>
        </member>
        <member name="P:NFX.Glue.CallReactor.Exception">
            <summary>
            Returns an exception surfaced during reactor operation or null
            </summary>
        </member>
        <member name="T:NFX.Glue.Call">
            <summary>
            Describes a flow of events originating from a Glue client call
            </summary>
        </member>
        <member name="P:NFX.Glue.Call.Reactor">
            <summary>
            Returns the reactor that services this call
            </summary>
        </member>
        <member name="P:NFX.Glue.Call.CallSlot">
            <summary>
            Returns CallSlot that represents this call
            </summary>
        </member>
        <member name="P:NFX.Glue.Call.Context">
            <summary>
            Retruns call-dependent context object if one was supplied in call .ctor, or null
            </summary>
        </member>
        <member name="P:NFX.Glue.Call.Ended">
            <summary>
            Returns true when call has ended with all attached events/callbacks
            </summary>
        </member>
        <member name="P:NFX.Glue.Call.CallbackException">
            <summary>
            Returns exception that was thrown from callback or null if no exception happened
            </summary>
        </member>
        <member name="T:NFX.Glue.LogSrc">
            <summary>
            Logging sources - client, server, any
            </summary>
        </member>
        <member name="T:NFX.Glue.CallStatus">
            <summary>
            Stipulates codes returned for contract calls
            </summary>
        </member>
        <member name="F:NFX.Glue.CallStatus.Dispatched">
            <summary>
            Indicates that call was sucessfully queued/dispatched for processing by remote server
            </summary>
        </member>
        <member name="F:NFX.Glue.CallStatus.DispatchError">
            <summary>
            Indicates that operation failed locally because the communication stack is overloaded or some other internal error occured
            </summary>
        </member>
        <member name="F:NFX.Glue.CallStatus.Timeout">
            <summary>
            Indicates that operation timed out before it could be completed
            </summary>
        </member>
        <member name="F:NFX.Glue.CallStatus.ResponseOK">
            <summary>
            Indicates that response came with payload that does not contain error
            </summary>
        </member>
        <member name="F:NFX.Glue.CallStatus.ResponseError">
            <summary>
            Remote server returned response with exception
            </summary>
        </member>
        <member name="T:NFX.Glue.OperationFlow">
            <summary>
            Stipulates operation flow kind - sync/async
            </summary>
        </member>
        <member name="F:NFX.Glue.OperationFlow.Synchronous">
            <summary>
            Every operation blocks until it is completed or times out
            </summary>
        </member>
        <member name="F:NFX.Glue.OperationFlow.Asynchronous">
            <summary>
            Operations do not block and use reactor to correlate request/responses
            </summary>
        </member>
        <member name="T:NFX.Glue.DumpDetail">
            <summary>
            Message/data dumping detail
            </summary>
        </member>
        <member name="F:NFX.Glue.DumpDetail.None">
            <summary>
            No dumping
            </summary>
        </member>
        <member name="F:NFX.Glue.DumpDetail.Message">
            <summary>
            Message-level dumping
            </summary>
        </member>
        <member name="T:NFX.Glue.Implementation.GlueService">
            <summary>
            Provides default implementation for IGlue. This is the root context for all other glue objects
            </summary>
        </member>
        <member name="T:NFX.Glue.IGlue">
            <summary>
            Represents a contract for Glue - a technology that provides asynchronous distributed component interconnection 
            </summary>
        </member>
        <member name="M:NFX.Glue.IGlue.GetNodeBinding(NFX.Glue.Node)">
            <summary>
            Retrieves a binding for node and throws if such binding is not known
            </summary>
        </member>
        <member name="M:NFX.Glue.IGlue.GetNodeBinding(System.String)">
            <summary>
            Retrieves a binding for node and throws if such binding is not known
            </summary>
        </member>
        <member name="P:NFX.Glue.IGlue.Providers">
            <summary>
            Performs provider lookup by name
            </summary>
        </member>
        <member name="P:NFX.Glue.IGlue.Bindings">
            <summary>
            Performs binding lookup by name
            </summary>
        </member>
        <member name="P:NFX.Glue.IGlue.Servers">
            <summary>
            Performs ServerEndPoint lookup by name
            </summary>
        </member>
        <member name="P:NFX.Glue.IGlue.ClientMsgInspectors">
            <summary>
            Registry of inspectors that deal with client-side messages
            </summary>
        </member>
        <member name="P:NFX.Glue.IGlue.ServerMsgInspectors">
            <summary>
            Registry of inspectors that deal with server-side messages
            </summary>
        </member>
        <member name="P:NFX.Glue.IGlue.DefaultDispatchTimeoutMs">
            <summary>
            Specifies default ms timout for call dispatch only
            </summary>
        </member>
        <member name="P:NFX.Glue.IGlue.DefaultTimeoutMs">
            <summary>
            Specified default ms timeout for the calls
            </summary>
        </member>
        <member name="P:NFX.Glue.IGlue.ClientLogLevel">
            <summary>
            Determines how much information should be logged about client-side operations
            </summary>
        </member>
        <member name="P:NFX.Glue.IGlue.ServerLogLevel">
            <summary>
            Determines how much information should be logged about server-side operations
            </summary>
        </member>
        <member name="P:NFX.Glue.IGlue.ServerInstanceLockTimeoutMs">
            <summary>
            Specifies ms timout for non-threadsafe server instance lock
            </summary>
        </member>
        <member name="M:NFX.Glue.IGlueImplementation.ServerDispatchRequest(NFX.Glue.Protocol.RequestMsg)">
            <summary>
            Asynchronously dispatch client request
            </summary>
        </member>
        <member name="M:NFX.Glue.IGlueImplementation.ServerHandleRequest(NFX.Glue.Protocol.RequestMsg)">
            <summary>
            Handle client request synchronously
            </summary>
        </member>
        <member name="M:NFX.Glue.IGlueImplementation.ServerHandleRequestFailure(NFX.FID,System.Boolean,System.Exception,System.Object)">
            <summary>
            Handle failure of client request synchronously
            </summary>
        </member>
        <member name="M:NFX.Glue.Implementation.GlueService.ExternalParametersForGroups(System.String[])">
            <summary>
            Returns named parameters that can be used to control this component
            </summary>
        </member>
        <member name="M:NFX.Glue.Implementation.GlueService.ExternalGetParameter(System.String,System.Object@,System.String[])">
            <summary>
            Gets external parameter value returning true if parameter was found
            </summary>
        </member>
        <member name="M:NFX.Glue.Implementation.GlueService.ExternalSetParameter(System.String,System.Object,System.String[])">
            <summary>
            Sets external parameter value returning true if parameter was found and set
            </summary>
        </member>
        <member name="P:NFX.Glue.Implementation.GlueService.InstrumentationEnabled">
            <summary>
            Implements IInstrumentable
            </summary>
        </member>
        <member name="P:NFX.Glue.Implementation.GlueService.ExternalParameters">
            <summary>
            Returns named parameters that can be used to control this component
            </summary>
        </member>
        <member name="P:NFX.Glue.Implementation.GlueService.ClientMsgInspectors">
            <summary>
            Returns client message inspectors for this instance
            </summary>
        </member>
        <member name="P:NFX.Glue.Implementation.GlueService.ServerMsgInspectors">
            <summary>
            Returns server message inspectors for this instance
            </summary>
        </member>
        <member name="T:NFX.Glue.Provider">
            <summary>
            Represents a base type for providers - providers are facades for some
            low-level implementation that transports use, for example ZeroMQ.
            </summary>
        </member>
        <member name="T:NFX.Glue.Providers">
            <summary>
            A registry of Provider-derived instances
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.InstrumentViewGroup">
            <summary>
            Denotes interface types that participate in instrumentation data grouping.
            Records that implement several classification interfaces which are decorated by this attribute
            get listed in each decorated interface/group
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.IWarningInstrument">
            <summary>
            Data of this class indicates some abnormality in operation, i.e. "LowDisk"
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.ICatastropyInstrument">
            <summary>
            Data of this class indicates an abnormality that will most likely lead to system inability to continue functioning as expected
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.IDiskInstrument">
            <summary>
            Disk operations (i.e. % drive free)
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.ILockingInstrument">
            <summary>
            Locking/coordination-related operations
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.IWebInstrument">
            <summary>
            Web-related operations
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.ISecurityInstrument">
            <summary>
            Security-related operations
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.IGDIDInstrument">
            <summary>
            GDID-related operations
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.ISchedulingInstrument">
            <summary>
            Timer/scheduling-related operations
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.ISocialLogic">
            <summary>
            A class of operations related to social operations / business logic
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadLine(System.String)">
            <summary>
            Reads first line from the string
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.CopyStream(System.IO.Stream,System.IO.Stream)">
            <summary>
            Copies one stream into another using temp buffer
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadBEInt32(System.Byte[])">
            <summary>
            Reads an integer encoded as big endian from buffer at index 0
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadBEUInt32(System.Byte[])">
            <summary>
            Reads an unsigned integer encoded as big endian from buffer at index 0
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadBEInt32(System.Byte[],System.Int64@)">
            <summary>
            Reads an integer encoded as big endian from buffer at the specified index
            and increments the idx by the number of bytes read
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadBEInt32(System.Byte[],System.Int32@)">
            <summary>
            Reads an integer encoded as big endian from buffer at the specified index
            and increments the idx by the number of bytes read
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadBEUInt32(System.Byte[],System.Int32@)">
            <summary>
            Reads an unsigned integer encoded as big endian from buffer at the specified index
            and increments the idx by the number of bytes read
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadBEUInt32(System.Byte[],System.Int64@)">
            <summary>
            Reads an unsigned integer encoded as big endian from buffer at the specified index
            and increments the idx by the number of bytes read
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadBEUInt64(System.Byte[],System.Int32@)">
            <summary>
            Reads an integer encoded as big endian from buffer at the specified index
            and increments the idx by the number of bytes read
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadBEUInt64(System.Byte[],System.Int32)">
            <summary>
            Reads an integer encoded as big endian from buffer at the specified index
            and increments the idx by the number of bytes read
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadBEShort(System.Byte[],System.Int32@)">
            <summary>
            Reads a short encoded as big endian from buffer at the specified index
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadBEShort(System.IO.Stream)">
            <summary>
            Reads a short encoded as big endian from stream
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadBEUShort(System.IO.Stream)">
            <summary>
            Reads an ushort encoded as big endian from stream
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadBEInt32(System.IO.Stream)">
            <summary>
            Reads an integer encoded as big endian from buffer at the specified index
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadBEUInt64(System.IO.Stream)">
            <summary>
            Reads an integer encoded as big endian from buffer at the specified index
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.WriteBEInt32(System.Byte[],System.Int32)">
            <summary>
            Writes an integer encoded as big endian to buffer at index 0
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.WriteBEInt32(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes an integer encoded as big endian to buffer at the specified index
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.WriteBEUInt32(System.Byte[],System.UInt32)">
            <summary>
            Writes an unsigned integer encoded as big endian to buffer at index 0
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.WriteBEUInt32(System.Byte[],System.Int32,System.UInt32)">
            <summary>
            Writes an unsigned integer encoded as big endian to buffer at the specified index
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.WriteBEUInt64(System.Byte[],System.UInt64)">
            <summary>
            Writes an unsigned long integer encoded as big endian to buffer at the beginning
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.WriteBEUInt64(System.Byte[],System.Int32,System.UInt64)">
            <summary>
            Writes an unsigned long integer encoded as big endian to buffer at the specified index
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.WriteBEShort(System.Byte[],System.Int32,System.Int16)">
            <summary>
            Writes a short encoded as big endian to buffer at the specified index
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.WriteBEShort(System.IO.Stream,System.Int16)">
            <summary>
            Writes a short encoded as big endian to the given stream
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.WriteBEUShort(System.IO.Stream,System.UInt16)">
            <summary>
            Writes an ushort encoded as big endian to the given stream
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.WriteBEInt32(System.IO.Stream,System.Int32)">
            <summary>
            Writes an integer encoded as big endian to the given stream
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.WriteBEUInt64(System.IO.Stream,System.UInt64)">
            <summary>
            Writes an unsigned long integer encoded as big endian to the given stream
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.EnsureFileEventuallyDeleted(System.String)">
            <summary>
            Deleted file if it exists - does not block until file is deleted, the behavior is up to the OS
            </summary>
            <param name="fileName">Full file name with path</param>
        </member>
        <member name="M:NFX.IOMiscUtils.EnsureDirectoryDeleted(System.String,System.Int32)">
            <summary>
            Tries to delete the specified directory if it exists BLOCKING for up to the specified interval until directory is PHYSICALLY deleted.
            Returns true when directory either did not exist in the first place or was successfully deleted (with confirmation).
            Returns false when directory could not be confirmed to be deleted within the specified timeout, this does not mean
             that the OS will not delete the directory later, so calling this function in a loop is expected.
             NOTE: Directory.Delete() does not guarantee that directory is no longer on disk upon its return
            </summary>
            <param name="dirName">Directory to delete</param>
            <param name="timeoutMs">Timeout in ms</param>
        </member>
        <member name="M:NFX.IOMiscUtils.EnsureAccessibleDirectory(System.String)">
            <summary>
            Creates directory and immediately grants it accessibility rules for everyone if it does not exists,
             or returns the existing directory
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.MemBufferEquals(System.Byte[],System.Byte[])">
            <summary>
            Returns true if both buffers contain the same number of the same bytes.
            The implementation uses quad-word comparison as much as possible for speed.
            Requires UNSAFE switch
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.NormalizeCenteredImage(System.Drawing.Image,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Scales source image so it fits in the desired image size preserving aspect ratio. 
            This function is usable for profile picture size/aspect normalization
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.CodeAnalysisException">
            <summary>
            Base exception thrown by the framework
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.CodeProcessorException">
            <summary>
            Thrown by code processors such as lexers, parsers ,  symantic analyzers, compilers etc...
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.JSON.JSONLexer">
            <summary>
            Performs lexical analysis on source supplied in JSON syntax.
            This class supports lazy analysis that happens gradually as result tokens are consumed through IEnumerable interface.
            NOTE: Although called JSON, this is really a JSON superset implementation that includes extra features:
             comments, directives, verbatim strings(start with $), ' or " string escapes, unquoted object key names 
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.IProjectItem">
            <summary>
            Represents an item that is a part of some project, i.e. a CS source file in CSharp project
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.JSON.JSONLanguage">
            <summary>
            Represents JSON language
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.JSON.JSONToken">
            <summary>
            Represents a token of JSON language
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.JSON.JSONTokenType">
            <summary>
            Denotes JSON token types.
            NOTE: Although called JSON, this is really a JSON superset implementation that includes extra features:
             comments, directives, verbatim strings(start with $), ' or " string escapes, unquoted object key names 
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.LanguageFamily">
            <summary>
            Defines various languages
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.UnspecifiedLanguage">
            <summary>
            Represents Unspecified unknown language
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Message">
            <summary>
            Represents a message emitted from code-analyzing entities such as lexers, parsers, semantic analyzers and compilers.
            Messages have severity type like warning, info or error etc.
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Message.IsInternal">
            <summary>
            Indicates whether this message is an internal message
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Message.IsInfo">
            <summary>
            Indicates whether this message is an info message
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Message.IsWarning">
            <summary>
            Indicates whether this message is a warning message
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Message.IsError">
            <summary>
            Indicates whether this message is an error message
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.ILanguageProcessorNotifications">
            <summary>
            Describes an entity capable of receiving messages as they are emitted by entities such as parsers and compilers
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.MessageList">
            <summary>
            Provides a list of messages, this class is not thread-safe
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.MessageList.Add(NFX.CodeAnalysis.Message)">
            <summary>
            Emits new message
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.MessageList.Internals">
            <summary>
            Enumerates all internal messages
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.MessageList.Infos">
            <summary>
            Enumerates all info messages
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.MessageList.Warnings">
            <summary>
            Enumerates all warning messages
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.MessageList.Errors">
            <summary>
            Enumerates all error messages
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.MessageType">
            <summary>
            Message type like: Info, Warning, Error
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Source.FileSource">
            <summary>
            Represents source code stored in a file
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Source.FileSource.#ctor(System.String)">
            <summary>
            Constructs file source infering source language from file extension
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Source.FileSource.#ctor(NFX.CodeAnalysis.Language,System.String)">
            <summary>
            Constructs file source with specified language ignoring file extension
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Source.FileSource.Name">
            <summary>
            Returns source's file name
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Source.FileNameList">
            <summary>
            Represents a list of file names
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Source.FileNameList.CheckAllNames">
            <summary>
            Checks that all files exist
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Source.SourceCodeRef">
            <summary>
            Represents a reference to the source code which may be named buffer or project source item (i.e. solution project item)
            </summary>
        </member>
        <member name="F:NFX.CodeAnalysis.Source.SourceCodeRef.SourceName">
            <summary>
            Provides name for the source, this property is set to ProjectItem.Name when IProjectItem is supplied in .ctor
            </summary>
        </member>
        <member name="F:NFX.CodeAnalysis.Source.SourceCodeRef.ProjectItem">
            <summary>
            References project source item, this property may be null
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Source.ListOfISourceText">
            <summary>
            Represents a list of strings used as source text 
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Source.SourcePosition">
            <summary>
            Represents position in source input
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Source.SourceVector">
            <summary>
            Represents a pointer to the named source code  and character position
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Source.StringSource">
            <summary>
            Provides source code from string
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Source.StringSource.Name">
            <summary>
            Provides a handy way to name an otherwise-anonymous string source code,
            This property is like a "file name" only data is kept in a string
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Source.StringSourceList">
            <summary>
            Represents a list of strings used as source text 
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.TokenKind">
            <summary>
            Provides language-agnostic token classification
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.TokenList`1">
            <summary>
            A list of tokens
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Tokenized`1">
            <summary>
            Provides read-only view over TokenList
            </summary>
        </member>
        <member name="T:NFX.Log.Destinations.DebugDestination">
            <summary>
            Provides a file storage destination implementation for debug and trace logging
            </summary>
        </member>
        <member name="T:NFX.Log.Destinations.TextFileDestination">
            <summary>
            Provides a file storage destination implementation
            </summary>
        </member>
        <member name="T:NFX.Log.Destinations.FileDestination">
            <summary>
            Provides a file storage destination implementation
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.FileDestination.#ctor(System.String)">
            <summary>
            Creates a new instance of destination
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.FileDestination.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new instance of destination
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.FileDestination.DoOnOpenStream">
            <summary>
            Called after output stream has been opened
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.FileDestination.DoOnCloseStream">
            <summary>
            Called just before output stream is closed
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.FileDestination.DoWriteMessage(NFX.Log.Message)">
            <summary>
            Called when message is to be written to stream
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.FileDestination.DoSend(NFX.Log.Message)">
            <summary>
            Warning: don't override this method in derived destinations, use
            DoFormatMessage() instead!
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.FileDestination.Filename">
            <summary>
            File path and name. It may include environment variables (e.g. ~home),
            and "$(~home)$(@::now fmt=yyyyMMdd utc=false)-$($name).log" to specify current time.
            "utc=Bool" argument to the now function of time controls if the now time in filename
            should be in UTC/local time
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.FileDestination.CreateDir">
            <summary>
            Indicates whether to create the directory to be written to if one doesn't exist
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.FileDestination.LogTimeFormat">
            <summary>
            Time format for log line entries
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.FileDestination.DefaultFileName">
            <summary>
            For backward compatibility
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.FileDestination.DefaultExtension">
            <summary>
            For backward compatibility
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.FileDestination.DefaultLogTimeFormat">
            <summary>
            For backward compatibility
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.TextFileDestination.#ctor(System.String)">
            <summary>
            Creates a new instance of destination
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.TextFileDestination.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new instance of destination
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.TextFileDestination.DoWriteMessage(NFX.Log.Message)">
            <summary>
            Warning: don't override this method in derived destinations, use
            DoFormatMessage() instead!
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.TextFileDestination.DoFormatMessage(NFX.Log.Message)">
            <summary>
            Called when message is to be written to stream
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.DebugDestination.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new instance of destination
            </summary>
        </member>
        <member name="T:NFX.Log.LogServiceBase">
            <summary>
            Based class for implementing test and non-test logging services.
            Destinations may fail and the message will be failed-over into another destination in the same logger 
             as specified by 'failover' attribute of destination. This attribute is also present on service level.
            Cascading failover is not supported (failover of failovers). Another consideration is that messages 
             get sent into destinations synchronously by internal thread so specifying too many destinations may
             limit overall LogService throughput. In complex scenarios consider using LogServiceDestination instead.
            </summary>
        </member>
        <member name="T:NFX.Log.ILogImplementation">
            <summary>
            Describes entity capable of being written log information to
            </summary>
        </member>
        <member name="T:NFX.Log.ILog">
            <summary>
            Describes entity capable of being written log information to
            </summary>
        </member>
        <member name="M:NFX.Log.LogServiceBase.#ctor">
            <summary>
            Creates a new logging service instance
            </summary>
        </member>
        <member name="M:NFX.Log.LogServiceBase.#ctor(NFX.ServiceModel.Service)">
            <summary>
            Creates a new logging service instance
            </summary>
        </member>
        <member name="M:NFX.Log.LogServiceBase.ExternalParametersForGroups(System.String[])">
            <summary>
            Returns named parameters that can be used to control this component
            </summary>
        </member>
        <member name="M:NFX.Log.LogServiceBase.Write(NFX.Log.MessageType,System.String,System.String,System.String)">
            <summary>
            Writes log message into log
            </summary>
        </member>
        <member name="M:NFX.Log.LogServiceBase.Write(NFX.Log.MessageType,System.String,System.Boolean,System.String,System.String)">
            <summary>
            Writes log message into log
            </summary>
        </member>
        <member name="M:NFX.Log.LogServiceBase.Write(NFX.Log.Message)">
            <summary>
            Writes log message into log
            </summary>
            <param name="msg">Message to write</param>
        </member>
        <member name="M:NFX.Log.LogServiceBase.Write(NFX.Log.Message,System.Boolean)">
            <summary>
            Writes log message into log
            </summary>
            <param name="msg">Message to write</param>
            <param name="urgent">Indicates that the logging service implementation must
            make an effort to write the message to its destinations urgently</param>
        </member>
        <member name="M:NFX.Log.LogServiceBase.RegisterDestination(NFX.Log.Destinations.Destination,System.Int32)">
            <summary>
            Adds a destination to this service active destinations. Negative index to append
            </summary>
        </member>
        <member name="M:NFX.Log.LogServiceBase.UnRegisterDestination(NFX.Log.Destinations.Destination)">
            <summary>
            Removes a destiantion from this service active destinations, returns true if destination was found and removed
            </summary>
        </member>
        <member name="M:NFX.Log.LogServiceBase.TimeChanged">
            <summary>
            Notifies log that time changed and log destinations should be notified. 
            Usually this causes log file close/open under different name
            </summary>
        </member>
        <member name="M:NFX.Log.LogServiceBase.ExternalGetParameter(System.String,System.Object@,System.String[])">
            <summary>
            Gets external parameter value returning true if parameter was found
            </summary>
        </member>
        <member name="M:NFX.Log.LogServiceBase.ExternalSetParameter(System.String,System.Object,System.String[])">
            <summary>
            Sets external parameter value returning true if parameter was found and set
            </summary>
        </member>
        <member name="M:NFX.Log.LogServiceBase.GetInstrumentationBuffer(System.Boolean)">
            <summary>
            Returns instrumentation buffer if instrumentation enabled
            </summary>
        </member>
        <member name="M:NFX.Log.LogServiceBase.DoWrite(NFX.Log.Message,System.Boolean)">
            <summary>
            Writes log message into log
            </summary>
            <param name="msg">Message to write</param>
            <param name="urgent">Indicates that the logging service implementation must
            make an effort to write the message to its destinations urgently</param>
        </member>
        <member name="M:NFX.Log.LogServiceBase.FailoverDestination(NFX.Log.Destinations.Destination,System.Exception,NFX.Log.Message)">
            <summary>
            When error=null => error cleared. When msg==null => exceptions surfaced from DoPulse()
            </summary>
        </member>
        <member name="P:NFX.Log.LogServiceBase.LastWarning">
            <summary>
            Latches last problematic msg
            </summary>
        </member>
        <member name="P:NFX.Log.LogServiceBase.LastError">
            <summary>
            Latches last problematic msg
            </summary>
        </member>
        <member name="P:NFX.Log.LogServiceBase.LastCatastrophy">
            <summary>
            Latches last problematic msg
            </summary>
        </member>
        <member name="P:NFX.Log.LogServiceBase.Destinations">
            <summary>
            Returns registered destinations. This call is thread safe
            </summary>
        </member>
        <member name="P:NFX.Log.LogServiceBase.InstrumentationEnabled">
            <summary>
            Implements IInstrumentable
            </summary>
        </member>
        <member name="P:NFX.Log.LogServiceBase.ExternalParameters">
            <summary>
            Returns named parameters that can be used to control this component
            </summary>
        </member>
        <member name="P:NFX.Log.LogServiceBase.DefaultFailover">
            <summary>
            Sets destination name used for failover on the service-level
            if particular failing destination did not specify its specific failover 
            </summary>
        </member>
        <member name="P:NFX.Log.LogServiceBase.FailoverErrorDestination">
            <summary>
            Returns a destination that threw last exception that happened durng failover. This kind of exceptions is never propagated and always handled
            </summary>
        </member>
        <member name="P:NFX.Log.LogServiceBase.FailoverError">
            <summary>
            Returns last exception that happened during failover. This kind of exceptions is never propagated and always handled
            </summary>
        </member>
        <member name="P:NFX.Log.LogServiceBase.Now">
            <summary>
            Returns localized log time
            </summary>
        </member>
        <member name="P:NFX.Log.LogServiceBase.DestinationsAreOptional">
            <summary>
            Indicates whether the service can operate without any destinations registered, i.e. some test loggers may not need
             any destinations to operate as they synchronously write to some buffer without any extra destinations
            </summary>
        </member>
        <member name="T:NFX.RegistryDictionary`1">
            <summary>
            Represents a dictionary of string-named objects. Name search is case-insensitive
            </summary>
        </member>
        <member name="T:NFX.OrderedRegistry`1">
            <summary>
            Represents a thread-safe registry of T which is ordered by Order property.
            This class is efficient for concurrent read access and is not designed for cases when frequent modifications happen.
            It is ideal for lookup of named instances that have much longer time span than components that look them up.
            Note: since registry does reading in a lock-free manner, it is possible to have an inconsistent read snapshot
             of ordered items which may capture items that have already/not yet been added to the registry
            </summary>
        </member>
        <member name="M:NFX.OrderedRegistry`1.Clear">
            <summary>
            Deletes all items from ordered registry
            </summary>
        </member>
        <member name="P:NFX.OrderedRegistry`1.OrderedValues">
            <summary>
            Returns items that registry contains ordered by their Order property.
            The returned sequence is pre-sorted during alteration of registry, so this property access is efficient.
            Note: since registry does reading in a lock-free manner, it is possible to have an inconsistent read snapshot
             of ordered items which may capture items that have already/not yet been added to the registry
            </summary>
        </member>
        <member name="P:NFX.OrderedRegistry`1.Item(System.Int32)">
            <summary>
            Tries to return an item by its position index in ordered set of items that this registry keeps.
            Null is returned when index is out of bounds.
            Note: since registry does reading in a lock-free manner, it is possible to have an inconsistent read snapshot
             of ordered items which may capture items that have already/not yet been added to the registry
            </summary>
        </member>
        <member name="T:NFX.Glue.Protocol.Headers">
            <summary>
            List of headers
            </summary>
        </member>
        <member name="T:NFX.Glue.Protocol.HeaderConfigurator">
            <summary>
            Provides general configuration reading logic for headers.
            Note: This class is not invoked by default glue runtime, so default application
             configurations that include header injections will be ignored unless this class is specifically called
             from code. This is because conf-based header injection is a rare case that may need to be controlled by a particular application
            </summary>
        </member>
        <member name="T:NFX.Glue.Protocol.Msg">
            <summary>
            Represents a message base that requests and responses derive from.
            Messages are exchanged between glued tiers
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.Msg.#ctor">
            <summary>
            Constructs new message and allocates unique ID
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.Msg.__SetArrivalTimeStampTicks(System.Int64)">
            <summary>
            Framework method not for developers. Sets arrival ticks stamp. Usually called from transport
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.Msg.__SetBindingSpecificContext(System.Object)">
            <summary>
            Internal method not to be called by app developers. 
            Called from custom bindings to inject binding-specific context
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.Msg.__SetBindingSpecificContext(NFX.Glue.Protocol.Msg)">
            <summary>
            Internal method not to be called by app developers. 
            Called from custom bindings to inject binding-specific context
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.Msg.CloneState(NFX.Glue.Protocol.Msg,System.Boolean,System.Boolean)">
            <summary>
            Clones message state from another message instance.
            State includes binding-specific context and optionally headers and correlation data
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.Msg.ID">
            <summary>
            Returns a unique ID for this message
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.Msg.ArrivalTimeStamp">
            <summary>
            Returns arrival timestamp expressed in ticks, that is - when message just arrived before its processing started by Glue (before deserialization).
            This property allows for glue-internal latency assessment
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.Msg.RequestID">
            <summary>
            Returns request ID that relates to this message instance. It is the message ID for RequestMsg and related message ID for ResponseMsg 
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.Msg.HasHeaders">
            <summary>
            Returns true when this message contains header data
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.Msg.Headers">
            <summary>
            Returns a list of headers that this message contains
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.Msg.HasCorrelationData">
            <summary>
            Returns true when this message contains header data
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.Msg.CorrelationData">
            <summary>
            Arbitrary named object collection that can be used to correlate messages and/or attach extra data. 
            This field is NOT transmitted over wire nor is it used by the framework. Message inspectors may use this property
            at their own discretion, for example in cases when the same inspector type is registered on multiple levels (endpoint, binding, glue),
            inspectors may check this property to execute only once per message.
            The collection is lazily allocated at the first reference attempt
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.Msg.BindingSpecificContext">
            <summary>
            Returns a binding-specific context object which is used for message processing/routing by binding.
            This property value is not serialized and used internally by Glue framework. Not all bindings use/need this property
            </summary>
        </member>
        <member name="T:NFX.Glue.GlueException">
            <summary>
            Base exception thrown by the Glue framework
            </summary>
        </member>
        <member name="T:NFX.Glue.InvalidGlueOperationException">
            <summary>
            Base exception thrown by the Glue framework when some operations are invoked that do not apply
            </summary>
        </member>
        <member name="T:NFX.Glue.ClientCallException">
            <summary>
            Thrown by the Glue framework when clients try to perfom a call but that action fails
            </summary>
        </member>
        <member name="P:NFX.Glue.ClientCallException.CallStatus">
            <summary>
            Returns call status enum
            </summary>
        </member>
        <member name="T:NFX.Glue.ClientMsgInspectionException">
            <summary>
            Thrown by the Glue framework when client message inspector fails with exception
            </summary>
        </member>
        <member name="P:NFX.Glue.ClientMsgInspectionException.Inspector">
            <summary>
            Returns inspector that threw exception
            </summary>
        </member>
        <member name="T:NFX.Glue.RemoteException">
            <summary>
            Base exception thrown by the Glue framework when remote errors are reported back to caller
            </summary>
        </member>
        <member name="P:NFX.Glue.RemoteException.Remote">
            <summary>
            Returns remote exception data
            </summary>
        </member>
        <member name="T:NFX.Glue.ProtocolException">
            <summary>
            Exception thrown when there are protocol-related errors like deserialization,
            request message received when response is expected
            </summary>
        </member>
        <member name="P:NFX.Glue.ProtocolException.CloseChannel">
            <summary>
            Returns true when error is not recoverable on the existing channel and it needs to be closed
            </summary>
        </member>
        <member name="T:NFX.Glue.MessageSizeException">
            <summary>
            Exception thrown in client/server when there's an attempt to send a too large message
            </summary>
        </member>
        <member name="T:NFX.Glue.ServerException">
            <summary>
            Exception thrown in Glue server
            </summary>
        </member>
        <member name="T:NFX.Glue.ServerNotRunningException">
            <summary>
            Exception thrown in Glue server when it shuts down/not running
            </summary>
        </member>
        <member name="T:NFX.Glue.ServerContractException">
            <summary>
            Exception thrown when server could not get contract
            </summary>
        </member>
        <member name="T:NFX.Glue.ServerInstanceActivationException">
            <summary>
            Exception thrown when server instance can not be created
            </summary>
        </member>
        <member name="T:NFX.Glue.StatefulServerInstanceDoesNotExistException">
            <summary>
            Exception thrown when statful server identified is not found/has expired/timed-out
            </summary>
        </member>
        <member name="T:NFX.Glue.StatefulServerInstanceLockTimeoutException">
            <summary>
            Exception thrown when statful server instance is not thread safe and could not be locked before set timeout expired
            </summary>
        </member>
        <member name="T:NFX.Glue.ServerMethodInvocationException">
            <summary>
            Exception thrown when server can not invoke method
            </summary>
        </member>
        <member name="T:NFX.Glue.Node">
            <summary>
            Represents a network node. It is a binding, logical address of a host and a service that host provides
            Nodes are not contract-dependent. The componets of address are not case-sensitive.
            The form of the address is: <code>binding://host:service</code>. The "host" and "service" segment syntaxes depend on binding and may not contain the ':' char.
            An example of some 'mytest' binding: 'mytest://adr=1.1.1.1,nic=eth001:job,chat,backup'
            </summary>
        </member>
        <member name="M:NFX.Glue.Node.#ctor(System.String)">
            <summary>
            Inits a node struct. It is a binding, logical address of a host and a service that host provides
            Nodes are not contract-dependent. The componets of address are not case-sensitive.
            The form of the address is: <code>binding://host:service</code>. The "host" and "service" segment syntaxes depend on binding and may not contain the ':' char.
            An example of some 'mytest' binding: 'mytest://adr=1.1.1.1,nic=eth001:job,chat,backup'
            </summary>
        </member>
        <member name="P:NFX.Glue.Node.ConnectString">
            <summary>
            Gets a connection string - a structured URL-like connection descriptor that identifies a host 
             along with binding and service. The componets of address are not case-sensitive.
            The form of the address is: <code>binding://host:service</code>. The "host" and "service" segment syntaxes depend on binding and may not contain the ':' char.
            An example of some 'mytest' binding: 'mytest://adr=1.1.1.1,nic=eth001:job,chat,backup'
            </summary>
        </member>
        <member name="P:NFX.Glue.Node.Assigned">
            <summary>
            Returns true when struct has some data assigned i.e. connect string is specified
            </summary>
        </member>
        <member name="P:NFX.Glue.Node.Binding">
            <summary>
            Gets binding portion of ConnectString. This value selects binding adapter
            </summary>
        </member>
        <member name="P:NFX.Glue.Node.Host">
            <summary>
            Gets host portion of ConnectString. This value may have a structure of its own which is understood by binding adapter
            </summary>
        </member>
        <member name="P:NFX.Glue.Node.Service">
            <summary>
            Gets service/port portion of ConnectString. This value may have a structure of its own which is understood by binding adapter
            </summary>
        </member>
        <member name="T:NFX.Glue.Bindings">
            <summary>
            A registry of Binding-derived instances
            </summary>
        </member>
        <member name="T:NFX.Glue.Protocol.RemoteExceptionData">
            <summary>
            Marshalls exception details
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.RemoteExceptionData.#ctor(System.Exception)">
            <summary>
            Initializes instance form local exception
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.RemoteExceptionData.TypeName">
            <summary>
            Returns the name of remote exception type
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.RemoteExceptionData.Message">
            <summary>
            Returns the message of remote exception
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.RemoteExceptionData.Code">
            <summary>
            Returns the code of remote NFX exception
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.RemoteExceptionData.Source">
            <summary>
            Name of the object that caused the error
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.RemoteExceptionData.StackTrace">
            <summary>
            Returns stack trace
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.RemoteExceptionData.ApplicationName">
            <summary>
            Returns the name of remote application
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.RemoteExceptionData.InnerException">
            <summary>
            Returns the inner remote exception if any
            </summary>
        </member>
        <member name="T:NFX.Glue.Protocol.RequestMsg">
            <summary>
            This message is sent from client to server and contains contract type, method specification and invocation arguments
            which are either included as object[] if RequestAnyMsg is used or inlined in RequestMsg- typed derivative for speed to avoid boxing
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.RequestMsg.#ctor(System.Reflection.MethodInfo,System.Nullable{System.Guid})">
            <summary>
            Constructs request message from method information and arguments for call invocation. 
            This constructor is slower as it uses reflection
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.RequestMsg.#ctor(NFX.Glue.Protocol.TypeSpec,NFX.Glue.Protocol.MethodSpec,System.Boolean,System.Nullable{System.Guid})">
            <summary>
            Constructs request message from pre-computed  specs obtained by reflection. 
            This constructor is the fastest as it does not use reflection
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.RequestMsg.#ctor(NFX.Glue.Protocol.RequestMsg,System.Reflection.MethodInfo,System.Nullable{System.Guid},System.Boolean,System.Boolean)">
            <summary>
            This .ctor is handy for message inspectors.
            Creates a substitute message for the original one with new values.
            Binding-specific context is cloned and headers/correlation data are cloned conditionaly
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.RequestMsg.#ctor(NFX.Glue.Protocol.RequestMsg,NFX.Glue.Protocol.TypeSpec,NFX.Glue.Protocol.MethodSpec,System.Boolean,System.Nullable{System.Guid},System.Boolean,System.Boolean)">
            <summary>
            This .ctor is handy for message inspectors.
            Creates a substitute message for the original one with new values.
            Binding-specific context is cloned and headers/correlation data are cloned conditionaly
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.RequestMsg.__setServerTransport(NFX.Glue.ServerTransport)">
            <summary>
            Implementation-specific internal method not to be used by developers
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.RequestMsg.RequestID">
            <summary>
            Returns request ID for this instance. Every request is uniquely identified 
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.RequestMsg.RemoteInstance">
            <summary>
            If server is stateful then this property contains remote instance ID
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.RequestMsg.Contract">
            <summary>
            Returns contract type that this call belongs to. This property throws if actual specified type can not be found
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.RequestMsg.ContractSpec">
            <summary>
            Returns contract type spec that this call belongs to
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.RequestMsg.MethodName">
            <summary>
            Gets a name of method to be invoked on the other side
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.RequestMsg.Method">
            <summary>
            Gets a method specification to be invoked on the other side
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.RequestMsg.OneWay">
            <summary>
            Indicates that no response is expected
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.RequestMsg.ServerTransport">
            <summary>
            Returns transport that this request arrived through. Property is to be used only on server
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.RequestMsg.Session">
            <summary>
            Session reference that can be used to pass session object that was already determined by transport (i.e. HttpServerTransport)
             into Glue server handler. This property is NOT transmitted/serialized over wire
            </summary>
        </member>
        <member name="T:NFX.Glue.Protocol.RequestAnyMsg">
            <summary>
            Represents request msg that marshalls arguments as object[].
            Although the most convenient and simple, this way of working with glue is slower than
            using RequestTypedMsg which needs to be derived-from for every method
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.RequestAnyMsg.#ctor(System.Reflection.MethodInfo,System.Nullable{System.Guid},System.Object[])">
            <summary>
            Constructs request message from method information and arguments for call invocation. 
            This constructor is slower as it uses reflection
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.RequestAnyMsg.#ctor(NFX.Glue.Protocol.TypeSpec,NFX.Glue.Protocol.MethodSpec,System.Boolean,System.Nullable{System.Guid},System.Object[])">
            <summary>
            Constructs request message from pre-computed  specs obtained by reflection. 
            This constructor is the fastest as it does not use reflection
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.RequestAnyMsg.#ctor(NFX.Glue.Protocol.RequestMsg,System.Reflection.MethodInfo,System.Nullable{System.Guid},System.Object[],System.Boolean,System.Boolean)">
            <summary>
            This .ctor is handy for message inspectors.
            Creates a substitute message for the original one with new values.
            Binding-specific context is cloned and headers/correlation data are cloned conditionaly
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.RequestAnyMsg.#ctor(NFX.Glue.Protocol.RequestMsg,NFX.Glue.Protocol.TypeSpec,NFX.Glue.Protocol.MethodSpec,System.Boolean,System.Nullable{System.Guid},System.Object[],System.Boolean,System.Boolean)">
            <summary>
            This .ctor is handy for message inspectors.
            Creates a substitute message for the original one with new values.
            Binding-specific context is cloned and headers/correlation data are cloned conditionaly
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.RequestAnyMsg.Arguments">
            <summary>
            Returns call arguments
            </summary>
        </member>
        <member name="T:NFX.Glue.CallSlot">
            <summary>
            Represents a class that is immediately returned after transport sends RequestMsg.
            This class provides CallStatus and RequestID properties where the later is used to match the incoming ResponseMsg.
            CallSlots are kinds of "spirit-less" mailboxes that keep state about the call, but do not posess any threads/call events.
            Working with CallSlots from calling code's existing thread of execution is the most efficient way of working with Glue (in high load cases), as
             it does not create extra object instances (tasks do) for asynchronous coordination and continuation.
            It is possible to obtain an instance of CallSlot.AsTask in which case that instance is registered with the framework-internal reactor
             so task does complete normally even on timeout, however, in high-throughput apps (10K+ calls per second) this method is not the most efficient one
             as it allocates additional objects (task, list entry etc.) that eventually increase GC load for long runs.
             Note: A 3.2 Ghz 4-Core I7 server with 8Gb of ram can easily handle 40K 2-way calls a second (given little business server logic and simple payload). 
             See also: CallReactor class
            </summary>
        </member>
        <member name="M:NFX.Glue.CallSlot.#ctor(NFX.Glue.ClientEndPoint,NFX.Glue.ClientTransport,NFX.Glue.Protocol.RequestMsg,NFX.Glue.CallStatus,System.Int32)">
            <summary>
            INTERNAL METHOD. Developers do not call!
            This constructor is used by an Async binding that delivers response after call slot was created
            </summary>
        </member>
        <member name="M:NFX.Glue.CallSlot.#ctor(NFX.Glue.ClientEndPoint,NFX.Glue.ClientTransport,System.Int64,System.DateTime,NFX.Glue.Protocol.RequestMsg,NFX.Glue.Protocol.ResponseMsg,System.Int32)">
            <summary>
            INTERNAL METHOD. Developers do not call!
            This constructor is used by a synchronous binding that delivers response right after sending it.
            ONLY for OneWayCall = false
            </summary>
        </member>
        <member name="M:NFX.Glue.CallSlot.AsTaskReturning``1">
            <summary>
            Creates a wrapper task around CallSlot.AsTask and returns CallSlot.GetValue() as TCallResult-returning Task.
            Note: the created wrapper task is not cached
            </summary>
        </member>
        <member name="M:NFX.Glue.CallSlot.DeliverResponse(NFX.Glue.Protocol.ResponseMsg)">
            <summary>
            Called internally by framework to populate the response message when one asynchronously arrives from transport
            </summary>
        </member>
        <member name="M:NFX.Glue.CallSlot.SignalDispatchError(System.String)">
            <summary>
            Signal erroneous completion of request dispatching. This method is used by transports that post outgoing message asynchronously
            </summary>
        </member>
        <member name="M:NFX.Glue.CallSlot.GetValue``1">
            <summary>
            Returns a value from the other side, that is - 
            gets the response message and checks it for errors,
            throwing RemoteError exception if one came from server.  
            Accessing this property blocks calling thread until either ResponseMsg arrives or timeout expires.
            Check 'Available' property not to block. Accessing this method for [OneWay] methods throws.
            </summary>
        </member>
        <member name="M:NFX.Glue.CallSlot.CheckVoidValue">
            <summary>
            Checks for a valid void value returned from the other side, that is - 
            gets the response message and checks it for errors,
            throwing RemoteError exception if one came from server. 
            Accessing this property blocks calling thread until either ResponseMsg arrives or timeout expires.
            Check 'Available' property not to block. Accessing this method for [OneWay] methods throws.
            </summary>
        </member>
        <member name="P:NFX.Glue.CallSlot.Client">
            <summary>
            Returns client endpoint that initiated this call
            </summary>
        </member>
        <member name="P:NFX.Glue.CallSlot.ClientTransport">
            <summary>
            Returns client transport that this instance is originated from
            </summary>
        </member>
        <member name="P:NFX.Glue.CallSlot.CallContext">
            <summary>
            General-purpose property that clients can use for attaching an arbitrary context to this instance. This property has no use in the framework
            </summary>
        </member>
        <member name="P:NFX.Glue.CallSlot.CallStatus">
            <summary>
            Returns current call status. Timeout is returned when response has not arrived from the other side in alotted time. This is a non-blocking call
            </summary>
        </member>
        <member name="P:NFX.Glue.CallSlot.DispatchErrorMessage">
            <summary>
            Optionally returns reason of the dispatch message failure
            </summary>
        </member>
        <member name="P:NFX.Glue.CallSlot.OneWay">
            <summary>
            Indicates that this call does not expect a response message from the server side
            </summary>
        </member>
        <member name="P:NFX.Glue.CallSlot.RequestID">
            <summary>
            Returns request ID for the request that was sent and generated this slot instance 
            </summary>
        </member>
        <member name="P:NFX.Glue.CallSlot.TimeoutMs">
            <summary>
            Returns timeout for this instance
            </summary>
        </member>
        <member name="P:NFX.Glue.CallSlot.StartTime">
            <summary>
            Returns UTC timestamp of call initiation
            </summary>
        </member>
        <member name="P:NFX.Glue.CallSlot.StatStartTimeTicks">
            <summary>
            When binding's MeasureStatTimes enabled, returns the operation start tick count
            </summary>
        </member>
        <member name="P:NFX.Glue.CallSlot.StatRoundtripEndTimeTicks">
            <summary>
            When binding's MeasureStatTimes enabled, returns the operation end (when response arrives) tick count
            </summary>
        </member>
        <member name="P:NFX.Glue.CallSlot.StatRoundtripTimeKey">
            <summary>
            When binding's MeasureStatTimes enabled, returns the name of the stat key
            </summary>
        </member>
        <member name="P:NFX.Glue.CallSlot.AsTask">
            <summary>
            Gets the CallSlot instance as a task that gets completed either instantly for one-way calls or when result arrives or timeout happens.
            The returned task never gets canceled
            </summary>
        </member>
        <member name="P:NFX.Glue.CallSlot.Available">
            <summary>
            Returns true when response has come and available so no blocking will occur when reading response. This is a non-blocking call.
            Always returns true for operations marked as [OneWay]
            </summary>
        </member>
        <member name="P:NFX.Glue.CallSlot.ResponseMsg">
            <summary>
            Blocks until response comes or timeout happens. Response message inspection happens in the context of a calling thread
            </summary>
        </member>
        <member name="T:NFX.Glue.TimeoutReactor">
            <summary>
            Internal class that polls call slots for timeout
            </summary>
        </member>
        <member name="T:NFX.Glue.Future`1">
            <summary>
            Provides a higher-level wrapper around CallSlot returned value by Glue.
            All property accessors evaluate synchronously on the calling thread.
            This struct should not be used with One-Way calls or calls that return void
            </summary>
        </member>
        <member name="F:NFX.Glue.Future`1.Call">
            <summary>
            Returns the underlying CallSlot object
            </summary>
        </member>
        <member name="P:NFX.Glue.Future`1.Available">
            <summary>
            Non-blocking call that returns true if result arrived, false otherwise
            </summary>
        </member>
        <member name="P:NFX.Glue.Future`1.Value">
            <summary>
            Blocking call that waits for return value. Use non-blocking Available to see if result arrived
            </summary>
        </member>
        <member name="T:NFX.Glue.FutureVoid">
            <summary>
            Provides a higher-level wrapper around CallSlot returned by Glue.
            All property accessors evaluate synchronously on the calling thread.
            This struct should not be used with One-Way calls 
            </summary>
        </member>
        <member name="F:NFX.Glue.FutureVoid.Call">
            <summary>
            Returns the underlying CallSlot object
            </summary>
        </member>
        <member name="M:NFX.Glue.FutureVoid.Wait">
            <summary>
            Blocking call that waits for call completion. Use non-blocking Available to see if call has completed
            </summary>
        </member>
        <member name="P:NFX.Glue.FutureVoid.Available">
            <summary>
            Non-blocking call that returns true if result arrived, false otherwise
            </summary>
        </member>
        <member name="T:NFX.Glue.Protocol.ResponseMsg">
            <summary>
            Represents a response message sent by called party 
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.ResponseMsg.#ctor(NFX.Glue.Protocol.ResponseMsg,System.Object,System.Boolean,System.Boolean)">
            <summary>
            This .ctor is handy for message inspectors.
            Creates a substitute message for the original one with new value.
            Binding-specific context is cloned and headers/correlation data are cloned conditionaly
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.ResponseMsg.RequestID">
            <summary>
            Returns request ID this response is for 
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.ResponseMsg.ReturnValue">
            <summary>
            Returns return value of the called method. Note: out and ref params are not supported
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.ResponseMsg.RemoteInstance">
            <summary>
            For stateful servers returns instance ID 
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.ResponseMsg.ExceptionData">
            <summary>
            Returns remote exception data if any
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.ResponseMsg.OK">
            <summary>
            Returns true when reponse does not contain remote server exception which is represented by RemoteExceptionData
            </summary>
        </member>
        <member name="T:NFX.Glue.TransportKind">
            <summary>
            Defines kinds of trasport
            </summary>
        </member>
        <member name="T:NFX.Health.BaseCheck">
            <summary>
            Base class for all Health Checks. Particular health checks must inherit from
             this class to be invoked
            </summary>
        </member>
        <member name="F:NFX.Health.BaseCheck.Result">
            <summary>
            Results property bag may be used for reporting of additional
            health-check parameters i.e. latency, content size etc...
            </summary>
        </member>
        <member name="M:NFX.Health.BaseCheck.Run(System.Collections.Specialized.NameValueCollection)">
            <summary>
            Runs the check
            </summary>
        </member>
        <member name="M:NFX.Health.BaseCheck.DoRun(System.Collections.Specialized.NameValueCollection)">
            <summary>
            Override to provide particular health check implementation
            </summary>
        </member>
        <member name="P:NFX.Health.BaseCheck.CanRun">
            <summary>
            Indicates whether this check will be executed
            </summary>
        </member>
        <member name="P:NFX.Health.BaseCheck.Name">
            <summary>
            Provides textual name for this check. Base implementation returns full type name
            </summary>
        </member>
        <member name="P:NFX.Health.BaseCheck.Description">
            <summary>
            Provides additional textual description of the check
            </summary>
        </member>
        <member name="T:NFX.Health.CheckListStatus">
            <summary>
            Stipulates status for Health.CheckList
            </summary>
        </member>
        <member name="T:NFX.Health.CheckList">
            <summary>
            Represents a list of health checks to be performed.
            Health checks are classes derived from BaseCheck class and must implement DoRun() method
             that performs application-specific checking. CheckList obtains a list of Check instances
              from assemblies supplied to its constructor. 
            Health checks are executed in no predictable order.
            If particular execution order is necessary then a check has to be written to explicitly
             coordinate sub-checks.
            The class is thread safe for all operations.
            </summary>
        </member>
        <member name="M:NFX.Health.CheckList.#ctor(System.String,System.String,NFX.Environment.ConfigSectionNode)">
            <summary>
            Initializaes check list from assembly names separated by semicolons.
            Optional path will be prepended to every assembly name
            </summary>
        </member>
        <member name="M:NFX.Health.CheckList.#ctor(System.Collections.Generic.IEnumerable{System.Reflection.Assembly},NFX.Environment.ConfigSectionNode)">
            <summary>
            Initializaes check list from assemblies 
            </summary>
        </member>
        <member name="M:NFX.Health.CheckList.Run(System.Collections.Specialized.NameValueCollection)">
            <summary>
            Runs health checks. Checks are ran in NO PARTICULAR order.
            This method can not be called twice
            </summary>
        </member>
        <member name="M:NFX.Health.CheckList.Report(System.IO.TextWriter,System.String)">
            <summary>
            Dumps check results into writer in on of the supported formats
            </summary>
        </member>
        <member name="P:NFX.Health.CheckList.Status">
            <summary>
            Returns current status - whether checks are running  or have already been run
            </summary>
        </member>
        <member name="P:NFX.Health.CheckList.Checks">
            <summary>
            Returns health checks
            </summary>
        </member>
        <member name="P:NFX.Health.CheckList.Successful">
            <summary>
            Returns true when all checks that could be run have successfuly run
            </summary>
        </member>
        <member name="P:NFX.Health.CheckList.AllSuccessful">
            <summary>
            Returns true when all checks have successfuly run
            </summary>
        </member>
        <member name="P:NFX.Health.CheckList.RunStart">
            <summary>
            Returns when run started
            </summary>
        </member>
        <member name="P:NFX.Health.CheckList.RunFinish">
            <summary>
            Returns when run finished
            </summary>
        </member>
        <member name="T:NFX.Health.CheckResult">
            <summary>
            Property bag to report health check results
            </summary>
        </member>
        <member name="P:NFX.Health.CheckResult.Successful">
            <summary>
            Indicates whether health check succeeded
            </summary>
        </member>
        <member name="P:NFX.Health.CheckResult.Exception">
            <summary>
            Exception that surfaced during check, consequently failing the check
            </summary>
        </member>
        <member name="P:NFX.Health.CheckResult.Skipped">
            <summary>
            Indicates whether check was not run
            </summary>
        </member>
        <member name="T:NFX.Health.HealthException">
            <summary>
            Represents general ancestor for exceptions thrown by health checks
            </summary>
        </member>
        <member name="T:NFX.Health.HealthCheckListException">
            <summary>
            Thrown by Health.CheckList
            </summary>
        </member>
        <member name="T:NFX.Health.HTMLReporter">
            <summary>
            Reports health check results as HTML
            </summary>
        </member>
        <member name="T:NFX.Health.Reporter">
            <summary>
            Base for all reporters - entities that output check list state into TextWriter
            </summary>
        </member>
        <member name="T:NFX.Health.TextReporter">
            <summary>
            Reports health check results in an plain text format
            </summary>
        </member>
        <member name="T:NFX.Health.XMLReporter">
            <summary>
            Reports XML health check results 
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Analytics.TimeHistogramHelper">
            <summary>
            Helper class used by TimerHistogram
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogramHelper.Title(System.String,System.Int64)">
            <summary>
            Histogram title used for displaying purposes
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogramHelper.Clear">
            <summary>
            Reset internal histogram state
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogramHelper.Start">
            <summary>
            Start sample time measurement
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogramHelper.Stop">
            <summary>
            Stop sample time measurement started by Start() call
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogramHelper.MinTime">
            <summary>
            Minimum time of all sample measurements
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogramHelper.MaxTime">
            <summary>
            Maximum time of all sample measurements
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Analytics.TimeDimension">
            <summary>
            A dimension of data type double partitions a range of values
            by mapping the given value into [0 ... PartitionCount] partitions.
            This is a helper class for creating a dimension of TimeHistogram
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Analytics.Dimension`1">
            <summary>
            A dimension of data type TData partitions a range of values
            by mapping the given value into [0 ... PartitionCount] partitions
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Analytics.Dimension">
            <summary>
            Base class of a histogram dimension.
            of data type TData partitions a range defined by MinValue and MaxValue,
            by mapping the given value into [0 ... PartitionCount] partitions
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Dimension.#ctor(System.String,System.Int32,NFX.Instrumentation.Analytics.PartitionNameFunc)">
            <summary>
            Creates histogram dimension instance. If partitionFunc is null then
            DoPartition must be overriden in the derived class
            </summary>
            <param name="name">Description of this dimension used in reporting</param>
            <param name="partCount">Total number of partitions</param>
            <param name="partitionNameFunc">Used to inject a function in order not to override this class</param>
        </member>
        <member name="F:NFX.Instrumentation.Analytics.Dimension.PartitionCount">
            <summary>
            Number of partitions in 
            </summary>
        </member>
        <member name="F:NFX.Instrumentation.Analytics.Dimension.Name">
            <summary>
            Provides meaningful name for displaying
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Dimension.GetPartitionName(System.Int32)">
            <summary>
            Returns the name of a partition identified by idx
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Dimension.DoPartitionName(System.Int32)">
            <summary>
            Override to implement a custom mapping logic to return the names of a given
            partition when its not passed in the .ctor
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.Dimension.Index">
            <summary>
            Index of this dimension in the histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.Dimension.DataType">
            <summary>
            Returns the type of data that this instance partitions
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Dimension`1.#ctor(System.String,System.Int32,NFX.Instrumentation.Analytics.PartitionFunc{`0},NFX.Instrumentation.Analytics.PartitionNameFunc)">
            <summary>
            Creates a histogram dimension. If partitionFunc is null then DoPartition must be
            overriden in the derived class
            </summary>
            <param name="name">Description of dimension used in reporting</param>
            <param name="partCount">Total number of partitions</param>
            <param name="partitionFunc">Used to inject a function in order not to override this class</param>
            <param name="partitionNameFunc">Used to inject a function in order not to override this class</param>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Dimension`1.DoPartition(`0)">
            <summary>
            Override to implement a custom partitioning logic in case of class derivation
            when its not passed in the .ctor
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.Dimension`1.DataType">
            <summary>
            Returns the type of data that this instance partitions
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.Dimension`1.Item(`0)">
            <summary>
            Maps a value into partition index
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeDimension.#ctor(System.String,System.Int32,NFX.Instrumentation.Analytics.PartitionFunc{System.Double},NFX.Instrumentation.Analytics.PartitionNameFunc)">
            <summary>
            Creates a histogram dimension. If partitionFunc is null then DoPartition must be
            overriden in the derived class
            </summary>
            <param name="desc">Description of dimension used in reporting</param>
            <param name="partCount">Total number of partitions</param>
            <param name="partitionFunc">Used to inject a function in order not to override this class</param>
            <param name="partitionNameFunc">Used to inject a function in order not to override this class</param>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeDimension.Item(System.Double)">
            <summary>
            Maps a value into partition index
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Analytics.TimeHistogram`2">
            <summary>
            Time measurement 3D histogram aggregates measurements in fractions of a second
            for a given 1st and 2nd dimension keys.
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Analytics.ITimeHistogram">
            <summary>
            Histogram for measuring latency
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Analytics.IHistogram">
            <summary>
            Basic histogram interface to be implemented by all types of
            instrumentation histograms
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.IHistogram.GetDimention(System.Int32)">
            <summary>
            Return a dimension of a histogram identified by index
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.IHistogram.GetPartitionName(System.Int32,System.Int32)">
            <summary>
            Returns the name of a partition in a given histogram dimension
            </summary>
            <param name="dimension">Dimension index</param>
            <param name="partition">Partition index</param>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.IHistogram.TryGet(NFX.Instrumentation.Analytics.HistogramKeys,System.Int32@)">
            <summary>
            Try to get the count of samples for the given histogram keys
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.IHistogram.Clear">
            <summary>
            Reset histogram state
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.IHistogram.Title">
            <summary>
            Histogram title used for displaying purposes
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.IHistogram.TotalSamples">
            <summary>
            Total number of samples in the histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.IHistogram.DimensionCount">
            <summary>
            Number of dimensions in this histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.IHistogram.Dimensions">
            <summary>
            Returns the dimension instances of this histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.IHistogram.Item(NFX.Instrumentation.Analytics.HistogramKeys)">
            <summary>
            Return the count of samples for the given histogram keys
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.ITimeHistogram.Start">
            <summary>
            Start sample time measurement
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.ITimeHistogram.MinTime">
            <summary>
            Minimum time of all measured samples
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.ITimeHistogram.MaxTime">
            <summary>
            Maximum time of all measured samples
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.ITimeHistogram.AvgTime">
            <summary>
            Average time of all measured samples
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram`2.TimeFrame(`0,`1)">
            <summary>
            Returns a disposable instance suitable for time measurement in a "using" block
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram`2.Start">
            <summary>
            Start sample time measurement
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram`2.Stop(`0,`1)">
            <summary>
            Stop sample time measurement started by Start() call
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram`2.Sample(System.Double,`0,`1)">
            <summary>
            Records time measurement in seconds
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram`2.Clear">
            <summary>
            Reset internal histogram state
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram`2.GetDimention(System.Int32)">
            <summary>
            Return a dimension of a histogram identified by index
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram`2.GetPartitionName(System.Int32,System.Int32)">
            <summary>
            Returns the name of a partition in a given histogram dimension
            </summary>
            <param name="dimension">Dimension index</param>
            <param name="partition">Partition index</param>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram`2.TryGet(NFX.Instrumentation.Analytics.HistogramKeys,System.Int32@)">
            <summary>
            Try to get the count of samples for the given histogram keys
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram`2.Title">
            <summary>
            Histogram title used for displaying purposes
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram`2.MinTime">
            <summary>
            Minimum time of all sample measurements
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram`2.MaxTime">
            <summary>
            Maximum time of all sample measurements
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram`2.AvgTime">
            <summary>
            Average time of all sample measurements
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram`2.TotalSamples">
            <summary>
            Total number of samples in the histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram`2.Dimensions">
            <summary>
            Returns the dimension instances of this histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram`2.DimensionCount">
            <summary>
            Number of dimensions in this histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram`2.Item(NFX.Instrumentation.Analytics.HistogramKeys)">
            <summary>
            Return the count of samples for the given histogram keys
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Analytics.TimeHistogram">
            <summary>
            Time measurement 1D histogram aggregates measurements in fractions of a second
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram.Start">
            <summary>
            Start sample time measurement
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram.Stop">
            <summary>
            Stop sample time measurement started by Start() call
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram.Sample(System.Double)">
            <summary>
            Records time measurement in seconds
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram.Clear">
            <summary>
            Reset internal histogram state
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram.GetDimention(System.Int32)">
            <summary>
            Return a dimension of a histogram identified by index
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram.GetPartitionName(System.Int32,System.Int32)">
            <summary>
            Returns the name of a partition in a given histogram dimension
            </summary>
            <param name="dimension">Dimension index</param>
            <param name="partition">Partition index</param>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram.TryGet(NFX.Instrumentation.Analytics.HistogramKeys,System.Int32@)">
            <summary>
            Try to get the count of samples for the given histogram keys
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram.TimeFrame">
            <summary>
            Returns a disposable instance suitable for time measurement in a "using" block
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram.Title">
            <summary>
            Histogram title used for displaying purposes
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram.MinTime">
            <summary>
            Minimum time of all sample measurements
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram.MaxTime">
            <summary>
            Maximum time of all sample measurements
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram.AvgTime">
            <summary>
            Average time of all sample measurements
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram.TotalSamples">
            <summary>
            Total number of samples in the histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram.Dimensions">
            <summary>
            Returns the dimension instances of this histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram.DimensionCount">
            <summary>
            Number of dimensions in this histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram.Item(NFX.Instrumentation.Analytics.HistogramKeys)">
            <summary>
            Return the count of samples for the given histogram keys
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Analytics.TimeHistogram`1">
            <summary>
            Time measurement 2D histogram aggregates measurements in fractions of a second
            for a given 1st dimension key.
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram`1.TimeFrame(`0)">
            <summary>
            Returns a disposable instance suitable for time measurement in a "using" block
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram`1.Start">
            <summary>
            Start sample time measurement
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram`1.Stop(`0)">
            <summary>
            Stop sample time measurement started by Start() call
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram`1.Sample(System.Double,`0)">
            <summary>
            Records time measurement in seconds
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram`1.Clear">
            <summary>
            Reset internal histogram state
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram`1.GetDimention(System.Int32)">
            <summary>
            Return a dimension of a histogram identified by index
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram`1.GetPartitionName(System.Int32,System.Int32)">
            <summary>
            Returns the name of a partition in a given histogram dimension
            </summary>
            <param name="dimension">Dimension index</param>
            <param name="partition">Partition index</param>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram`1.TryGet(NFX.Instrumentation.Analytics.HistogramKeys,System.Int32@)">
            <summary>
            Try to get the count of samples for the given histogram keys
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram`1.Title">
            <summary>
            Histogram title used for displaying purposes
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram`1.MinTime">
            <summary>
            Minimum time of all sample measurements
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram`1.MaxTime">
            <summary>
            Maximum time of all sample measurements
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram`1.AvgTime">
            <summary>
            Average time of all sample measurements
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram`1.TotalSamples">
            <summary>
            Total number of samples in the histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram`1.Dimensions">
            <summary>
            Returns the dimension instances of this histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram`1.DimensionCount">
            <summary>
            Number of dimensions in this histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram`1.Item(NFX.Instrumentation.Analytics.HistogramKeys)">
            <summary>
            Return the count of samples for the given histogram keys
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Analytics.Histogram`3">
            <summary>
            Three-dimensional histogram for storing number of samples for given
            dimension keys
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Analytics.Histogram">
            <summary>
            Base histogram to be used by typed histogram generic derived classes.
            The histogram holds a dictionary of integer counts for each measurement
            keys (with number of keys correspondent to the number of dimensions
            in the histogram).
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Histogram.GetDimention(System.Int32)">
            <summary>
            Return a dimension of a histogram identified by index
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Histogram.GetPartitionName(System.Int32,System.Int32)">
            <summary>
            Returns the name of a partition in a given histogram dimension
            </summary>
            <param name="dimension">Dimension index</param>
            <param name="partition">Partition index</param>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Histogram.TryGet(NFX.Instrumentation.Analytics.HistogramKeys,System.Int32@)">
            <summary>
            Try to get the count of samples for the given histogram keys
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Histogram.Clear">
            <summary>
            Reset histogram state
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.Histogram.DimensionCount">
            <summary>
            Number of dimensions in this histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.Histogram.Title">
            <summary>
            Histogram title used for displaying purposes
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.Histogram.TotalSamples">
            <summary>
            Total number of samples in the histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.Histogram.Dimensions">
            <summary>
            Returns the dimension instances of this histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.Histogram.Item(NFX.Instrumentation.Analytics.HistogramKeys)">
            <summary>
            Return the count of samples for the given histogram keys
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Histogram`3.#ctor(System.String,NFX.Instrumentation.Analytics.Dimension{`0},NFX.Instrumentation.Analytics.Dimension{`1},NFX.Instrumentation.Analytics.Dimension{`2})">
            <summary>
            Constructs a histogram from a given array of dimensions
            </summary>
            <param name="title">Histogram title used for displaying result</param>
            <param name="dimension1">Dimension of the 1st histogram dimension</param>
            <param name="dimension2">Dimension of the 2nd histogram dimension</param>
            <param name="dimension3">Dimension of the 3nd histogram dimension</param>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Histogram`3.TryGet(System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary>
            Try to get the sample count associated with the given histogram keys.
            If the keys are not present in the histogram dictionary return false
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Histogram`3.Sample(`0,`1,`2)">
            <summary>
            Increment histogram statistics for a given triplet of dimension values
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Histogram`3.Keys(`0,`1,`2)">
            <summary>
            Convert values to HistogramKeys struct
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Histogram`3.Value(`0,`1,`2)">
            <summary>
            Returns number of samples collected for a given key.
            The key is obtained by mapping the given values into the dimensions' partitions.
            Return value of 0 indicates that key is not present in the histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.Histogram`3.DimensionCount">
            <summary>
            Number of dimensions in this histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.Histogram`3.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            Return the sample count associated with given histogram keys
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Analytics.Histogram`2">
            <summary>
            Two-dimensional histogram for storing number of samples for given
            dimension keys
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Histogram`2.#ctor(System.String,NFX.Instrumentation.Analytics.Dimension{`0},NFX.Instrumentation.Analytics.Dimension{`1})">
            <summary>
            Constructs a histogram from a given array of dimensions
            </summary>
            <param name="title">Histogram title used for displaying result</param>
            <param name="dimension1">Dimension of the 1st histogram dimension</param>
            <param name="dimension2">Dimension of the 2nd histogram dimension</param>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Histogram`2.TryGet(System.Int32,System.Int32,System.Int32@)">
            <summary>
            Try to get the sample count associated with the given histogram keys.
            If the keys are not present in the histogram dictionary return false
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Histogram`2.Sample(`0,`1)">
            <summary>
            Increment histogram statistics for a given pair of dimension values
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Histogram`2.Keys(`0,`1)">
            <summary>
            Convert values to HistogramKeys struct
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Histogram`2.Value(`0,`1)">
            <summary>
            Returns number of samples collected for a given key.
            The key is obtained by mapping the given values into the dimensions' partitions.
            Return value of 0 indicates that key is not present in the histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.Histogram`2.DimensionCount">
            <summary>
            Number of dimensions in this histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.Histogram`2.Item(System.Int32,System.Int32)">
            <summary>
            Return the sample count associated with given histogram keys
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Analytics.Histogram`1">
            <summary>
            One-dimensional histogram for storing number of samples for a given
            dimension key
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Histogram`1.#ctor(System.String,NFX.Instrumentation.Analytics.Dimension{`0})">
            <summary>
            Constructs a histogram from a given array of dimensions
            </summary>
            <param name="title">Histogram title used for displaying result</param>
            <param name="dimension1">Dimension of the histogram dimension</param>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Histogram`1.TryGet(System.Int32,System.Int32@)">
            <summary>
            Try to get the sample count associated with the given histogram key.
            If the key is not present in the histogram dictionary return false
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Histogram`1.Sample(`0)">
            <summary>
            Increment histogram statistics for a given dimension value
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Histogram`1.Keys(`0)">
            <summary>
            Convert a value to HistogramKeys struct
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Histogram`1.Value(`0)">
            <summary>
            Returns number of samples collected for a given key.
            The key is obtained by mapping the given value into the dimension's partition.
            Return value of 0 indicates that key is not present in the histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.Histogram`1.DimensionCount">
            <summary>
            Number of dimensions in this histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.Histogram`1.Item(System.Int32)">
            <summary>
            Return the sample count associated with given histogram keys
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Analytics.HistogramKeys">
            <summary>
            Represents histogram dimension key vector.
            This class is introduced for performance enhancement vs int[] approach
            that would have allocated extra object on heap per call
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Analytics.HistogramEntry">
            <summary>
            The placeholder of histogram data that represents a sample count
            for a given set of histogram keys.
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Analytics.HistData">
            <summary>
            Helper type representing a dictionary for storing historam data
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Analytics.HistogramReporters">
            <summary>
            Maps histogram data into some other representation (such as text, HTML, etc)
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Analytics.PartitionFunc`1">
            <summary>
            References a function that maps input value into a partition index 
            in the context of a given Partitioner
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Analytics.PartitionNameFunc">
            <summary>
            Returns a partition name for a given partition index
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.ExceptionEvent">
            <summary>
            Represents an exception event recorded by instrumentation
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.ExceptionEvent.Record(System.Exception)">
            <summary>
            Create event from exception instance
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.ExceptionEvent.Record(System.String,System.Exception)">
            <summary>
            Create event from exception instance and source
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.ExceptionEvent.Record(System.String,System.Exception,System.DateTime)">
            <summary>
            Create event from exception instance as of utcTime 
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.IInstrumentation">
            <summary>
            Stipulates instrumentation contract
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.IInstrumentation.GetDatumTypeSources(System.Type,NFX.Instrumentation.Datum@)">
            <summary>
            Enumerates sources per Datum type ever recorded by the instance. This property may be used to build
             UIs for instrumentation, i.e. datum type tree. Returned data is NOT ORDERED.
             Returns default instance so caller may get default description/unit name
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.IInstrumentation.Record(NFX.Instrumentation.Datum)">
            <summary>
            Records instrumentation datum
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.IInstrumentation.GetBufferedResults(System.Int32)">
            <summary>
            Returns the specified number of samples from the ring result buffer in the near-chronological order,
            meaning that data is already sorted by time MOST of the TIME, however sorting is NOT GUARANTEED for all 
             result records returned as enumeration is a lazy procedure that does not make copies/take locks.
            The enumeration is empty if ResultBufferSize is less or equal to zero entries.
            If count is less or equal to zero then the system returns all results available.
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.IInstrumentation.GetBufferedResultsSince(System.DateTime)">
            <summary>
            Returns samples starting around the the specified UTCdate in the near-chronological order,
            meaning that data is already sorted by time MOST of the TIME, however sorting is NOT GUARANTEED for all 
             result records returned as enumeration is a lazy procedure that does not make copies/take locks.
            The enumeration is empty if ResultBufferSize is less or equal to zero entries
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.IInstrumentation.Enabled">
            <summary>
            Indicates whether instrumentation is enabled
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.IInstrumentation.Overflown">
            <summary>
            Returns true to indicate that instrumentation does not have any space left to record more data at the present moment
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.IInstrumentation.RecordCount">
            <summary>
            Returns current record count in the instance
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.IInstrumentation.MaxRecordCount">
            <summary>
            Gets/Sets the maximum record count that this instance can store
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.IInstrumentation.ProcessingIntervalMS">
            <summary>
            Specifies how often aggregation is performed
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.IInstrumentation.OSInstrumentationIntervalMS">
            <summary>
            Specifies how often OS instrumentation such as CPU and RAM is sampled.
            Value of zero disables OS sampling
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.IInstrumentation.SelfInstrumented">
            <summary>
            When true, outputs instrumentation data about the self (how many datum buffers, etc.)
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.IInstrumentation.ResultBufferSize">
            <summary>
            Returns the size of the ring buffer where result (aggregated) instrumentation records are kept in memory.
            The maximum buffer capacity is returned, not how many results have been buffered so far.
             If this property is less than or equal to zero then result buffering in memory is disabled
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.IInstrumentation.DataTypes">
            <summary>
            Enumerates distinct types of Datum ever recorded in the instance. This property may be used to build
             UIs for instrumentation, i.e. datum type tree. Returned data is NOT ORDERED
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.IInstrumentationImplementation">
            <summary>
            Stipulates instrumentation contract
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.InstrumentationService">
            <summary>
            Implements IInstrumentation. This service aggregates data by type,source and sends result into provider
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.InstrumentationService.#ctor">
            <summary>
            Creates a instrumentation service instance
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.InstrumentationService.#ctor(System.Object)">
            <summary>
            Creates a instrumentation service instance
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.InstrumentationService.ExternalParametersForGroups(System.String[])">
            <summary>
            Returns named parameters that can be used to control this component
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.InstrumentationService.Record(NFX.Instrumentation.Datum)">
            <summary>
            Records instrumentation datum
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.InstrumentationService.GetBufferedResults(System.Int32)">
            <summary>
            Returns the specified number of samples from the ring result buffer in the near-chronological order,
            meaning that data is already sorted by time MOST of the TIME, however sorting is NOT GUARANTEED for all 
             result records returned as enumeration is a lazy procedure that does not make copies/take locks.
            The enumeration is empty if ResultBufferSize is less or equal to zero entries.
            If count is less or equal to zero then the system returns all results available.
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.InstrumentationService.GetBufferedResultsSince(System.DateTime)">
            <summary>
            Returns samples starting around the the specified UTCdate in the near-chronological order,
            meaning that data is already sorted by time MOST of the TIME, however sorting is NOT GUARANTEED for all 
             result records returned as enumeration is a lazy procedure that does not make copies/take locks.
            The enumeration is empty if ResultBufferSize is less or equal to zero entries
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.InstrumentationService.GetDatumTypeSources(System.Type,NFX.Instrumentation.Datum@)">
            <summary>
            Enumerates sources per Datum type ever recorded by the instance. This property may be used to build
             UIs for instrumentation, i.e. datum type tree. Returned data is NOT ORDERED
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.InstrumentationService.ExternalGetParameter(System.String,System.Object@,System.String[])">
            <summary>
            Gets external parameter value returning true if parameter was found
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.InstrumentationService.ExternalSetParameter(System.String,System.Object,System.String[])">
            <summary>
            Sets external parameter value returning true if parameter was found and set
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.InstrumentationService.Overflown">
            <summary>
            Returns true to indicate that instrumentation does not have any space left to record more data
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.InstrumentationService.Provider">
            <summary>
            References provider that persists instrumentation data
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.InstrumentationService.ProcessingIntervalMS">
            <summary>
            Specifies how often aggregation is performed
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.InstrumentationService.OSInstrumentationIntervalMS">
            <summary>
            Specifies how often OS instrumentation such as CPU and RAM is sampled.
            Value of zero disables OS sampling
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.InstrumentationService.SelfInstrumented">
            <summary>
            When true, outputs instrumentation data about the self (how many datum buffers, etc.)
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.InstrumentationService.InstrumentationEnabled">
            <summary>
            Shortcut to SelfInstrumented, implements IInstrumentable
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.InstrumentationService.ExternalParameters">
            <summary>
            Returns named parameters that can be used to control this component
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.InstrumentationService.RecordCount">
            <summary>
            Returns current record count in the instance
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.InstrumentationService.MaxRecordCount">
            <summary>
            Gets/Sets the maximum record count that this instance can store
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.InstrumentationService.ResultBufferSize">
            <summary>
            Returns the size of the ring buffer where result (aggregated) instrumentation records are kept in memory.
            The maximum buffer capacity is returned, not how many results have been buffered so far.
             If this property is less than or equal to zero then result buffering in memory is disabled.
             This property can be set only on a stopped service
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.InstrumentationService.DataTypes">
            <summary>
            Enumerates distinct types of Datum ever recorded in the instance. This property may be used to build
             UIs for instrumentation, i.e. datum type tree. Returned data is NOT ORDERED
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.TypeBucketedData">
            <summary>
            Internal concurrent dictionary used for instrumentation data aggregation 
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.SrcBucketedData">
            <summary>
            Internal concurrent dictionary used for instrumentation data aggregation
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.DatumBag">
            <summary>
            Internal concurrent bag used for instrumentation data aggregation
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.NOPInstrumentation">
            <summary>
            Provides IInstrumentation implementation that does nothing 
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.NOPInstrumentation.Instance">
            <summary>
            Returns a singlelton instance of the NOPInstrumentation
            </summary>
        </member>
        <member name="T:NFX.Inventorization.BasicInventorization">
            <summary>
            Performs basic inventorization of Inventory-marked types and their members
            </summary>
        </member>
        <member name="T:NFX.Inventorization.IInventorization">
            <summary>
            Defines an abstraction of inventorization  
            </summary>
        </member>
        <member name="T:NFX.Inventorization.Strategies">
            <summary>
            Defines a list of inventorization strategies
            </summary>
        </member>
        <member name="T:NFX.Inventorization.InventorizationManager">
            <summary>
            Performs an inventory scan of supplied assemblies using specified options.
            Items to be included in result must be tagged with Inventory attribute, otherwise then will be omitted unless OnlyAttributed == false.
            The scan is performed using options and inventorization strategies.
            This class is NOT THREAD SAFE
            </summary>
        </member>
        <member name="M:NFX.Inventorization.InventorizationManager.#ctor(System.String,System.String)">
            <summary>
            Delimiter assembly names with ';'
            </summary>
        </member>
        <member name="M:NFX.Inventorization.InventorizationManager.Run(NFX.Environment.ConfigSectionNode)">
            <summary>
            Runs inventorization routine dumping result into config node
            </summary>
        </member>
        <member name="M:NFX.Inventorization.InventorizationManager.WriteInventoryAttributes(System.Collections.Generic.IEnumerable{NFX.Inventorization.InventoryAttribute},NFX.Environment.ConfigSectionNode)">
            <summary>
            Adds nodes for InventoryAttributes
            </summary>
        </member>
        <member name="M:NFX.Inventorization.InventorizationManager.WriteType(System.Type,NFX.Environment.ConfigSectionNode)">
            <summary>
            Describes type including generic arguments
            </summary>
        </member>
        <member name="P:NFX.Inventorization.InventorizationManager.Strategies">
            <summary>
            References inventorization strategies
            </summary>
        </member>
        <member name="P:NFX.Inventorization.InventorizationManager.Options">
            <summary>
            Options for inventorization strategies
            </summary>
        </member>
        <member name="P:NFX.Inventorization.InventorizationManager.OnlyAttributed">
            <summary>
            When true, inventorizes ONLY items that have have Inventory attribute applied.
            Even if this property is false but some other inventory filter specified, then an item must be Inventory-tagged to be included
            </summary>
        </member>
        <member name="P:NFX.Inventorization.InventorizationManager.Tiers">
            <summary>
            Imposes a filter on system tiers parameter of Inventory attribute
            </summary>
        </member>
        <member name="P:NFX.Inventorization.InventorizationManager.Concerns">
            <summary>
            Imposes a filter on system concerns parameter of Inventory attribute
            </summary>
        </member>
        <member name="P:NFX.Inventorization.InventorizationManager.Technology">
            <summary>
            Imposes a filter on technology parameter of Inventory attribute
            </summary>
        </member>
        <member name="P:NFX.Inventorization.InventorizationManager.Schema">
            <summary>
            Imposes a filter on schema parameter of Inventory attribute
            </summary>
        </member>
        <member name="P:NFX.Inventorization.InventorizationManager.Tool">
            <summary>
            Imposes a filter on tool parameter of Inventory attribute
            </summary>
        </member>
        <member name="P:NFX.Inventorization.InventorizationManager.StartDate">
            <summary>
            Imposes a filter on StartDate parameter of Inventory attribute
            </summary>
        </member>
        <member name="P:NFX.Inventorization.InventorizationManager.EndDate">
            <summary>
            Imposes a filter on EndDate parameter of Inventory attribute
            </summary>
        </member>
        <member name="T:NFX.Inventorization.InventorizationException">
            <summary>
            Base exception thrown by inventorization operations
            </summary>
        </member>
        <member name="T:NFX.Inventorization.RecordModelInventorization">
            <summary>
            Performs inventorization of records , fields and their relevant properties 
            </summary>
        </member>
        <member name="T:NFX.IO.WritingStreamer">
            <summary>
            Writes primitives to stream
            </summary>
        </member>
        <member name="T:NFX.IO.Streamer">
            <summary>
            Represents a base for stream readers and writers.
            Streamer object instances ARE NOT THREAD-safe
            </summary>
        </member>
        <member name="M:NFX.IO.Streamer.BindStream(System.IO.Stream)">
            <summary>
            Sets the stream as the target for output/input.
            This call must be coupled with UnbindStream()
            </summary>
        </member>
        <member name="M:NFX.IO.Streamer.UndindStream">
            <summary>
            Unbinds the current stream. This call is coupled with BindStream(stream)
            </summary>
        </member>
        <member name="P:NFX.IO.Streamer.Format">
            <summary>
            Returns format that this streamer implements
            </summary>
        </member>
        <member name="P:NFX.IO.Streamer.Stream">
            <summary>
            Returns underlying stream if it is bound or null
            </summary>
        </member>
        <member name="P:NFX.IO.Streamer.Encoding">
            <summary>
            Returns stream string encoding
            </summary>
        </member>
        <member name="T:NFX.IO.ReadingStreamer">
            <summary>
            Reads primitives from stream
            </summary>
        </member>
        <member name="T:NFX.IO.VarIntStr">
            <summary>
            Holds either an integer or a string value.
            This is useful for metadata, i.e. types, if type is known an integer is sent, otherwise a full type name is sent
            </summary>
        </member>
        <member name="T:NFX.IO.MetaHandle">
            <summary>
            Represents tuple of an unsigned integer with optional int or string metadata. If metadata is null then integer is stored by itself in an efficient way.
            The type is useful for storage of handles/indexes (such as pointer surrogates) with optional description of pointed-to data (such as type information).
            A special case is reserved for strings which are immutable yet reference types, in which case a special handle INLINED_STRING_HANDLE is set to indicate that 
             "Metadata" really contains string data that this handle should resolve into. Check "IsInlinedString" property to see if string was inlined.
            Check "IsInlinedValueType" is set to true when a struct/valuetype is inlined and "Metadata" contains type spec 
            </summary>
        </member>
        <member name="M:NFX.IO.MetaHandle.InlineString(System.String)">
            <summary>
            Inlines string instance instead of pointer handle
            </summary>
        </member>
        <member name="M:NFX.IO.MetaHandle.InlineValueType(System.Nullable{NFX.IO.VarIntStr})">
            <summary>
            Inlines value type instead of pointer handle
            </summary>
        </member>
        <member name="M:NFX.IO.MetaHandle.InlineRefType(System.Nullable{NFX.IO.VarIntStr})">
            <summary>
            Inlines ref type instead of pointer handle
            </summary>
        </member>
        <member name="M:NFX.IO.MetaHandle.InlineTypeValue(System.Nullable{NFX.IO.VarIntStr})">
            <summary>
            Inlines type value instead of pointer handle
            </summary>
        </member>
        <member name="P:NFX.IO.MetaHandle.Handle">
            <summary>
            Returns handle value. This value is invalid if special conditions such as inlining are true
            </summary>
        </member>
        <member name="P:NFX.IO.MetaHandle.IsInlinedString">
            <summary>
            Indicates whether a string instance is inlined in Metadata property
            </summary>
        </member>
        <member name="P:NFX.IO.MetaHandle.IsInlinedValueType">
            <summary>
            Indicates whether a struct (value type) instance is inlined right after this handle and Metadata property contains type
            </summary>
        </member>
        <member name="P:NFX.IO.MetaHandle.IsInlinedRefType">
            <summary>
            Indicates whether a reference (reference type) instance is inlined right after this handle and Metadata property contains type.
            This is used for handling of ref types that are natively supported by streamers
            </summary>
        </member>
        <member name="P:NFX.IO.MetaHandle.IsInlinedTypeValue">
            <summary>
            Indicates whether a reference to TYPE is inlined - that is a Metadata parameter points to the value of type (reference to Type)
            </summary>
        </member>
        <member name="T:NFX.IO.NFXIOException">
            <summary>
            Base exception thrown by the IO-related classes 
            </summary>
        </member>
        <member name="T:NFX.IO.StreamerFormat">
            <summary>
            Describes a format - apair of readers/writers along with their capabilities - what types format supports natively
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat.GetReadingStreamer(System.Text.Encoding)">
            <summary>
            Makes new reader instance
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat.GetWritingStreamer(System.Text.Encoding)">
            <summary>
            Makes new writer instance
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat.IsTypeSupported(System.Type)">
            <summary>
            Returns true when the supplied type is natively supported by format 
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat.IsRefTypeSupported(System.Type)">
            <summary>
            Returns true when the supplied ref type is natively supported by format 
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat.GetReadMethodForType(System.Type)">
            <summary>
            Returns a method info for reading a certain value type for this format or null if type is not supported
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat.GetReadMethodForRefType(System.Type)">
            <summary>
            Returns a method info for reading a certain ref type for this format or null if type is not supported
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat.GetWriteMethodForType(System.Type)">
            <summary>
            Returns a method info for writing a certain value type for this format or null if type is not supported
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat.GetWriteMethodForRefType(System.Type)">
            <summary>
            Returns a method info for writing a certain ref type for this format or null if type is not supported
            </summary>
        </member>
        <member name="T:NFX.IO.StreamerFormat`2">
            <summary>
            Describes a format - apair of readers/writers along with their capabilities.
            Developers may derive new formats that support custom serialization schemes
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat`2.GetReadingStreamer(System.Text.Encoding)">
            <summary>
            Makes new reader instance
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat`2.GetWritingStreamer(System.Text.Encoding)">
            <summary>
            Makes new writer instance
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat`2.MakeReadingStreamer(System.Text.Encoding)">
            <summary>
            Makes new reader instance
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat`2.MakeWritingStreamer(System.Text.Encoding)">
            <summary>
            Makes new writer instance
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat`2.IsTypeSupported(System.Type)">
            <summary>
            Returns true when the supplied value type is natively supported by format, that is - when this format 
             can directly write instances of this type without reflection/complex graph walk.
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat`2.IsRefTypeSupported(System.Type)">
            <summary>
            Returns true when the supplied reference type is natively supported by format, that is - when this format 
             can directly write instances of this type without reflection/complex graph walk.
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat`2.GetReadMethodForType(System.Type)">
            <summary>
            Returns a method info for reading a certain value type for this format or null if this type is not directly supported.
            Use IsTypeSupported(type) to see if the type is native to this format.
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat`2.GetReadMethodForRefType(System.Type)">
            <summary>
            Returns a method info for reading a certain reference type for this format or null if this type is not directly supported.
            Use IsRefTypeSupported(type) to see if the ref type is native to this format.
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat`2.GetWriteMethodForType(System.Type)">
            <summary>
            Returns a method info for writing a certain value type for this format.
            Use IsTypeSupported(type) to see if the type is native to this format.
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat`2.GetWriteMethodForRefType(System.Type)">
            <summary>
            Returns a method info for writing a certain ref type for this format.
            Use IsRefTypeSupported(type) to see if the type is native to this format.
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat`2.GetReadActionForType(System.Type)">
            <summary>
            Returns a function that reads the specified value type and returns it as object
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat`2.GetReadActionForRefType(System.Type)">
            <summary>
            Returns a function that reads the specified ref type and returns it as object
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat`2.GetWriteActionForType(System.Type)">
            <summary>
            Returns an action that writes the value of the specified value type 
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat`2.GetWriteActionForRefType(System.Type)">
            <summary>
            Returns an action that writes the value of the specified ref type 
            </summary>
        </member>
        <member name="T:NFX.IO.SlimFormat">
            <summary>
            A format that writes into binary files in an efficient way using variable-length integers, strings and meta handles.
            Developers may derive new formats that support custom serialization of their business-related types. This may increase performance dramatically.
            For example, in a drawing application a new format may derive from SlimFormat to natively serialize Point and PolarPoint structs to yield faster serialization times.
            NFX.Serialization.Slim.SlimSlimSerializer is capable of SlimFormat-derived format injection, in which case it will automatically discover new types that are directly supported
            by the format.
            </summary>
        </member>
        <member name="F:NFX.IO.SlimFormat.TypeSchema">
            <summary>
            Internally references type schema
            </summary>
        </member>
        <member name="P:NFX.IO.SlimFormat.Instance">
            <summary>
            Returns a singleton format instance
            </summary>
        </member>
        <member name="T:NFX.Log.Destinations.LogServiceDestination">
            <summary>
            Implements a destination that is based on another instance of LogService, which provides asynchronous buffering and failover capabilities.
            </summary>
        </member>
        <member name="T:NFX.Log.MessageFilterExpression">
            <summary>
            Defines an expression used for log message filtering.
            Important: it is not a good practice to create many different scopes as it leads to creation of many assemblies dynamically
            </summary>
        </member>
        <member name="T:NFX.Parsing.CompilingExpressionEvaluator`3">
            <summary>
            Implements an evaluator that compiles all expressions represented by instances of this class in a certain scope into dynamic assemblies.
            Every unique scope name creates a separate assembly.
            The compilation of scope is triggered either by a call to Compile() or first attempt to call Evaluate() on any instance within a scope. 
            Once a scope has been compiled, no further allocations in this scoped are allowed, this is because CLR does not allow to unload assemblies dynamically.
            Within an expression context is passed as "ctx" and argument as "arg".
            This class is thread-safe.
            </summary>
        </member>
        <member name="M:NFX.Parsing.CompilingExpressionEvaluator`3.IsScopeAlreadyCompiled(System.String)">
            <summary>
            Indicates whether this scope has already been compiled and no more epressions can be allocated in it
            </summary>
        </member>
        <member name="M:NFX.Parsing.CompilingExpressionEvaluator`3.#ctor(System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Allocates a new expression. This call fails if the scope was already compiled
            </summary>
            <param name="scope">A valid identifier for namespace sub-path like "mycode.test" no leading or trailing "."</param>
            <param name="expression">A C# expression to compile</param>
            <param name="referencedAssemblies"> An enumerable of assemblies that compiler should reference while building scope assembly i.e. "MyCompany.dll"</param>
            <param name="usings">Extra usings i.e. "System.IO", "MyCode.Routines" etc.</param>
        </member>
        <member name="M:NFX.Parsing.CompilingExpressionEvaluator`3.Compile">
            <summary>
            Forces the entire scope compilation now, so no delay is incurred on first call to Evaluate().
            </summary>
        </member>
        <member name="M:NFX.Parsing.CompilingExpressionEvaluator`3.Evaluate(`0,`2)">
            <summary>
            Evaluates expression using supplied arg in a context.
            Context is passed as "ctx" and argument as "arg".
            </summary>
        </member>
        <member name="P:NFX.Parsing.CompilingExpressionEvaluator`3.Scope">
            <summary>
            Returns a scope (similar to compilation unit / assembly) that this expression is in 
            </summary>
        </member>
        <member name="P:NFX.Parsing.CompilingExpressionEvaluator`3.Expression">
            <summary>
            Returns an original expression as string that is to be evaluated 
            </summary>
        </member>
        <member name="M:NFX.Log.MessageFilterExpression.#ctor(System.String)">
            <summary>
            Creates a new expression in a default logging filter scope.
            This .ctor will fail if at least one expression from this scope has already been compiled
            </summary>
        </member>
        <member name="M:NFX.Log.MessageFilterExpression.#ctor(System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Use this .ctor to specify a different scope name. Every unique scope name gets compiled into a new assembly,
            consequently it is not a good practice to create many different scopes.
            This .ctor will fail if at least one expression from this scope has already been compiled
            </summary>
        </member>
        <member name="T:NFX.Inventorization.SystemTiers">
            <summary>
            Designates system architecture tiers
            </summary>
        </member>
        <member name="T:NFX.Inventorization.SystemConcerns">
            <summary>
            Designates item concerns
            </summary>
        </member>
        <member name="T:NFX.Inventorization.InventoryAttribute">
            <summary>
            Defines an inventory-related set of data which is used by automatic code/component discovery
            such as database schema generation tools and system-global registry servers
            </summary>
        </member>
        <member name="P:NFX.Inventorization.InventoryAttribute.Tiers">
            <summary>
            Designates what tier this entry is for
            </summary>
        </member>
        <member name="P:NFX.Inventorization.InventoryAttribute.Concerns">
            <summary>
            Indicates what concerns this entry relates to
            </summary>
        </member>
        <member name="P:NFX.Inventorization.InventoryAttribute.Technology">
            <summary>
            A type of implementaton that this inventory entry refers to, i.e. "Oracle", "MongoDB", "Riak"
            </summary>
        </member>
        <member name="P:NFX.Inventorization.InventoryAttribute.Schema">
            <summary>
            Provides a name of schema for this item, for example [Inventory(Technology="MongoDB", Schema="UserTransactions")]  
            </summary>
        </member>
        <member name="P:NFX.Inventorization.InventoryAttribute.Tool">
            <summary>
            Provides an optional name of an applicable tool [Inventory(Tool="ErlangModuleGenerator")]  
            </summary>
        </member>
        <member name="P:NFX.Inventorization.InventoryAttribute.StartDate">
            <summary>
            Provides an optional start date i.e. when this item will start to be used
            </summary>
        </member>
        <member name="P:NFX.Inventorization.InventoryAttribute.EndDate">
            <summary>
            Provides an optional end date i.e. when this item will be phased out
            </summary>
        </member>
        <member name="P:NFX.Inventorization.InventoryAttribute.Parameters">
            <summary>
            Parameters for particular inventory entry. This can be used as params for auto-generating tools that scan inventories
            </summary>
        </member>
        <member name="T:NFX.Log.Destinations.ConsoleDestination">
            <summary>
            Logs messages in stdio.console
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.ConsoleDestination.LogTimeFormat">
            <summary>
            Time format for log line entries
            </summary>
        </member>
        <member name="T:NFX.Log.Destinations.CompositeDestination">
            <summary>
            Provides an abstraction of a wrap around another destinations
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.CompositeDestination.RegisterDestination(NFX.Log.Destinations.Destination)">
            <summary>
            Adds a destination to this wrapper
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.CompositeDestination.UnRegisterDestination(NFX.Log.Destinations.Destination)">
            <summary>
            Removes a destiantion from this wrapper, returns true if destination was found and removed
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.CompositeDestination.Destinations">
            <summary>
            Returns destinations that this destination wraps. This call is thread safe
            </summary>
        </member>
        <member name="T:NFX.Log.Destinations.FloodFilter">
            <summary>
            Implements a destination group that stops message flood 
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.FloodFilter.#ctor">
            <summary>
            Creates a filter that prevents message flood
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.FloodFilter.#ctor(NFX.Log.Destinations.Destination[])">
            <summary>
            Creates a filter that prevents message flood
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.FloodFilter.#ctor(System.String,NFX.Log.Destinations.Destination[])">
            <summary>
            Creates a filter that prevents message flood
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.FloodFilter.MaxCount">
            <summary>
            Sets how many messages may be batched per interval. If more messages arrive then their data is not going to be logged
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.FloodFilter.MaxTextLength">
            <summary>
            Imposes a limit in character length of combined message test
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.FloodFilter.MessageType">
            <summary>
            Determines the message type for message emitted when flood is detected
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.FloodFilter.MessageTopic">
            <summary>
            Determines the message topic for message emitted when flood is detected
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.FloodFilter.MessageSource">
            <summary>
            Determines the message topic for message emitted when flood is detected
            </summary>
        </member>
        <member name="T:NFX.Log.Destinations.SMTPDestination">
            <summary>
            Implements log destination that sends emails
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.SMTPDestination.#ctor">
            <summary>
            Creates a new instance of destination that sends EMails
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.SMTPDestination.#ctor(System.String,System.String,System.Int32,System.Boolean)">
            <summary>
            Creates a new instance of destination that sends EMails
            </summary>
        </member>
        <member name="T:NFX.Log.Destinations.SyslogDestination">
            <summary>
            Implements destination that sends messages to UNIX syslog using UDP datagrams
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.SyslogDestination.#ctor">
            <summary>
            Creates a new instance of destination that sends messages to .nix SYSLOG
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.SyslogDestination.#ctor(System.String,System.String,System.Int32)">
            <summary>
            Creates a new instance of destination that sends messages to .nix SYSLOG
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.SyslogDestination.Client">
            <summary>
            References the underlying syslog client instance
            </summary>
        </member>
        <member name="T:NFX.Log.Syslog.FacilityLevel">
            <summary>
            Standard SYSLOG severity levels http://en.wikipedia.org/wiki/Syslog
            </summary>
        </member>
        <member name="T:NFX.Log.Syslog.SeverityLevel">
            <summary>
            Standard SYSLOG severity levels http://en.wikipedia.org/wiki/Syslog
            </summary>
        </member>
        <member name="T:NFX.Log.Syslog.SyslogClient">
            <summary>
            Implements SYSLOG UDP client
            </summary>
        </member>
        <member name="T:NFX.Log.Syslog.SyslogMessage">
            <summary>
            Represents a UNIX-standard SYSLOG message
            </summary>
        </member>
        <member name="T:NFX.Parsing.CharCodes">
            <summary>
            Declares common char codes
            </summary>
        </member>
        <member name="T:NFX.RecordModel.CallableMethodAttribute">
            <summary>
            Decorates model methods that can be called by external code, such as NFX.WebForms
            </summary>
        </member>
        <member name="T:NFX.RecordModel.ClientScripts">
            <summary>
            A dictionary of [script-type, text] pairs which is returned to client.
            Use ClientScripts.*_TYPE family of constants to pass standard values for script-type keys
            </summary>
        </member>
        <member name="F:NFX.RecordModel.ClientScripts.VALIDATION_TYPE">
            <summary>
            Constant for client-side validation scripts
            </summary>
        </member>
        <member name="F:NFX.RecordModel.ClientScripts.PRESENTATION_TYPE">
            <summary>
            Constant for client-side presentation scripts
            </summary>
        </member>
        <member name="T:NFX.RecordModel.ClientScriptAttribute">
            <summary>
            Declaratively specifies what resource/text should be used to serve client script for requested technology. Decorates record models and record fields.
            Script text is taken from ClientScript.Text field, or from resource pointed-to by ClientScript.ResourceName.
            ResourceName may include @tech@ tag that is replaced with technology name.
            If neither Text nor ResourceName attribute fields specified, then script resource name is constructed according to this pattern:
             record-type.@tech@.js for records or record-type.codefieldname.@tech@.js for fields.
            If Type is not set than it defaults to ClientScripts.VALIDATION_TYPE value 
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ClientScriptAttribute.#ctor">
            <summary>
            Creates an attribute
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ClientScriptAttribute.#ctor(System.String,System.String)">
            <summary>
            Creates an attribute of particular type and text
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ClientScriptAttribute.GetScripts(System.Type,System.String,System.Collections.Generic.IEnumerable{NFX.RecordModel.ClientScriptAttribute},System.String)">
            <summary>
            Harvests client scripts from ClientScript attributes per specified technology.
            Script text is taken from ClientScript.Text field, or from resource pointed-to by ClientScript.ResourceName.
            ResourceName may include @tech@ tag that is replaced with technology name.
            If neither Text nor ResourceName attribute fields specified, then script resource name is constructed according to this pattern:
             record-type.@tech@.js for records or record-type.codefieldname.@tech@.js for fields
            </summary>
            <param name="scopeType">Scoping type relative to which resource are located</param>
            <param name="extraResourceScope">When not null, added to record type name if attribute does not specify either Text or ResourceName</param>
            <param name="attributes">Attributes decorating the declaration of record or field</param>
            <param name="technology">Technology of interest or null</param>
        </member>
        <member name="P:NFX.RecordModel.ClientScriptAttribute.Text">
            <summary>
            Gets/sets script text. This property takes precedence over ResourceName when specified
            </summary>
        </member>
        <member name="P:NFX.RecordModel.ClientScriptAttribute.ResourceName">
            <summary>
            Name of script resource which must be co-located with the record class that declares an entity decorated with this attribute.
            The property is used if Text is null or empty.
            The @tech@ tag may be placed within this string - it will be replaced with requested lower-case technology name, i.e. 
              "A.@tech@.B"  will be evaluate as "A.nfx.B" if "nfx" technology was requested
            </summary>
        </member>
        <member name="P:NFX.RecordModel.ClientScriptAttribute.Technology">
            <summary>
            A name of technology that this script supports
            </summary>
        </member>
        <member name="P:NFX.RecordModel.ClientScriptAttribute.Type">
            <summary>
            Script type - such as validation, presentation etc. which is served to client. Use ClientScripts.*_TYPE family of constants to pass standard values
            </summary>
        </member>
        <member name="T:NFX.RecordModel.RecordDefAttribute">
            <summary>
            A convenience for defining record properties declaratively
            </summary>
        </member>
        <member name="P:NFX.RecordModel.RecordDefAttribute.FieldValidationSuspended">
            <summary>
            Determines whether field validation should be deferred until Record.Post() 
            </summary>
        </member>
        <member name="P:NFX.RecordModel.RecordDefAttribute.NoBuildCrosscheks">
            <summary>
            Determines whether record instance building should bypass duplicate names checks. Setting this flag to true significantly improves performance
            when many record instances need to be allocated
            </summary>
        </member>
        <member name="P:NFX.RecordModel.RecordDefAttribute.SupportsNotificationBinding">
            <summary>
            Determines whether record can notify bindings. Disabling improves speed
            </summary>
        </member>
        <member name="T:NFX.RecordModel.FieldDefAttribute">
            <summary>
            A convenience for defining field properties declaratively
            </summary>
        </member>
        <member name="M:NFX.RecordModel.FieldDefAttribute.BuildAndDefineFields(NFX.RecordModel.Record)">
            <summary>
            Constructs fields for particular record instance using attributes
            </summary>
        </member>
        <member name="T:NFX.ReferenceEqualityComparer`1">
            <summary>
            Checks for reference equality. Use ReferenceEqualityComparer(T).Instance
            </summary>
        </member>
        <member name="T:NFX.RelationalModel.TargetType">
            <summary>
            Specifies a type of target that compiler produces output for
            </summary>
        </member>
        <member name="T:NFX.RelationalModel.Compiler">
            <summary>
            Represents a compiler that can turn source schema into particular target script/schema, i.e. into database creation script for particular technology
             (i.e. Oracle, MySQL, PostgreSQL, etc..) or some other code/script (i.e. RecordModel classes, JavaScript classes)
            </summary>
        </member>
        <member name="F:NFX.RelationalModel.Compiler.SCRIPT_INCLUDE_SECTION">
            <summary>
            Specifies the name of the file to be included in the output verbatim, i.e.:  script-include="mytypes.txt"{}
            </summary>
        </member>
        <member name="F:NFX.RelationalModel.Compiler.SCRIPT_COMMENT_ATTR">
            <summary>
            Specifies the comment that will be output for decorated entity in the script
            </summary>
        </member>
        <member name="F:NFX.RelationalModel.Compiler.SCRIPT_TEXT_SECTION">
            <summary>
            Specifies the text to be included in the output verbatim, i.e.:  script-text="INSERT INTO TBL_ABC VALUES(1, true, now())"{}
            </summary>
        </member>
        <member name="F:NFX.RelationalModel.Compiler.SCRIPT_OUTPUT_NAME_ATTR">
            <summary>
            Specifies the name of the output that script text has to be placed in
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.Compiler.GetOutputFileSuffix(System.String)">
            <summary>
            Override to provide meaningful extension for particular technology, i.e. SQL
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.Compiler.DoCompile">
            <summary>
            Performs a compilation - this is a root  override-able method where compilation starts
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.Compiler.BuildOutputs(NFX.RelationalModel.Compiler.Outputs)">
            <summary>
            Override to perform compilation into output, the base implementation loops over all nodes and interprets 
             script includes
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.Compiler.BuildNodeOutput(NFX.Environment.IConfigSectionNode,NFX.RelationalModel.Compiler.Outputs)">
            <summary>
            Override to perform custom interpretation per particular compiler target
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.Compiler.IncludeScriptFile(NFX.Environment.IConfigSectionNode,NFX.RelationalModel.Compiler.Outputs)">
            <summary>
            Performs a script file include
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.Compiler.IncludeScriptText(NFX.Environment.IConfigSectionNode,NFX.RelationalModel.Compiler.Outputs)">
            <summary>
            Performs a verbatim script text include
            </summary>                                    
        </member>
        <member name="M:NFX.RelationalModel.Compiler.EscapeFileName(System.String)">
            <summary>
            Replaces incompatible characters for file names with "_"
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.Compiler.Name">
            <summary>
            Returns the name of the technology that this compiler targets. i.e. "ORACLE", "RecordModel"
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.Compiler.Target">
            <summary>
            Returns type of target that this instance produces output for
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.Compiler.Schema">
            <summary>
            Returns source schema
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.Compiler.HasCompiled">
            <summary>
            Returns true to indicate that compiler has already processed the source schema
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.Compiler.CompileException">
            <summary>
            Returns exception that surfaced during compilation, or null if source has not compiled yet or no exception happened.
            This exception is different form CompileErrors because it indicates some un=planned condition that broke the compilation process
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.Compiler.CompileErrors">
            <summary>
            Returns exception errors that were generated during compilation. This property returns "planned" errors that were caused by input,
             whereas CompileException returns exception that indicates some more drastic abnormality that broke the compilation
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.Compiler.HasErrors">
            <summary>
            Returns true when this instance did not compile properly
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.Compiler.CaseSensitiveNames">
            <summary>
            Determines whether output script is case sensitive
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.Compiler.NameComparison">
            <summary>
            Returns string comparison options for names that depend on target case sensitivity
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.Compiler.OutputPath">
            <summary>
            Determines where compiled output is placed
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.Compiler.OutputPrefix">
            <summary>
            Determines the prefix for output names
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.Compiler.Outputs.CurrentOrUnspecified">
            <summary>
            Returns last output used or Unspecified output
            </summary>
        </member>
        <member name="T:NFX.RelationalModel.MsSQLServerCompiler">
            <summary>
            Compiles relation schema into Ms SQL Server scripts
            </summary>
        </member>
        <member name="T:NFX.RelationalModel.RDBMSCompiler">
            <summary>
            Compiles schema scripts into RDBMS-family of outputs - the ones that have tables, keys, indexes, constraints etc...
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.RDBMSCompiler.CreateDomain(System.String,System.String,NFX.Environment.IConfigNode)">
            <summary>
            Turns domain name into domain instance
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.RDBMSCompiler.TransformEntityName(NFX.RelationalModel.RDBMSEntity)">
            <summary>
            Override to map a name from schema into the name that should be used in the output (i.e. real table name)
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.RDBMSCompiler.GetQuotedIdentifierName(NFX.RelationalModel.RDBMSEntityType,System.String)">
            <summary>
            Gets quoted name per particular technology
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.RDBMSCompiler.GetStatementDelimiterScript(NFX.RelationalModel.RDBMSEntityType,System.Boolean)">
            <summary>
            Override to return statement delimiter script for particular target , i.e. "Go" at the statementend for MsSQL Server T-SQL
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.RDBMSCompiler.DoTable(NFX.Environment.IConfigSectionNode,NFX.RelationalModel.Compiler.Outputs)">
            <summary>
            Override to compile a RDBMS Table
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.RDBMSCompiler.DoTableIndexes(NFX.RelationalModel.RDBMSEntity,NFX.RelationalModel.Compiler.Outputs)">
            <summary>
            Override to compile a indexes per table
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.RDBMSCompiler.DoColumn(NFX.Environment.IConfigSectionNode,NFX.RelationalModel.RDBMSEntity,System.Text.StringBuilder,System.Boolean@,NFX.RelationalModel.Compiler.Outputs)">
            <summary>
            Override to compile a RDBMS Table
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.RDBMSCompiler.DoReadPrimaryKeySection(NFX.Environment.IConfigSectionNode,NFX.RelationalModel.RDBMSEntity)">
            <summary>
            Override to read primary key definition form sub-section of table (not column level)
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.RDBMSCompiler.DoPrimaryKeys(NFX.RelationalModel.RDBMSEntity,System.Text.StringBuilder,System.Boolean@)">
            <summary>
            Override to output primary keys
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.RDBMSCompiler.DoForeignKeys(NFX.RelationalModel.RDBMSEntity,System.Text.StringBuilder,System.Boolean@,NFX.RelationalModel.Compiler.Outputs)">
            <summary>
            Override to outpur foreign keys
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.RDBMSCompiler.DoReadIndexSection(NFX.Environment.IConfigSectionNode,NFX.RelationalModel.RDBMSEntity)">
            <summary>
            Override to read primary key definition form sub-section of table (not column level)
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.RDBMSCompiler.DomainSearchPaths">
            <summary>
            Gets/sets ';' separated list of domain search namespaces paths
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.RDBMSCompiler.SeparateIndexes">
            <summary>
            Gets/sets the flag that indicates whether indexes should be written in the separate output from tables
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.RDBMSCompiler.SeparateForeignKeys">
            <summary>
            Gets/sets the flag that indicates whether foreign keys should be written in the separate output from tables.
            Foreign keys get added as constraints under the table when referenced table is already present and this flag is false
            </summary>
        </member>
        <member name="T:NFX.RelationalModel.DataTypes.Domain">
            <summary>
            Represents a domain - a named type 
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.DataTypes.Domain.Name">
            <summary>
            Returns the name of this domain, i.e. 'THumanAge', 'TSalary'
            </summary>
        </member>
        <member name="T:NFX.RelationalModel.DataTypes.RDBMSDomain">
            <summary>
            Represents a domain - named type with optional constraints/checks for permitted values
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.DataTypes.RDBMSDomain.GetTypeName(NFX.RelationalModel.RDBMSCompiler)">
            <summary>
            Returns the name of the resulting type that this domain maps to
            </summary>
            <param name="compiler">The context that the result depends on </param>
            <returns>Target type name, i.e. BIGINT, DECIMAL(8,2) etc...</returns>
        </member>
        <member name="M:NFX.RelationalModel.DataTypes.RDBMSDomain.GetColumnRequirement(NFX.RelationalModel.RDBMSCompiler)">
            <summary>
            Returns true to indicate that column of this type is always required
            </summary>
            <param name="compiler">The context that the result depends on </param>
        </member>
        <member name="M:NFX.RelationalModel.DataTypes.RDBMSDomain.TransformColumnName(NFX.RelationalModel.RDBMSCompiler,NFX.RelationalModel.RDBMSEntity)">
            <summary>
            Changes column name, i.e. adds prefix
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.DataTypes.RDBMSDomain.GetColumnAutoGeneratedScript(NFX.RelationalModel.RDBMSCompiler,NFX.RelationalModel.RDBMSEntity,NFX.RelationalModel.Compiler.Outputs)">
            <summary>
            Returns script for auto-generated values, may also emit compiler-specific object like sequence or generator
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.DataTypes.RDBMSDomain.GetColumnDefaultScript(NFX.RelationalModel.RDBMSCompiler,NFX.RelationalModel.RDBMSEntity,NFX.RelationalModel.Compiler.Outputs)">
            <summary>
            Returns script for default values, may also emit compiler-specific object like sequence or generator or insert rows in some other table
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.DataTypes.RDBMSDomain.GetColumnCheckScript(NFX.RelationalModel.RDBMSCompiler,NFX.RelationalModel.RDBMSEntity,NFX.RelationalModel.Compiler.Outputs)">
            <summary>
            Returns script for check constraint on column level
            </summary>
        </member>
        <member name="T:NFX.RelationalModel.RelationalException">
            <summary>
            Base exception thrown by the Relational-* framework
            </summary>
        </member>
        <member name="T:NFX.RelationalModel.SchemaException">
            <summary>
            Thrown by relational schema
            </summary>
        </member>
        <member name="T:NFX.RelationalModel.CompilerException">
            <summary>
            Thrown by relational schema compiler
            </summary>
        </member>
        <member name="T:NFX.RelationalModel.SchemaCompilationException">
            <summary>
            Thrown by relational schema compiler while processing the source schema
            </summary>
        </member>
        <member name="F:NFX.RelationalModel.SchemaCompilationException.NodePath">
            <summary>
            Returns node that issued compilation error
            </summary>
        </member>
        <member name="T:NFX.RelationalModel.MySQLCompiler">
            <summary>
            Compiles relation schema into MySQL scripts
            </summary>
        </member>
        <member name="T:NFX.RelationalModel.RDBMSEntityType">
            <summary>
            Denotes a type of RDBMS entity
            </summary>
        </member>
        <member name="T:NFX.RelationalModel.Schema">
            <summary>
            Represents an instance of relational schema source
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.Schema.SourceScriptRunner">
            <summary>
            Returns script runner used for schema source evaluation. Null returned when no scripts were executed
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.Schema.SourceOriginal">
            <summary>
            Returns the source root tree before script was run but all includes processed
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.Schema.Source">
            <summary>
            Returns the source root tree after includes were processed and script was run
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.Schema.IncludePaths">
            <summary>
            Returns include paths that are searched for included files
            </summary>
        </member>
        <member name="T:NFX.Scope">
            <summary>
            Helper class to be used in the context of 'using' clause to
            facilitate cleanup on scope exit and performing of other functions
            such as status logging
            </summary>
            <remarks>
            Typical use case:
            <code>
              using(Scope.OnExit(() => Bell.Ring()))
              {
                 ... do something ...
              }
              
              using(Scope.OnExit&lt;bool>(
                            ()  => { var old = Tracing.IsOn; Tracing.Off(); return old; },
                            (b) => Tracing.State(b)))
              {
                 ... do something ...
              }
            </code>
            </remarks>
        </member>
        <member name="T:NFX.EmbeddedResource">
            <summary>
             Fetches resources such as script statement text by scriptName from assembly resource stream.
             Mostly used for SQL and JavaScript but maybe used for any text retrieval. 
             This class is 100% safe for multithreading operations. 
             Script texts are cached in ram for faster subsequent access.
            </summary>
        </member>
        <member name="M:NFX.EmbeddedResource.GetText(System.Type,System.String)">
            <summary>
            Pass a type and resource path rooted at type's namespace, for example
             given <code> string sql = typeof(SomeType).GetText("SQL.User.Insert.sql");</code>
             If "SomeType" is declared in "TestApp.Types", then statement's resource will have to be embedded under resource named: 
              "TestApp.Types.SQL.User.Insert.sql"
            </summary>
        </member>
        <member name="M:NFX.EmbeddedResource.GetBinaryStream(System.Type,System.String)">
            <summary>
            Pass a type and resource path rooted at type's namespace, for example
             given <code> using (var stream = typeof(SomeType).GetBinary("My.Picture.gif")){...}</code>
             If "SomeType" is declared in "TestApp.Types", then statement's resource will have to be embedded under resource named: 
              "TestApp.Types.My.Picture.gif"
            </summary>
        </member>
        <member name="T:NFX.DisposedObjectException">
            <summary>
            This exception is thrown from DisposableObject.EnsureObjectNotDisposed() method
            </summary>
        </member>
        <member name="T:NFX.Environment.BuildInformation">
            <summary>
            Retrieves build information encapsulated into a module in the form of an embedded resource
            </summary>
        </member>
        <member name="M:NFX.Environment.BuildInformation.#ctor">
            <summary>
            Creates an instance of BuildInformation class for framework
            </summary>
        </member>
        <member name="M:NFX.Environment.BuildInformation.#ctor(System.Reflection.Assembly,System.String,System.Boolean)">
            <summary>
            Creates and instance of BuildInformation class from the specified resource path in particular assembly.
            If assembly is null then BuildInformation for the whole framework is returned.
            If Path is null then the first found BUILD info resource is used form the specified assembly
            </summary>
        </member>
        <member name="P:NFX.Environment.BuildInformation.ForFramework">
            <summary>
            Return framework build information
            </summary>
        </member>
        <member name="P:NFX.Environment.BuildInformation.AssemblyName">
            <summary>
            Rertuns assembly name that this information was obtained from
            </summary>
        </member>
        <member name="P:NFX.Environment.BuildInformation.BuildSeed">
            <summary>
            Returns random number assigned to a build. It is NOT guaranteed to be unique
            </summary>
        </member>
        <member name="P:NFX.Environment.BuildInformation.Computer">
            <summary>
            A name of the computer that performed build
            </summary>
        </member>
        <member name="P:NFX.Environment.BuildInformation.User">
            <summary>
            a name of user that build session was logged under
            </summary>
        </member>
        <member name="P:NFX.Environment.BuildInformation.OS">
            <summary>
            OS name
            </summary>
        </member>
        <member name="P:NFX.Environment.BuildInformation.DateStamp">
            <summary>
            Date and time stamp when build was performed
            </summary>
        </member>
        <member name="T:NFX.Environment.CommandArgsConfiguration">
            <summary>
            Provides implementation of configuration based on arguments supplied from command line
             which is "string[]". Arguments start with either "/" or "-" prefix. If any argument is not 
             prefixed then it is written as an auto-named attribute node of the root with its value set, otherwise a section (under root) with
              argument's name is created. Any argument may have options. Any option may either consist of name
               or name value pair delimited by "=".
             Argument options are written as attribute nodes of their corresponding sections.
             If option value specified without name (without "=") then option is auto-named
            </summary>
            <example>
             Given command line:
              <code>
              c:\>dosomething.exe "c:\input.file" "d:\output.file" -compress level=100 method=zip -shadow fast -large
              </code>
             The following configuration object will be created from the supplied args:  
             <code>
               [args ?1="c:\input.file" ?2="c:\output.file"]
                 [compress level="100" method="zip"]
                 [shadow ?1="fast"]
                 [large]
             </code>  
             
             Use args:
             <code>
              var conf = new CmdArgsConfiguration(args);
              var inFile = conf.Root.AttrByIndex(0).ValueAsString(DEFAULT_INPUT_FILE);
              var outFile = conf.Root.AttrByIndex(1).ValueAsString(DEFAULT_OUTPUT_FILE);
              .....
               if (conf.Root["large"].Exists) .......
              .....
              var level = conf.Root["compress"].AttrByName("level").ValueAsInt(DEFAULT_COMPRESSION_LEVEL);
              .....
             </code> 
            
            </example>
        </member>
        <member name="M:NFX.Environment.CommandArgsConfiguration.#ctor(System.String[])">
            <summary>
            Creates an instance of the new configuration parsed from command line arguments
            </summary>
        </member>
        <member name="P:NFX.Environment.CommandArgsConfiguration.IsReadOnly">
            <summary>
            Indicates whether configuration is readonly or may be modified and saved
            </summary>
        </member>
        <member name="P:NFX.Environment.CommandArgsConfiguration.Arguments">
            <summary>
            Returns arguments array that this configuration was parsed from
            </summary>
        </member>
        <member name="T:NFX.Environment.ConfigNode">
            <summary>
            Provides configuration node abstraction for section and attribute nodes. This class is thread-safe
            </summary>
        </member>
        <member name="T:NFX.Environment.IConfigNode">
            <summary>
            Provides read-only configuration node abstraction for section and attribute nodes
            </summary>
        </member>
        <member name="M:NFX.Environment.IConfigNode.ValueAsType(System.Type,System.Boolean,System.Boolean)">
            <summary>
            Tries to get value as specified type or throws if it can not be converted
            </summary>
        </member>
        <member name="M:NFX.Environment.IConfigNode.IsSameName(NFX.Environment.IConfigNode)">
            <summary>
            Returns true when another node has the same name as this one
            </summary>
        </member>
        <member name="M:NFX.Environment.IConfigNode.IsSameName(System.String)">
            <summary>
            Returns true when another name is the same as this node's name
            </summary>
        </member>
        <member name="P:NFX.Environment.IConfigNode.Configuration">
            <summary>
            References configuration this node is under
            </summary>
        </member>
        <member name="P:NFX.Environment.IConfigNode.Exists">
            <summary>
            Determines whether this node really exists in configuration or is just a sentinel empty node
            </summary>
        </member>
        <member name="P:NFX.Environment.IConfigNode.VerbatimValue">
            <summary>
            Returns varbatim (without variable evaluation) node value or null
            </summary>
        </member>
        <member name="P:NFX.Environment.IConfigNode.EvaluatedValue">
            <summary>
            Returns null or value of this node with all variables evaluated
            </summary>
        </member>
        <member name="P:NFX.Environment.IConfigNode.Value">
            <summary>
            Returns null or value of this node with all variables evaluated
            </summary>
        </member>
        <member name="P:NFX.Environment.IConfigNode.Parent">
            <summary>
            References parent node or empty node if this is the top-most node with no parent
            </summary>
        </member>
        <member name="P:NFX.Environment.IConfigNode.RootPath">
            <summary>
            Returns a path from root to this node
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigNode.#ctor(NFX.Environment.Configuration,NFX.Environment.ConfigSectionNode,NFX.Environment.IConfigNode)">
            <summary>
            Creates new node by cloning other node from this or another configuration
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigNode.ResetModified">
            <summary>
            Resets modification flag
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigNode.ValueAsType(System.Type,System.Boolean,System.Boolean)">
            <summary>
            Tries to get value as specified type or throws if it can not be converted
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigNode.IsSameName(NFX.Environment.IConfigNode)">
            <summary>
            Returns true when another node has the same name as this one per case-insensitive culture-neutral comparison
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigNode.IsSameName(System.String)">
            <summary>
            Returns true when another name is the same as this node's name per case-insensitive culture-neutral comparison
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigNode.Configuration">
            <summary>
            References configuration this node is under
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigNode.Exists">
            <summary>
            Determines whether this node really exists in configuration or is just a sentinel empty node
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigNode.Name">
            <summary>
            Retrieves node name
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigNode.VerbatimValue">
            <summary>
            Returns verbatim (without variable evaluation) node value or null
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigNode.EvaluatedValue">
            <summary>
            Returns null or value of this node with all variables evaluated
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigNode.Value">
            <summary>
            Retrieves node value or null. The value getter performs evaluation of variables, while setter sets the value verbatim
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigNode.Parent">
            <summary>
            References parent node or Empty if this node has no parent
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigNode.NFX#Environment#IConfigNode#Parent">
            <summary>
            References parent node
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigNode.Modified">
            <summary>
            Indicates whether a node was modified
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigNode.RootPath">
            <summary>
            Returns path from root to this node
            </summary>
        </member>
        <member name="T:NFX.Environment.ConfigSectionNode">
            <summary>
            Represents configuration section node. This class is thread safe
            </summary>
        </member>
        <member name="T:NFX.Environment.IConfigSectionNode">
            <summary>
            Provides read-only configuration section node abstraction
            </summary>
        </member>
        <member name="M:NFX.Environment.IConfigSectionNode.AttrByName(System.String,System.Boolean)">
            <summary>
            Returns attribute node by its name or empty attribute if real attribute with such name does not exist
            </summary>
        </member>
        <member name="M:NFX.Environment.IConfigSectionNode.AttrByIndex(System.Int32)">
            <summary>
            Returns attribute node by its index or empty attribute if real attribute with such index does not exist
            </summary>
        </member>
        <member name="M:NFX.Environment.IConfigSectionNode.Navigate(System.String)">
            <summary>
            Navigates the path and return the appropriate node. Example '!/nfx/logger/destination/$file-name'
            </summary>
            <param name="path">If path starts from '!' then exception will be thrown if such a node does not exist;
             Use '/' as leading char for root, 
             '..' for step up,
             '$' for attribute name. Multiple paths may be coalesced using '|' or ';'
            </param>
        </member>
        <member name="M:NFX.Environment.IConfigSectionNode.NavigateSection(System.String)">
            <summary>
            Navigates the path and return the appropriate section node. Example '!/nfx/logger/destination'
            </summary>
            <param name="path">If path starts from '!' then exception will be thrown if such a section node does not exist;
             Use '/' as leading char for root, 
             '..' for step up. Multiple paths may be coalesced using '|' or ';'
            </param>
        </member>
        <member name="M:NFX.Environment.IConfigSectionNode.EvaluateValueVariables(System.String)">
            <summary>
            Evaluates a value string expanding all variables with var-paths relative to this node.
            Evaluates configuration variables such as "$(varname)" or "$(@varname)". Varnames are paths
            to other config nodes from the same configuration or variable names when prefixed with "~". If varname starts with "@" then it gets combined 
             with input as path string. "~" is used to qualify environment vars that get resolved through Configuration.EnvironmentVarResolver
             Example: `....add key="Schema.$(/A/B/C/$attr)" value="$(@~HOME)bin\Transforms\"...`
            </summary>
        </member>
        <member name="M:NFX.Environment.IConfigSectionNode.IsSameNameAttr(NFX.Environment.IConfigSectionNode)">
            <summary>
            Returns true when this and another nodes both have attribute "name" and their values are equal per case-insensitive culture-neutral comparison
            </summary>
        </member>
        <member name="M:NFX.Environment.IConfigSectionNode.IsSameNameAttr(System.String)">
            <summary>
            Returns true when this node has an attribute called "name" and its value is euqal to the supplied value per case-insensitive culture-neutral comparison
            </summary>
        </member>
        <member name="M:NFX.Environment.IConfigSectionNode.ToLaconicString(NFX.CodeAnalysis.Laconfig.LaconfigWritingOptions)">
            <summary>
            Serializes configuration tree rooted at this node into Laconic format and returns it as a string
            </summary>
        </member>
        <member name="M:NFX.Environment.IConfigSectionNode.ToJSONDataMap">
            <summary>
            Converts this IConfigSectionNode to JSONDataMap.
            Be carefull: that this operation can "loose" data from IConfigSectionNode.
            In other words some IConfigSectionNode information can not be reflected in corresponding JSONDataMap
            </summary>
        </member>
        <member name="P:NFX.Environment.IConfigSectionNode.HasChildren">
            <summary>
            Indicates whether this node has any child section nodes 
            </summary>
        </member>
        <member name="P:NFX.Environment.IConfigSectionNode.HasAttributes">
            <summary>
            Indicates whether this node has any associated attributes 
            </summary>
        </member>
        <member name="P:NFX.Environment.IConfigSectionNode.Children">
            <summary>
            Enumerates all child nodes
            </summary>
        </member>
        <member name="P:NFX.Environment.IConfigSectionNode.Attributes">
            <summary>
            Enumerates all attribute nodes
            </summary>
        </member>
        <member name="P:NFX.Environment.IConfigSectionNode.Item(System.String[])">
            <summary>
            Retrieves section node by names, from left to right until existing node is found.
            If no existing node could be found then empty node instance is returned
            </summary>
        </member>
        <member name="P:NFX.Environment.IConfigSectionNode.Item(System.Int32)">
            <summary>
            Retrieves section node by index or empty node instance if section node with such index could not be found
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.#ctor(NFX.Environment.Configuration,NFX.Environment.ConfigSectionNode,NFX.Environment.IConfigSectionNode)">
            <summary>
            Performs deep clone copy from another node which can be in this or different configuration
            </summary>
        </member>
        <member name="F:NFX.Environment.ConfigSectionNode.m_Script_Statement">
            <summary>
            Internal field used for attaching temporary script state. do not use
            </summary>
        </member>
        <member name="F:NFX.Environment.ConfigSectionNode.m_Script_Bool_Condition_Result">
            <summary>
            Internal field used for attaching temporary script state. do not use
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.Delete">
            <summary>
            Deletes this section from its parent
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.DeleteAllChildren">
            <summary>
            Deletes all child section nodes from this node
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.DeleteAllAttributes">
            <summary>
            Deletes all attribute nodes from this node
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.AddChildNode(System.String,System.String)">
            <summary>
            Adds a new child section node to this node
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.AddChildNode(NFX.Environment.IConfigSectionNode)">
            <summary>
            Adds a new child node into this one deeply cloning nodes data from some other node which may belong to a different conf instance
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.AddChildNodeFromMerge(NFX.Environment.IConfigSectionNode,NFX.Environment.IConfigSectionNode,NFX.Environment.NodeOverrideRules)">
            <summary>
            Adds a new section node to this configuration which is an ordered merge result of two other nodes - base and override.
            </summary>
            <param name="baseNode">A base node that data is defaulted from</param>
            <param name="overrideNode">A node that contains overrides/additions of/to data from base node</param>
            <param name="rules">Rules to use for this merge. Default rules will be used if null is passed</param>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.OverrideBy(NFX.Environment.IConfigSectionNode,NFX.Environment.NodeOverrideRules)">
            <summary>
            Merges another node data by overriding this node's value/attributes/sub nodes according to rules.
            </summary>
            <returns>True when merge match was made</returns>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.MergeAttributes(NFX.Environment.IConfigSectionNode,NFX.Environment.NodeOverrideRules)">
            <summary>
            Merges attributes from another node into this one. Another node may belong to a different configuration instance
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.MergeSections(NFX.Environment.IConfigSectionNode,NFX.Environment.NodeOverrideRules)">
            <summary>
            Merges child sections from another node into this one. Another node may belong to a different configuration instance.
            This method ignores override flags and merges nodes regardless
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.ReplaceBy(NFX.Environment.IConfigSectionNode)">
            <summary>
            Completely replaces this node's attributes, value and children with data from another node
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.AttrByIndex(System.Int32)">
            <summary>
            Returns attribute node by its index or empty attribute if real attribute with such index does not exist
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.ResetModified">
            <summary>
            Resets modification of this an all child nodes
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.Navigate(System.String)">
            <summary>
            Navigates the path and return the appropriate node. Example: '!/nfx/logger/destination/$file-name'
            </summary>
            <param name="path">If path starts from '!' then exception will be thrown if such a node does not exist;
             Use '/' as leading char for root, 
             '..' for step up,
             '$' for attribute name,
             [int] for access to subsection or attribute by index,
             section[value] for access using value comparison of named section,
             section[attr=value] for access using value of sections named attr
            Multiple paths may be coalesced using '|' or ';' 
            </param>
            <example>
                Navigate("/vars/[3]"); Navigate("/tables/table[resident]"); Navigate("/vars/var1/$[2]");  Navigate("/tables/table[name=patient]");
            </example>
            <remarks>
              /table[patient]    -   get first section named "table" with value "patient"
              /[3]               -   get 4th child section from the root
              /table/$[2]        -   get 3rd attribute of first section named "table"
              /table[short-name=pat] -  get first section named "table" having attribute named "short-name" equal "pat"
            </remarks>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.NavigateSection(System.String)">
            <summary>
            Navigates the path and return the appropriate section node. Example '!/nfx/logger/destination'
            </summary>
            <param name="path">If path starts from '!' then exception will be thrown if such a section node does not exist;
             Use '/' as leading char for root, 
             '..' for step up. Multiple paths may be coalesced using '|' or ';'
            </param>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.EvaluateValueVariables(System.String)">
            <summary>
            Evaluates a value string expanding all variables with var-paths relative to this node.
            Evaluates configuration variables such as "$(varname)" or "$(@varname)". Varnames are paths
            to other config nodes from the same configuration or variable names when prefixed with "~". If varname starts with "@" then it gets combined 
             with input as path string. "~" is used to qualify environment vars that get resolved through Configuration.EnvironmentVarResolver
             Example: `....add key="Schema.$(/A/B/C/$attr)" value="$(@~HOME)bin\Transforms\"...`
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.IsSameNameAttr(NFX.Environment.IConfigSectionNode)">
            <summary>
            Returns true when another node has the attribute called 'name' and its value is the same as in this one per case-insensitive culture-neutral comparison
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.IsSameNameAttr(System.String)">
            <summary>
            Returns true when another name is the same as this section "name" attribute per case-insensitive culture-neutral comparison
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.ToLaconicString(NFX.CodeAnalysis.Laconfig.LaconfigWritingOptions)">
            <summary>
            Serializes configuration tree rooted at this node into Laconic format and returns it as a string
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.ProcessIncludePragmas(System.Boolean,System.String)">
            <summary>
            Replaces all include pragmas - sections with specified names ('_include' by default), with pointed to configuration file content
            as obtained via the call to file system specified in every pragma.
            If no FS specified then LocalFileStsrem is used. Returns true if include pragmas were found.
            Note: this method does not process new include pragmas that may have fetched during this call.
            Caution: the file system used in the operation may rely on the App container that may need to be set-up for the call to succeed,
            therefore calling this method before app has activated may fail, in such cases a temp app container may be set to get the config file
             with processed includes, then the result may be passed to the primary app container ctor.
            This call is not logically thread-safe, it must be called from the main thread in the app
            </summary>
            <param name="recurse">True to process inner nodes</param>
            <param name="includePragma">Pragma section name, '_include' by default</param>
            <returns>True if pragmas were found</returns>
            <example>
             nfx
             {
               sectionA{ a=2 b=3}
               _include
               {
                 name=secret // '_include' will be replaced by 'secret' with sub-nodes from referenced file     
                 file="/etc/cluster/mysecret.laconf" //would come from local FS
                 required=false //if file is not found then nothing will be included instead of '_include' which will be just removed
               }
               _include
               {
                 // '_include' will be replaced by whatever root section content in the referenced file
                 fs {type="NFX.Web.IO.FileSystem.SVNFileSystem, NFX.Web"}
                 session { server-url="https://myhost.com/mySvnRepo/trunk/configs" user-name="user1" user-password="******"}
               }
             }
            </example>      
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.ToJSONDataMap">
            <summary>
            Converts this ConfigSectionNode to JSONDataMap.
            Be carefull: that this operation can "loose" data from ConfigSectionNode.
            In other words some ConfigSectionNode information can not be reflected in corresponding JSONDataMap
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigSectionNode.HasChildren">
            <summary>
            Indicates whether this node has any child section nodes 
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigSectionNode.HasAttributes">
            <summary>
            Indicates whether this node has any associated attributes
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigSectionNode.Modified">
            <summary>
            Indicates whether this or any child nodes or attributes were modified
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigSectionNode.Children">
            <summary>
            Enumerates all child nodes
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigSectionNode.Attributes">
            <summary>
            Enumerates all attribute nodes
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigSectionNode.Item(System.String[])">
            <summary>
            Retrieves section node by names, from left to right until existing node is found.
            If no existing node could be found then empty node instance is returned
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigSectionNode.Item(System.Int32)">
            <summary>
            Retrieves section node by index or empty node instance if section node with such index could not be found
            </summary>
        </member>
        <member name="T:NFX.Environment.ConfigAttrNode">
            <summary>
            Represents an attribute of a attribute node
            </summary>
        </member>
        <member name="T:NFX.Environment.IConfigAttrNode">
            <summary>
            Represents a read-only attribute of a attribute node
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigAttrNode.Delete">
            <summary>
            Deletes this attribute from its parent
            </summary>
        </member>
        <member name="T:NFX.Environment.FactoryUtils">
            <summary>
            Provides helper methods for dynamic object creation and configuration
            </summary>
        </member>
        <member name="M:NFX.Environment.FactoryUtils.MakeAndConfigure(NFX.Environment.IConfigSectionNode,System.Type,System.Object[])">
            <summary>
            Creates and configures an instance of appropriate configurable object as specified in supplied config node.
            Applies configured behaviours
            </summary>
        </member>
        <member name="M:NFX.Environment.FactoryUtils.MakeAndConfigure``1(NFX.Environment.IConfigSectionNode,System.Type,System.Object[])">
            <summary>
            Creates and configures an instance of appropriate configurable object as specified in supplied config node.
            Applies configured behaviours
            </summary>
        </member>
        <member name="M:NFX.Environment.FactoryUtils.Make``1(NFX.Environment.IConfigSectionNode,System.Type,System.Object[])">
            <summary>
            Creates an instance of appropriate configurable object as specified in supplied config node.
            This function does not configure the instance
            </summary>
        </member>
        <member name="M:NFX.Environment.FactoryUtils.MakeUsingCtor``1(NFX.Environment.IConfigSectionNode)">
            <summary>
            Invokes a constructor for type feeding it the specified args: 
             node{type="NS.Type, Assembly" arg0=1 arg1=true....}
            </summary>
        </member>
        <member name="T:NFX.Environment.IConfigSettings">
            <summary>
            Represents an entity that provides a type-safe access to configuration settings that come from Configuration nodes.
            This class obviates the need for navigation between config nodes on every property get and facilitates faster access to some config parameters
            that need to be gotten efficiently, as they are now kept cached in RAM in native format (i.e. DateTime vs. string) as fields.
            Usually classes that implement this interface are singleton and they get registered with the application using IApplication.RegisterConfigSettings()
            method. Warning: the implementation must be thread-safe and allow property getters to keep reading while ConfigChanged() notification happens
            </summary>
        </member>
        <member name="M:NFX.Environment.IConfigSettings.ConfigChanged(NFX.Environment.IConfigSectionNode)">
            <summary>
            Notifies the implementer that underlying source configuration has changed and memory-resident 
            fields need to be re-read from config nodes. Usually this method is called by application container
             when instance of this class has been registered with the application using IApplication.RegisterConfigSettings().
            Warning: the implementation must be thread-safe and allow getters to keep reading while notification happens 
            </summary>
            <param name="atNode">
            Passes the most top-level node that covers all of the changes that happened in the source config system.
            Usually this is a root config node. The capability of source config change detection on node level is not supported by all providers
            </param>
        </member>
        <member name="T:NFX.Environment.MemoryConfiguration">
            <summary>
            Implements configuration that can not be persisted/loaded anywhere - just stored in memory
            </summary>
        </member>
        <member name="T:NFX.Environment.XMLConfiguration">
            <summary>
            Provides implementation of configuration based on a classic XML content
            </summary>
        </member>
        <member name="M:NFX.Environment.XMLConfiguration.#ctor">
            <summary>
            Creates an instance of a new configuration not bound to any XML file
            </summary>
        </member>
        <member name="M:NFX.Environment.XMLConfiguration.#ctor(System.String)">
            <summary>
            Creates an isntance of the new configuration and reads contents from an XML file
            </summary>
        </member>
        <member name="M:NFX.Environment.XMLConfiguration.CreateFromXML(System.String)">
            <summary>
            Creates an instance of configuration initialized from XML content passed as string
            </summary>
        </member>
        <member name="M:NFX.Environment.XMLConfiguration.SaveAs(System.String)">
            <summary>
            Saves configuration into a file
            </summary>
        </member>
        <member name="M:NFX.Environment.XMLConfiguration.SaveAs(System.String,System.String)">
            <summary>
            Saves configuration to a file with optional link to XSL file
            </summary>
        </member>
        <member name="M:NFX.Environment.XMLConfiguration.SaveToString(System.String)">
            <summary>
            Saves XML configuration with optional link to XSL file, into string and returns it
            </summary>
        </member>
        <member name="T:NFX.Financial.TimeValue">
            <summary>
            Implements time value financial functions such as: PV, NPV, IRR
            </summary>
        </member>
        <member name="M:NFX.Financial.TimeValue.PV(System.Double,System.Double,System.Int32)">
            <summary>
            Returns present value of amount returned in X number of periods
            at a certain interest rate
            </summary>
            <param name="fv">Future value (returned amount in X periods)</param>
            <param name="intRate">Interest rate per period</param>
            <param name="periods">Period length</param>
            <returns>Present Value</returns>
            <example> 
            Assume that A gives $100 cash to B. B returns the same amount to A in 1 year.
            Banks give 5% annual rate, therefore present value of this $100 dollar 
            returned is going to be $95.24 - A lost $4.76, because B did not pay any interest and 
             A could have deposited $100 in regular bank instead of giving it to B.
            Had A charged B 5% interest rate , A would have made money.
            </example>
        </member>
        <member name="M:NFX.Financial.TimeValue.FV(System.Double,System.Double,System.Int32)">
            <summary>
            Returns future value of presently-valued amount in X number of periods
            at a certain interest rate 
            </summary>
            <param name="pv">Present value</param>
            <param name="intRate">Interest rate</param>
            <param name="periods">Period length</param>
            <returns>Future value</returns>
            <example>
            $100 loaned for 1 period at 5% interest per period have future value of $105;
            same amount loaned for 10 periods at the same rate would have future value of $162.89
            </example>
        </member>
        <member name="M:NFX.Financial.TimeValue.NPV(System.Collections.Generic.IEnumerable{System.Double},System.Double)">
            <summary>
            Returns a net present value calculated over series of cashflows
            </summary>
            <param name="cashFlows">A series of net cashflows per period(supplied as a summ of inflows and outflows), usually the first cashflow is an outflow of initial project investment</param>
            <param name="discountRate">Interest rate used for net cashflow discount</param>
            <returns>Net present value</returns>
        </member>
        <member name="M:NFX.Financial.TimeValue.IRR(System.Collections.Generic.IEnumerable{System.Double},System.Double)">
            <summary>
            Calculates the internal rate of return over series of cash flows 
            </summary>
        </member>
        <member name="M:NFX.Financial.TimeValue.IRR(System.Double[],System.Double)">
            <summary>
            Calculates the internal rate of return over series of cash flows 
            </summary>
        </member>
        <member name="T:NFX.Geometry.MapDirection">
            <summary>
            Map direction enumeration aka. North, South, East, etc...
            </summary>
        </member>
        <member name="F:NFX.Geometry.CartesianUtils.PI_DEGREES">
            <summary>
            Represents count of degrees in PI
            </summary>
        </member>
        <member name="F:NFX.Geometry.CartesianUtils.PI2">
            <summary>
            Pi*2 constant
            </summary>
        </member>
        <member name="F:NFX.Geometry.CartesianUtils.PI_HALF">
            <summary>
            Pi/2 constant
            </summary>
        </member>
        <member name="M:NFX.Geometry.CartesianUtils.ToRad(System.Double)">
            <summary>
            Converts degrees into radians
            </summary>
        </member>
        <member name="M:NFX.Geometry.CartesianUtils.ToDeg(System.Double)">
            <summary>
            Converts radians into degrees
            </summary>
        </member>
        <member name="M:NFX.Geometry.CartesianUtils.Distance(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculates distance between two points
            </summary>
        </member>
        <member name="M:NFX.Geometry.CartesianUtils.Distance(System.Drawing.Point,System.Drawing.Point)">
            <summary>
            Calculates distance between two points
            </summary>
        </member>
        <member name="M:NFX.Geometry.CartesianUtils.Distance(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Calculates distance between two points
            </summary>
        </member>
        <member name="M:NFX.Geometry.CartesianUtils.Distance(System.Drawing.PointF,System.Drawing.PointF)">
            <summary>
            Calculates distance between two points
            </summary>
        </member>
        <member name="M:NFX.Geometry.CartesianUtils.AzimuthRad(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculates azimuth for vector in rads
            </summary>
        </member>
        <member name="M:NFX.Geometry.CartesianUtils.AzimuthDeg(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculates azimuth for vector in degrees
            </summary>
        </member>
        <member name="M:NFX.Geometry.CartesianUtils.AzimuthOfRadix(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculates azimuth for vector in degrees
            </summary>
        </member>
        <member name="M:NFX.Geometry.CartesianUtils.PointToPolarPoint(System.Drawing.Point,System.Drawing.Point)">
            <summary>
            Converts Point to polar coordinate point
            </summary>
        </member>
        <member name="M:NFX.Geometry.CartesianUtils.VectorToPolarPoint(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Converts vector in 'x1, y1, x2, y2' representation to polar coordinate point
            </summary>
        </member>
        <member name="M:NFX.Geometry.CartesianUtils.WrapAngle(System.Double,System.Double)">
            <summary>
            Modifies an angle by delta value ensuring that resulting angle is always between 0 and 2Pi 
            </summary>
        </member>
        <member name="M:NFX.Geometry.CartesianUtils.FindRayFromRectangleCenterSideIntersection(System.Drawing.Rectangle,System.Double)">
            <summary>
            Returns a point of intersection between a ray cast from the center of a rectangle 
             under certain polar coordinate angle and a rectangle side
            </summary>
        </member>
        <member name="M:NFX.Geometry.CartesianUtils.MapDirectionToAngle(NFX.Geometry.MapDirection)">
            <summary>
            Converts map direction to angular coordinate in radians
            </summary>
        </member>
        <member name="M:NFX.Geometry.CartesianUtils.AngleToMapDirection(System.Double)">
            <summary>
            Converts a radian angular coordinate into map direction
            </summary>
        </member>
        <member name="M:NFX.Geometry.CartesianUtils.CalculatePerimeterViolationArea(System.Drawing.Rectangle,System.Drawing.Rectangle)">
            <summary>
            Calculates an area of an inner rectangle that violates outside perimeter
            </summary>
        </member>
        <member name="T:NFX.Geometry.PolarPoint">
            <summary>
            Represents a point with polar coordinates
            </summary>
        </member>
        <member name="M:NFX.Geometry.PolarPoint.#ctor(System.Double,System.Double)">
            <summary>
            Initializes polar coordinates
            </summary>
        </member>
        <member name="M:NFX.Geometry.PolarPoint.#ctor(System.Drawing.Point,System.Drawing.Point)">
            <summary>
            Initializes polar coordinates from 2-d cartesian coordinates
            </summary>
        </member>
        <member name="M:NFX.Geometry.PolarPoint.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes polar coordinates from 2-d cartesian coordinates of 'x1, y1, x2, y2' format
            </summary>
        </member>
        <member name="P:NFX.Geometry.PolarPoint.R">
            <summary>
            R coordinate component which is coordinate distance from point of coordinates origin
            </summary>
        </member>
        <member name="P:NFX.Geometry.PolarPoint.Theta">
            <summary>
            Angular azimuth coordinate component. An angle must be between 0 and 2Pi.
            Note: Due to screen Y coordinate going from top to bottom (in usual orientation)
             Theta angle may be reversed, that is - be positive in the lower half coordinate plane.
            Please refer to:
             http://en.wikipedia.org/wiki/Polar_coordinates
            </summary>
        </member>
        <member name="P:NFX.Geometry.PolarPoint.Point">
            <summary>
            Returns polar coordinate converted to 2-d cartesian coordinates.
            Coordinates are relative to 0,0 of the angle base vertex
            </summary>
        </member>
        <member name="T:NFX.Geometry.VectorUtils">
            <summary>
            Provides helper methods dealing with vector graphics
            </summary>
        </member>
        <member name="M:NFX.Geometry.VectorUtils.VectorizeBalloon(System.Drawing.Rectangle,System.Drawing.Point,System.Double)">
            <summary>
            Calculates callout balloon vertexes suitable for curve drawing
            </summary>
            <param name="body">Balloon body coordinates</param>
            <param name="target">A point of balloon leg attachment</param>
            <param name="legSweep">Length of balloon leg attachment breach at balloon body edge, expressed in radians (arc length). A value such as PI/16 yields good results</param>
            <returns>An array of vertex points</returns>
        </member>
        <member name="M:NFX.Geometry.VectorUtils.InflateBalloon(System.Drawing.Rectangle@,System.Drawing.Point@,System.Int32,System.Int32)">
            <summary>
            Inflates balloon body and target point
            </summary>
        </member>
        <member name="M:NFX.Geometry.VectorUtils.InflateBalloon(System.Drawing.Rectangle@,System.Drawing.Point@,System.Int32)">
            <summary>
            Inflates balloon body and target point
            </summary>
        </member>
        <member name="T:NFX.IO.ErrorHandling.CRC32">
            <summary>
            Implements CRC32 checksum algorithm
            </summary>
        </member>
        <member name="M:NFX.IO.ErrorHandling.CRC32.ForEncodedString(System.String,System.Text.Encoding)">
            <summary>
            Computes CRC32 for string
            </summary>
        </member>
        <member name="M:NFX.IO.ErrorHandling.CRC32.ForString(System.String)">
            <summary>
            Computes CRC32 for binary string representation (in-memory)
            </summary>
        </member>
        <member name="M:NFX.IO.ErrorHandling.CRC32.ForBytes(System.Byte[])">
            <summary>
            Computes CRC32 for byte array
            </summary>
        </member>
        <member name="M:NFX.IO.ErrorHandling.CRC32.Add(System.Int32)">
            <summary>
            Adds integer value into checksum
            </summary>
        </member>
        <member name="M:NFX.IO.ErrorHandling.CRC32.Add(System.Byte[])">
            <summary>
            Adds byte array into checksum
            </summary>
        </member>
        <member name="M:NFX.IO.ErrorHandling.CRC32.Add(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Adds byte array into checksum
            </summary>
        </member>
        <member name="P:NFX.IO.ErrorHandling.CRC32.Value">
            <summary>
            Returns present checksum for the pushed data 
            </summary>
        </member>
        <member name="T:NFX.IO.ConsoleUtils">
            <summary>
            Provides various console-helper utilities
            </summary>
        </member>
        <member name="M:NFX.IO.ConsoleUtils.ReadPassword(System.Char)">
            <summary>
            Reads password from console displaying substitute characters instead of real ones
            </summary>
        </member>
        <member name="M:NFX.IO.ConsoleUtils.WriteMarkupContent(System.String)">
            <summary>
            Outputs colored text from content supplied in an HTML-like grammar:
            </summary>
        </member>
        <member name="M:NFX.IO.ConsoleUtils.WriteMarkupContent(System.String,System.Char,System.Char)">
            <summary>
            Outputs colored text from content supplied in an HTML-like grammar
            </summary>
        </member>
        <member name="M:NFX.IO.ConsoleUtils.Error(System.String,System.Int32)">
            <summary>
            Shows message with colored error header
            </summary>
        </member>
        <member name="M:NFX.IO.ConsoleUtils.Warning(System.String,System.Int32)">
            <summary>
            Shows message with colored warning header
            </summary>
        </member>
        <member name="M:NFX.IO.ConsoleUtils.Info(System.String,System.Int32)">
            <summary>
            Shows message with colored info header
            </summary>
        </member>
        <member name="T:NFX.Log.Destinations.CSVFileDestination">
            <summary>
            Provides a CSV file storage log destination implementation
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.CSVFileDestination.#ctor">
            <summary>
            Creates a new instance of destination that stores log in CSV files
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.CSVFileDestination.#ctor(System.String,System.String)">
            <summary>
            Creates a new instance of destination that stores log in CSV files
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.CSVFileDestination.DoFormatMessage(NFX.Log.Message)">
            <summary>
            Spools instance data in CSV format for storage in a file destination
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.CSVFileDestination.DefaultFileName">
            <summary>
            This is for backward compatibility
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.CSVFileDestination.DefaultLogTimeFormat">
            <summary>
            This is for backward compatibility
            </summary>
        </member>
        <member name="T:NFX.Log.Destinations.MessageFilterHandler">
            <summary>
            Delegate for message filtering
            </summary>
        </member>
        <member name="T:NFX.Log.Destinations.NullDestination">
            <summary>
            Log destination that does not log anything anywhere
            </summary>
        </member>
        <member name="T:NFX.Log.MessageType">
            <summary>
            Stipulates general logging message types like: Info/Warning/Error etc...
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.Debug">
            <summary>
            Used in debugging temp code
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.DebugSQL">
            <summary>
            Emitted by DataStore implementations
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.DebugGlue">
            <summary>
            Emitted by Glue/Net code
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.DebugZ">
            <summary>
            Last debug-related message type for use in debug-related max-level config setting
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.Trace">
            <summary>
            Tracing, no danger to system operation
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.TraceSQL">
            <summary>
            Emitted by DataStore implementations
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.TraceGlue">
            <summary>
            Emitted by Glue/Net code
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.TraceZ">
            <summary>
            Last trace-related message type for use in trace-related max-level config setting
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.PerformanceInstrumentation">
            <summary>
            Performance/Instrumentation-related message
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.Info">
            <summary>
            Informational message, no danger to system operation
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.InfoZ">
            <summary>
            Last info-related message type for use in info-related max-level config setting
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.SecurityAudit">
            <summary>
            Permission audit, usualy a result of client user action, no danger to system operation
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.Notice">
            <summary>
            SYSLOG.Notice Events that are unusual but not error conditions - might be summarized in an email to developers or admins to spot potential problems - no immediate action required.
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.Warning">
            <summary>
            Caution - inspect and take action.
            SYSLOG.Warning, not an error, but indication that an error will occur if action is not taken, e.g. file system 85% full - each item must be resolved within a given time.
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.Error">
            <summary>
            Recoverable error, system will most-likely continue working normally.
            SYSLOG.Error Non-urgent failures, these should be relayed to developers or admins; each item must be resolved within a given time.
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.Critical">
            <summary>
            SYSLOG.Critical Should be corrected immediately, but indicates failure in a primary system, an example is a loss of a backup ISP connection.
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.CriticalAlert">
            <summary>
            SYSLOG.Alert Should be corrected immediately, therefore notify staff who can fix the problem. An example would be the loss of a primary ISP connection.
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.Emergency">
            <summary>
            Unrecoverable error, system  will most-likely experience major operation disruption.
            SYSLOG.Emergency - A "panic" condition usually affecting multiple apps/servers/sites. At this level it would usually notify all tech staff on call.
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.CatastrophicError">
            <summary>
            Unrecoverable error, system  will experience major operation disruption.
            SYSLOG.Emergency - A "panic" condition usually affecting multiple apps/servers/sites. At this level it would usually notify all tech staff on call.
            </summary>
        </member>
        <member name="T:NFX.Log.LogService">
            <summary>
            Provides logging services by buffering messages and dispatching them into destinations.
            This is an asynchronous service, meaning that Write(msg) never blocks for long.
            </summary>
        </member>
        <member name="M:NFX.Log.LogService.#ctor">
            <summary>
            Creates a new logging service instance
            </summary>
        </member>
        <member name="M:NFX.Log.LogService.#ctor(NFX.ServiceModel.Service)">
            <summary>
            Creates a new logging service instance
            </summary>
        </member>
        <member name="M:NFX.Log.LogService.DoWrite(NFX.Log.Message,System.Boolean)">
            <summary>
            Writes log message into log
            </summary>
        </member>
        <member name="P:NFX.Log.LogService.WriteInterval">
            <summary>
            Determines how often a log should be written to storage.
            The value of this property must be between 10 and 5000 (milliseconds)
            </summary>
        </member>
        <member name="P:NFX.Log.LogService.FileExtension">
            <summary>
            Extension for log files
            </summary>
        </member>
        <member name="P:NFX.Log.LogService.Reliable">
            <summary>
            Determines whether this service blocks on stop longer until all buffered messages have been tried to be dispatched into all destinations.
            This property is true by default.
            Certain destinations may take considerable time to fail per message (i.e. database connection timeout), consequently buffered messages
             processing may delay service stop significantly if this property is true
            </summary>
        </member>
        <member name="T:NFX.Log.Message">
            <summary>
            Represents an Log message 
            </summary>
        </member>
        <member name="P:NFX.Log.Message.Guid">
            <summary>
            Returns global unique identifier for this particular message
            </summary>
        </member>
        <member name="P:NFX.Log.Message.RelatedTo">
            <summary>
            Gets/Sets global unique identifier of a message that this message is related to.
            No referential integrity check is performed
            </summary>
        </member>
        <member name="P:NFX.Log.Message.Type">
            <summary>
            Gets/Sets message type, such as: Info/Warning/Error etc...
            </summary>
        </member>
        <member name="P:NFX.Log.Message.Source">
            <summary>
            Gets/Sets message source, particular applications may elect to cast to their enums
            </summary>
        </member>
        <member name="P:NFX.Log.Message.TimeStamp">
            <summary>
            Gets/Sets timestamp when message was generated
            </summary>
        </member>
        <member name="P:NFX.Log.Message.Host">
            <summary>
            Gets/Sets host name that generated the message
            </summary>
        </member>
        <member name="P:NFX.Log.Message.From">
            <summary>
            Gets/Sets instance name/ID/type, such as: class name, method name, process instance, that generated the message
            </summary>
        </member>
        <member name="P:NFX.Log.Message.Topic">
            <summary>
            Gets/Sets a message type in unstructured textual form - message topic
            </summary>
        </member>
        <member name="P:NFX.Log.Message.Text">
            <summary>
            Gets/Sets an unstructured message text
            </summary>
        </member>
        <member name="P:NFX.Log.Message.Parameters">
            <summary>
            Gets/Sets a structured parameter bag 
            </summary>
        </member>
        <member name="P:NFX.Log.Message.ThreadID">
            <summary>
            Returns the ID of the thread that created the message
            </summary>
        </member>
        <member name="P:NFX.Log.Message.Exception">
            <summary>
            Gets/Sets exception
            </summary>
        </member>
        <member name="T:NFX.Log.NOPLog">
            <summary>
            Represents log that does not do anything
            </summary>
        </member>
        <member name="P:NFX.Log.NOPLog.Instance">
            <summary>
            Returns a singlelton instance of the log that does not do anything
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.NonNull``1(``0,System.Func{System.Exception},System.String)">
            <summary>
            Checks the value for null and throws exception if it is.
            The method is useful for .ctor call chaining to preclude otherwise anonymous NullReferenceException
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.ToSecondsSinceUnixEpochStart(System.DateTime)">
            <summary>
            Gets number of seconds since Unix epoch start (1970/1/1 0:0:0)
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.FromSecondsSinceUnixEpochStart(System.Int64)">
            <summary>
            Gets UTC DateTime from number of seconds since Unix epoch start (1970/1/1 0:0:0)
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.ToMillisecondsSinceUnixEpochStart(System.DateTime)">
            <summary>
            Gets number of milliseconds since Unix epoch start (1970/1/1 0:0:0)
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.ToMicrosecondsSinceUnixEpochStart(System.DateTime)">
            <summary>
            Gets number of microseconds since Unix epoch start (1970/1/1 0:0:0)
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.ToMessageWithType(System.Exception)">
            <summary>
            Writes exception message with exception type
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.FullNameWithExpandedGenericArgs(System.Type,System.Boolean)">
            <summary>
            Returns the full name of the type optionally prefixed with verbatim id specifier '@'.
            The generic arguments ar expanded into their full names i.e. 
              List'1[System.Object]  ->  System.Collections.Generic.List&lt;System.Object&gt;
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.DisplayNameWithExpandedGenericArgs(System.Type)">
            <summary>
            Returns the the name of the type with expanded generic argument names.
            This helper is useful for printing class names to logs/messages.
              List'1[System.Object]  ->  List&lt;Object&gt;
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.CapitalizeFirstChar(System.String)">
            <summary>
            Capitalizes first character of string
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.SplitLines(System.String)">
            <summary>
            Splits string into lines using Win or .nix line brakes
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.ToDescription(System.Reflection.MemberInfo)">
            <summary>
            Returns MemberInfo described as short string
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.IsComponentDesignerHosted(System.ComponentModel.Component)">
            <summary>
            Determines if component is being used within designer
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.ExeName(System.Boolean)">
            <summary>
            Returns name of executable file along with its path
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.Args(System.String,System.Object[])">
            <summary>
            Shortcut helper for string.Format(tpl, params object[] args)
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.ArgsTpl(System.String,System.Object)">
            <summary>
            Interprets template of the form:  Some text {@value_name@:C} by replacing with property/field values.
            Note: this function does not recognize escapes for simplicity (as escapes can be replaced by regular strings instead)
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.IPStringToIPEndPoint(System.String)">
            <summary>
            Converts string of format "xx.xx.xx.xx:nnnn" into IPEndPoint.
            DNS names are NOT supported
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.ToIPEndPoint(System.String,System.Int32)">
            <summary>
            Resolve IP address by Name
            </summary>
            <param name="epoint">An ip address or DNS host name with optional port separated by ':'</param>
            <param name="dfltPort">Port number to use if not supplied in endpoint string</param>
            <returns>IPEndPoint instance or null supplied string could not be parsed</returns>
        </member>
        <member name="M:NFX.MiscUtils.RunAndCompleteProcess(System.String,System.String)">
            <summary>
            Runs specified process and waits for termination returning standard process output.
            This is a blocking call
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.AllFileNamesThatMatch(System.String,System.String,System.Boolean)">
            <summary>
            Walks all file names that match the pattern in a directory
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.AllFileNames(System.String,System.Boolean)">
            <summary>
            Walks all file names in a directory
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.CopyFieldsToRecordFields(System.Data.Common.DbDataReader,NFX.RecordModel.Record)">
            <summary>
            Copies reader fields into record fields finding matches by name and store flag.
            Reader must be in a "readable" state - "reader.Read()" should be executed by the caller
            <code>
              if (reader.Read()) reader.CopyFieldsToRecordFields(record);
            </code>
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.ToGUID(System.String)">
            <summary>
            Generates GUID based on a string MD5 hash
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.ToMD5String(System.String)">
            <summary>
            Returns a MD5 hash of a string represented as hex string
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.IsValidXMLName(System.String)">
            <summary>
            Returns true when supplied name can be used for XML node naming (node names, attribute names)
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.EqualsIgnoreCase(System.String,System.String)">
            <summary>
            Helper function that performs case-insensitive comparison between strings using invariant comparison.
            Either lhs and rhs can be null
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.EqualsOrdIgnoreCase(System.String,System.String)">
            <summary>
            Helper function that performs case-insensitive comparison between strings using ordinal comparison.
            Either lhs and rhs can be null
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.IsNullOrEmpty(System.String)">
            <summary>
            Helper function that calls string.IsNullOrEmpty()
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.IsNotNullOrEmpty(System.String)">
            <summary>
            Helper function that calls !string.IsNullOrEmpty()
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.IsNullOrWhiteSpace(System.String)">
            <summary>
            Helper function that calls string.IsNullOrWhiteSpace()
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.IsNotNullOrWhiteSpace(System.String)">
            <summary>
            Helper function that calls !string.IsNullOrWhiteSpace()
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.ToDumpString(System.Byte[],NFX.DumpFormat,System.Int32,System.Int32,System.Boolean,System.Text.Encoding,System.Int32)">
            <summary>
            Convert a buffer to a printable string
            </summary>
            <param name="buf">Buffer to convert</param>
            <param name="fmt">Dumping format</param>
            <param name="offset">Starting index</param>
            <param name="count">Number of bytes to process (-1 means all bytes in the buffer)</param>
            <param name="eol">If true, terminate with end-of-line</param>
            <param name="encoding">Encoding to use for writing data in Binary format</param>
            <param name="maxLen">Max length of the returned string. Pass 0 for unlimited length</param>
            <returns></returns>
        </member>
        <member name="M:NFX.MiscUtils.ToConfigSections(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Converts dictionary into configuration where every original node gets represented as a sub-section of config's root
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.ToConfigAttributes(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Converts dictionary into configuration where every original node gets represented as an attribute of config's root
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.EvaluateVarsInXMLConfigScope(System.String,System.String,NFX.Environment.IEnvironmentVariableResolver,NFX.Environment.IMacroRunner)">
            <summary>
             Evaluates variables in a context of optional configuration supplied in XML format
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.EvaluateVarsInDictionaryScope(System.String,System.Collections.Generic.IDictionary{System.String,System.Object},NFX.Environment.IEnvironmentVariableResolver,NFX.Environment.IMacroRunner)">
            <summary>
             Evaluates variables in a context of optional configuration supplied as dictionary which is converted to attributes
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.EvaluateVars(System.String,NFX.Environment.IEnvironmentVariableResolver,NFX.Environment.IMacroRunner)">
            <summary>
             Evaluates variables in a context of optional variable resolver and macro runner
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.EvaluateVarsInConfigScope(System.String,NFX.Environment.Configuration)">
            <summary>
             Evaluates variables in a context of optional configuration supplied as config object
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.Burmatographize(System.String,System.Boolean)">
            <summary>
            Swaps string letters that "obfuscates" string- usefull for generation of keys from strings that have to become non-obvious to user.
            This function does not offer any real protection (as it is easy to decipher the original value), just visual.
            The name comes from non-existing science "Burmatography" used in "Neznaika" kids books
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.ToDebugView(System.Linq.Expressions.Expression,System.Int32)">
            <summary>
            Converts expression tree to simple textual form for debugging
            </summary>
        </member>
        <member name="T:NFX.DebugAssertionException">
            <summary>
            Thrown by Debug class to indicate assertion failures
            </summary>
        </member>
        <member name="T:NFX.OS.ProcessRunner">
            <summary>
            Provides simple process invocation and output capture functionality
            </summary>
        </member>
        <member name="M:NFX.OS.ProcessRunner.Run(System.String,System.String,System.Int32@,System.Boolean@,System.Int32)">
            <summary>
            Invokes a process specified by cmd parameters blocking until process finishes and returns stdout.
            Pass optional timeout parameter that will abort the process execution when exceeded, or zero for unlimited time.
            </summary>
        </member>
        <member name="M:NFX.OS.ProcessRunner.Run(System.String,System.String,System.Boolean@,System.Int32)">
            <summary>
            Invokes a process specified by cmd parameters blocking until process finishes and returns stdout.
            Pass optional timeout parameter that will abort the process execution when exceeded, or zero for unlimited time.
            </summary>
        </member>
        <member name="M:NFX.OS.ProcessRunner.Run(System.String,System.Int32)">
            <summary>
            Invokes a process specified by cmd parameters blocking until process finishes and returns stdout
            Pass optional timeout parameter that will abort the process execution when exceeded, or zero for unlimited time.
            </summary>
        </member>
        <member name="M:NFX.OS.ProcessRunner.Run(System.Int32)">
            <summary>
            Runs process blocking until it finishes, or timeout is exceeded. Pass zero for time-unconstrained execution
            </summary>
        </member>
        <member name="P:NFX.OS.ProcessRunner.ProcessCmd">
            <summary>
            Gets/sets process to run
            </summary>
        </member>
        <member name="P:NFX.OS.ProcessRunner.Arguments">
            <summary>
            Gets/sets process invocation arguments
            </summary>
        </member>
        <member name="P:NFX.OS.ProcessRunner.BufferedOutput">
            <summary>
            Returns buffered process output
            </summary>
        </member>
        <member name="P:NFX.OS.ProcessRunner.ExitCode">
            <summary>
            Returns process last exit code
            </summary>
        </member>
        <member name="P:NFX.OS.ProcessRunner.TimedOutAndKilled">
            <summary>
            Returns process last exit code
            </summary>
        </member>
        <member name="P:NFX.OS.ProcessRunner.ExecutionTimeMs">
            <summary>
            Returns process execution time in milliseconds
            </summary>
        </member>
        <member name="T:NFX.Parsing.DataEntryUtils">
            <summary>
            Provides misc data-entry parsing routines
            </summary>
        </member>
        <member name="M:NFX.Parsing.DataEntryUtils.CheckScreenName(System.String)">
            <summary>
            Returns true if the value starts from primary language char and contains only those chars separated by one of ['.','-','_'].
            Subsequent separators not to occur more than once and can not be at the very end. This function supports Latin/Cyrrilic char sets
            </summary>
        </member>
        <member name="M:NFX.Parsing.DataEntryUtils.NormalizeUSPhone(System.String)">
            <summary>
            Normalizes US phone string so it looks like (999) 999-9999x9999.
            </summary>
        </member>
        <member name="T:NFX.Parsing.IdentifierLookup">
            <summary>
            Evaluator class performs math and logical expression parsing and evaluation without allocating .NET compilers
            </summary>
        </member>
        <member name="M:NFX.Parsing.Evaluator.Evaluate(NFX.Parsing.IdentifierLookup)">
            <summary>
            Evaluate expression and return result - either string or numerical value
            </summary>
        </member>
        <member name="M:NFX.Parsing.Evaluator.PrintTree">
            <summary>
            Returns b-tree traversal in a string form
            </summary>
        </member>
        <member name="P:NFX.Parsing.Evaluator.Expression">
            <summary>
            Expression beeing evaluated
            </summary>
        </member>
        <member name="P:NFX.Parsing.Evaluator.NoStringsExpression">
            <summary>
            Expression with all strings replaced with tokens
            </summary>
        </member>
        <member name="P:NFX.Parsing.Evaluator.Root">
            <summary>
            Root node of expression evaluation tree
            </summary>
        </member>
        <member name="E:NFX.Parsing.Evaluator.OnIdentifierLookup">
            <summary>
            Event which is fired upon leaf token resolution during evaluation, used to resolve host variables
            </summary>
        </member>
        <member name="T:NFX.Parsing.Evaluator.Node">
            <summary>
            Node class represents evaluation b-tree element
            </summary>
        </member>
        <member name="P:NFX.Parsing.Evaluator.Node.Expression">
            <summary>
            This node sub-expression
            </summary>
        </member>
        <member name="P:NFX.Parsing.Evaluator.Node.Condition">
            <summary>
            Boolean condition expression (subnode) used for conditional (ternary) operator
            </summary>
        </member>
        <member name="P:NFX.Parsing.Evaluator.Node.Left">
            <summary>
            Left b-tree branch, may be blank (in case of unary operators)
            </summary>
        </member>
        <member name="P:NFX.Parsing.Evaluator.Node.Right">
            <summary>
            Right b-tree branch, used for unary operators
            </summary>
        </member>
        <member name="P:NFX.Parsing.Evaluator.Node.Operator">
            <summary>
            Head operator performed on left and right b-tree branches
            </summary>
        </member>
        <member name="P:NFX.Parsing.Evaluator.Node.Level">
            <summary>
            Node depth level within expression b-tree
            </summary>
        </member>
        <member name="T:NFX.Parsing.JavaScript.Stripper">
            <summary>
            Strips JavaScript content off comments and whitespaces
            </summary>
        </member>
        <member name="T:NFX.Parsing.TokenParser">
            <summary>
            TokenParser class translates tokenized content string to an array list of parsed tokens with attributes
            </summary>
        </member>
        <member name="P:NFX.Parsing.TokenParser.Content">
            <summary>
            Retrieves raw unparsed content
            </summary>
        </member>
        <member name="T:NFX.Parsing.TokenParser.Token">
            <summary> Token class holds parsed token info along with an array of attributes </summary>
        </member>
        <member name="P:NFX.Parsing.TokenParser.Token.Content">
            <summary>
            A string representing whole token body, in between open and close chars
            </summary>          
        </member>
        <member name="P:NFX.Parsing.TokenParser.Token.Name">
            <summary>
            A string representing token name - first identifier within token content
            </summary>
        </member>
        <member name="P:NFX.Parsing.TokenParser.Token.IsSimpleText">
            <summary>             
            True if a token represents literal text that gets embedded in response as is 
            </summary>
        </member>
        <member name="T:NFX.Parsing.TokenParser.Token.Attribute">
            <summary>
            Attribute class represents token's attribute
            </summary>
        </member>
        <member name="P:NFX.Parsing.TokenParser.Token.Attribute.Name">
            <summary>
            Represents token's attribute name
            </summary>
        </member>
        <member name="P:NFX.Parsing.TokenParser.Token.Attribute.Value">
            <summary>
            Represents token's attribute value
            </summary>
        </member>
        <member name="P:NFX.Parsing.TokenParser.Token.Attribute.Index">
            <summary>
            Attribute index (0-based position) within token tag parse order
            </summary>
        </member>
        <member name="P:NFX.Parsing.TokenParser.Token.Attribute.ContentIndex">
            <summary>
            Attribute body index in content string
            </summary>
        </member>
        <member name="P:NFX.Parsing.TokenParser.Token.Attribute.ContentLength">
            <summary>
            Attribute body length in content string
            </summary>
        </member>
        <member name="M:NFX.Parsing.Utils.ParseFieldNameToDescription(System.String,System.Boolean)">
            <summary>
            Parses database field names (column names) and converts parts to human-readable description
             like:
             "FIRST_NAME" -> "First Name",    
             "FirstName" -> "First Name",
             "CHART_OF_ACCOUNTS" -> "Chart of Accounts"
            </summary>
        </member>
        <member name="M:NFX.Parsing.Utils.IsURLValid(System.String)">
            <summary>
            Checks URL string for validity
            </summary>
        </member>
        <member name="M:NFX.Parsing.Utils.MakeSentenceLines(System.String)">
            <summary>
            Puts every sentence on a separate line
            </summary>
        </member>
        <member name="M:NFX.Parsing.Utils.CapturePatternMatch(System.String,System.String,System.Char,System.StringComparison)">
            <summary>
            Returns a captured wildcard segment from string. Pattern uses '*' for match capture by default and may contain a single capture
            </summary>
        </member>
        <member name="M:NFX.Parsing.Utils.MatchPattern(System.String,System.String,System.Char,System.Char,System.Boolean)">
            <summary>
            Returns true if supplied string matches pattern that can contain up to one * wildcard and multiple ? wildcards
            </summary>
        </member>
        <member name="T:NFX.RecordModel.BindingBase">
            <summary>
            Provides an abstract base for bindings
            </summary>
        </member>
        <member name="T:NFX.RecordModel.IBinding">
            <summary>
            Represents view binding. This interface is used by model classes which are unaware of concrete binding
             types allocated by views
            </summary>
        </member>
        <member name="M:NFX.RecordModel.BindingBase.#ctor(System.Object)">
            <summary>
            Creates an instance of binding, setting an owner reference to an instance of a concrete GUI class
            that is allocating this binding and what this binding provides services for
            </summary>
        </member>
        <member name="M:NFX.RecordModel.BindingBase.SetValueFromGUI(System.Object)">
            <summary>
            Sets value from view binding. This method is used to commit data from view controls into fields
            </summary>
        </member>
        <member name="M:NFX.RecordModel.BindingBase.AttachDesignTimeSurrogateRecord(System.String)">
            <summary>
            Attaches to a surrogate record instance. This is an internal framework design-time only method. 
            Throws exceptions. Not intended to be called by developers
            </summary>
        </member>
        <member name="M:NFX.RecordModel.BindingBase.Detach">
            <summary>
            Unbinds a binding from whatever entity it is bound to
            </summary>
        </member>
        <member name="M:NFX.RecordModel.BindingBase.Notify(NFX.RecordModel.Notification)">
            <summary>
            Notifies binding with a notification message of a certain type
            </summary>
        </member>
        <member name="M:NFX.RecordModel.BindingBase.NotificationsFinished">
            <summary>
            Notifies binding that all notifications have been sent and it is time for control to take appropriate actions.
            This method may be useful for controls that should wait with any repaints/layout changes until all
             notifications have arrived i.e.: "DataChange" may arrive first then other notification
             may arrive that can require full control repaint once again. By implementing protected ProcessNotificationsFinished()
             control's binding can respond to different notification kinds post-factum when a more intelligent
              composition/painting decision can be made.
            </summary>
        </member>
        <member name="F:NFX.RecordModel.BindingBase.m_Record">
            <summary>
            A reference to attached record
            </summary>
        </member>
        <member name="F:NFX.RecordModel.BindingBase.m_Attached">
            <summary>
            Indicates whether binding is attached
            </summary>
        </member>
        <member name="M:NFX.RecordModel.BindingBase.Destructor">
            <summary>
            Destroys an instance of binding. Overrides DisposableObject.Destructor()
            </summary>
        </member>
        <member name="M:NFX.RecordModel.BindingBase.DetachBinding">
            <summary>
            Unbinds a binding from whatever entity it is bound to 
            </summary>
        </member>
        <member name="M:NFX.RecordModel.BindingBase.ProcessNotification(NFX.RecordModel.Notification)">
            <summary>
            Override in derived binding class to take action when all notifications have been sent and it is time for control to take appropriate actions.
            This method may be useful for controls that should wait with any repaints/layout changes until all
             notifications have arrived i.e.: "DataChange" may arrive first then other notification
             may arrive that can require full control repaint once again. By implementing ProcessNotificationsFinished()
             control's binding can respond to different notification kinds post-factum when a more intelligent
              composition/painting decision can be made.
            </summary>
        </member>
        <member name="M:NFX.RecordModel.BindingBase.ProcessNotificationsFinished">
            <summary>
            Called when all messages arrived
            </summary>
        </member>
        <member name="M:NFX.RecordModel.BindingBase.BindingStatusChanged">
            <summary>
            Override in derived classes to take action after binding was attached or detached
            </summary>
        </member>
        <member name="P:NFX.RecordModel.BindingBase.Attached">
            <summary>
            Indicates whether binding is active/attached
            </summary>
        </member>
        <member name="P:NFX.RecordModel.BindingBase.DesignTimeSurrogate">
            <summary>
            Indicates whether binding was created in design-time and connected to temporary record instance
            </summary>
        </member>
        <member name="P:NFX.RecordModel.BindingBase.Record">
            <summary>
            Represents a record this binding is attached to
            </summary>
        </member>
        <member name="P:NFX.RecordModel.BindingBase.RecordTypeName">
            <summary>
            Provides fully-qualified record class type name which is used in design-time to extract record's metadata
             like field names, types etc. A name may take a form of: "Medical.PatientRecord, BusinessObjects" where
              first part before coma is a namespace-qualified record type name followed by an assembly name after coma
            </summary>
        </member>
        <member name="P:NFX.RecordModel.BindingBase.DesignTime">
            <summary>
            Determines whether owner is being designed
            </summary>
        </member>
        <member name="T:NFX.RecordModel.IView">
            <summary>
            Represents model-attachable view
            </summary>
        </member>
        <member name="T:NFX.RecordModel.IRecordContext">
            <summary>
            Describes an entity which can function in a context of a particular record
            </summary>
        </member>
        <member name="T:NFX.RecordModel.ISurrogateRecordTypeNameProvider">
            <summary>
            Describes an entity that has design-time record type name property 
            </summary>
        </member>
        <member name="T:NFX.RecordModel.IParentRecordAttachable">
            <summary>
            Describes an entity which takes its record from parent entity, i.e. field view control
             takes AttachToRecord property from it's containing form or panel
            </summary>
        </member>
        <member name="M:NFX.RecordModel.IParentRecordAttachable.TryAttachModel">
            <summary>
            Attaches an item to a record provided by its logical parent
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IParentRecordAttachable.AttachToParentRecord">
            <summary>
            Indicates whether an item should automatically attach to it's parent record
            </summary>
        </member>
        <member name="T:NFX.RecordModel.IRecordFieldContext">
            <summary>
            Describes an entity which can function in a context of a particular record's field
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IRecordFieldContext.Field">
            <summary>
            Defines what field by reference this binding is connected to. 
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CounterDataStoreKey">
            <summary>
            Represents a key (key field) used in databases that identify entities with BIGINT identity/autoinc columns
            </summary>
        </member>
        <member name="T:NFX.DataAccess.NameValueDataStoreKey">
            <summary>
            Defines dictionary of string/object pairs used for key matching, where string dictionary key represents column name
             in storage and value is an object for the key
            </summary>
        </member>
        <member name="T:NFX.DataAccess.KeyViolationKind">
            <summary>
            Specifies the sub-type of key violation
            </summary>
        </member>
        <member name="T:NFX.RecordModel.DataAccess.IModelDataStore">
            <summary>
            Represents a store that can save and retrieve data for controllers
            </summary>
        </member>
        <member name="M:NFX.RecordModel.DataAccess.IModelDataStore.Load(NFX.RecordModel.ModelBase,NFX.DataAccess.IDataStoreKey,System.Object[])">
            <summary>
            Loads instance data from store
            </summary>
            <param name="instance">Model instance to fill with data</param>
            <param name="key">A key object that uniquely identifies what data to load (such as COUNTER)</param>
            <param name="extra">Extra parameters passed to a store</param>
        </member>
        <member name="M:NFX.RecordModel.DataAccess.IModelDataStore.Save(NFX.RecordModel.ModelBase,NFX.DataAccess.IDataStoreKey,System.Object[])">
            <summary>
            Saves data from model instance into a store
            </summary>
            <param name="instance">Model instance to be saved</param>
            <param name="key">Optional key to store data under (may be null i.e. for identity columns or if data inlined in model itself)</param>
            <param name="extra">Extra params passed to a store</param>
        </member>
        <member name="M:NFX.RecordModel.DataAccess.IModelDataStore.Delete(NFX.RecordModel.ModelBase,NFX.DataAccess.IDataStoreKey,System.Object[])">
            <summary>
            Deletes data for model of specified type (passed as instance) with specified key
            </summary>
        </member>
        <member name="T:NFX.RecordModel.InteractabilityType">
            <summary>
            Determines interactability characteristic 
            </summary>
        </member>
        <member name="T:NFX.RecordModel.DataState">
            <summary>
            Represents a state for controllers 
            </summary>
        </member>
        <member name="T:NFX.RecordModel.StorageOperation">
            <summary>
            Represents a state for storage operation such as Load() Save and Delete()
            </summary>
        </member>
        <member name="T:NFX.RecordModel.ChangeType">
            <summary>
            Represents a type change of change made to the record 
            </summary>
        </member>
        <member name="T:NFX.RecordModel.DataEntryType">
            <summary>
            Describes the ways a user can perform data entry through model-attached view
            </summary>
        </member>
        <member name="F:NFX.RecordModel.DataEntryType.None">
            <summary>
            No data entry is allowed, an item is display-only
            </summary>
        </member>
        <member name="F:NFX.RecordModel.DataEntryType.DirectEntry">
            <summary>
            A user can enter value directly into view control
            </summary>
        </member>
        <member name="F:NFX.RecordModel.DataEntryType.DirectEntryOrLookup">
            <summary>
            A user can either enter value directly into view control or select value from a lookup
            </summary>
        </member>
        <member name="F:NFX.RecordModel.DataEntryType.DirectEntryOrLookupWithValidation">
            <summary>
            A user can either enter value directly into view control or select value from a lookup
            A value must exist in dictionary if one is defined
            </summary>
        </member>
        <member name="F:NFX.RecordModel.DataEntryType.Lookup">
            <summary>
            A user can only select value from lookup
            </summary>
        </member>
        <member name="T:NFX.RecordModel.LookupType">
            <summary>
            Describes types of lookup
            </summary>
        </member>
        <member name="F:NFX.RecordModel.LookupType.Dictionary">
            <summary>
            Lookup values come from LookupDictionary property
            </summary>
        </member>
        <member name="F:NFX.RecordModel.LookupType.Command">
            <summary>
            Lookup values come from lookup command property
            </summary>
        </member>
        <member name="F:NFX.RecordModel.LookupType.Calendar">
            <summary>
            A value is looked-up in a calendar control
            </summary>
        </member>
        <member name="F:NFX.RecordModel.LookupType.CalendarWithTime">
            <summary>
            A value is looked-up in a calendar control with time
            </summary>
        </member>
        <member name="F:NFX.RecordModel.LookupType.Custom">
            <summary>
            A custom event is invoked, developers are responsible for implementing custom lookup solution
            </summary>
        </member>
        <member name="T:NFX.RecordModel.DataEntryFormat">
            <summary>
            Describes formatting applied to attached view controls
            </summary>
        </member>
        <member name="F:NFX.RecordModel.DataEntryFormat.AsIs">
            <summary>
            No formatting is performed, content is kept as-is
            </summary>
        </member>
        <member name="F:NFX.RecordModel.DataEntryFormat.Phone">
            <summary>
            Phone numbers
            </summary>
        </member>
        <member name="F:NFX.RecordModel.DataEntryFormat.PostalCode">
            <summary>
            aka ZIP codes in US
            </summary>
        </member>
        <member name="F:NFX.RecordModel.DataEntryFormat.Currency">
            <summary>
            Format as currency
            </summary>
        </member>
        <member name="F:NFX.RecordModel.DataEntryFormat.Date">
            <summary>
            Date without time
            </summary>
        </member>
        <member name="F:NFX.RecordModel.DataEntryFormat.Time">
            <summary>
            A time without date
            </summary>
        </member>
        <member name="F:NFX.RecordModel.DataEntryFormat.DateTime">
            <summary>
            Date with time
            </summary>
        </member>
        <member name="F:NFX.RecordModel.DataEntryFormat.Custom">
            <summary>
            An event is invoked. Developers are responsible for custom formatting
            </summary>
        </member>
        <member name="T:NFX.RecordModel.DisplayTextHAlignment">
            <summary>
            Types of text alignment for text and combo box views
            Supports both RTL sensitive and insensitive modes
            </summary>
        </member>
        <member name="F:NFX.RecordModel.FieldDataChangeEventArgs.GUIBinding">
            <summary>
            Represents a GUI control binding (if any) that this field's value is being changed from.
            NULL when change was not caused by manual user entry
            </summary>
        </member>
        <member name="P:NFX.RecordModel.FieldDataChangeEventArgs.FromGUI">
            <summary>
            Indicates whether an event was caused by user GUI action 
            </summary>
        </member>
        <member name="T:NFX.RecordModel.GetClientScriptsEventHandler">
            <summary>
            Event handler invoked to get client scripts for specific technology
            </summary>
        </member>
        <member name="T:NFX.RecordModel.Field">
            <summary>
            Provides base field-management model functionality. View controls are bound to record fields 
            </summary>
        </member>
        <member name="T:NFX.RecordModel.ModelBase">
            <summary>
            Provides an abstract base for Record and Field model classes
            </summary>
        </member>
        <member name="T:NFX.RecordModel.IControllableInteractions">
            <summary>
            Interfaces an item with changeable interaction behavior such as: applicability, visibility, being enabled, readonly etc.
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IControllableInteractions.Applicable">
            <summary>
            Determines whether an item applies (can be interacted at all). Usually this property is
            acted upon  by an application business rules
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IControllableInteractions.Visible">
            <summary>
            Determines whether an item is shown to the user. 
            Presentation method of an item is dependent on an implementation of a particular class.
            For non-visual model/controller classes this property cascades down to attached view devices.
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IControllableInteractions.Enabled">
            <summary>
            Determines whether an item is enabled for user actions.
            Presentation method of an item is dependent on an implementation of a particular class.
            For non-visual model/controller classes this property cascades down to attached view devices.
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IControllableInteractions.Readonly">
            <summary>
            Determines whether an item is available for data input.
            Presentation method of an item is dependent on an implementation of a particular class.
            For non-visual model/controller classes this property cascades down to attached view devices.
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IControllableInteractions.IsApplicable">
            <summary>
            Determines whether an item is really applicable. 
            Item applicability is governed by parent context and may differ from instance's Applicable property 
            <see>Applicable</see>
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IControllableInteractions.IsVisible">
            <summary>
            Determines whether an item is really visible. 
            Item visibility is governed by parent context and may differ from instance's Visible property 
            <see>Visible</see>
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IControllableInteractions.IsEnabled">
            <summary>
            Determines whether an item is really enabled. 
            Item enabled state is governed by parent context and may differ from instance's Enabled property 
            <see>Enabled</see>
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IControllableInteractions.IsReadonly">
            <summary>
            Determines whether an item is really readonly. 
            Item readonly state is governed by parent context and may differ from instance's Readonly property 
            <see>Readonly</see>
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.Load(NFX.RecordModel.DataAccess.IModelDataStore,NFX.DataAccess.IDataStoreKey,System.Object[])">
            <summary>
            Initializes an instance for data loading and loads data if store is not null from external source.
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.BeginLoad(NFX.RecordModel.DataAccess.IModelDataStore,NFX.DataAccess.IDataStoreKey,System.Object[])">
            <summary>
            Initializes an instance for data loading and loads data if store is not null from external source.
            This call has to be followed by EndLoad()
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.EndLoad">
            <summary>
            Finalized data load operation from external source. This call has to be preceded by BeginLoad()
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.CancelLoad">
            <summary>
            Sets this instance to Uninitialized state when Load did not succeed. Call to abort failed loads
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.Create">
            <summary>
            Create a new instance of data, such as new record, or new field value
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.Edit">
            <summary>
            Modified item's existing data
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.Post">
            <summary>
            Performs validations and posts changes permanently
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.Cancel">
            <summary>
            Cancels creation/modification of data
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.Save(NFX.RecordModel.DataAccess.IModelDataStore)">
            <summary>
            Saves data into external store under this instance's DataStoreKey
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.Save(NFX.RecordModel.DataAccess.IModelDataStore,NFX.DataAccess.IDataStoreKey,System.Object[])">
            <summary>
            Saves data into external store using specified key. If key is null then provider may elect to build key from fields with KeyField attribute set to true
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.Delete(NFX.RecordModel.DataAccess.IModelDataStore)">
            <summary>
            Deletes data from external store under this instance's DataStoreKey.
            After this call model state is DataState.Uninitialized
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.Delete(NFX.RecordModel.DataAccess.IModelDataStore,NFX.DataAccess.IDataStoreKey,System.Object[])">
            <summary>
            Deletes data from external store with specified key. When key is omitted instance's DataStoreKey is used.
            After this call model state is DataState.Uninitialized
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.Revert">
            <summary>
            Reverts data to the state it was in before editing/creation was performed. This method is used for modifications cancelation
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.ReleaseOwner">
            <summary>
            Disassociates an item with its current owner effectively rendering owning entity unaware of this item
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.Validate">
            <summary>
            Validates an item for correct data and sets "Validated" and "Valid" properties
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.DisableBindings">
            <summary>
            Stops any notifications broadcast to subscribed bindings from this and all owned instances
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.EnableBindings">
            <summary>
            Resumes all notifications broadcast to subscribed bindings from this and all owned instances
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.AttachEventHandlers">
            <summary>
            Attaches event handlers or re-attaches event handlers back after model was resurrected from non-volatile store
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.InvokeCallableMethod(System.String,System.Object[])">
            <summary>
            Invokes model's public method which is decorated with callable attribute
            </summary>
            <param name="name">Method name</param>
            <param name="parameters">Parameters</param>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.GetClientScripts(System.String)">
            <summary>
            Returns client scripts, such as JavaScript for particular client-implementation technology.
            For example, client frameworks/technologies of a different kind may connect to the same record model.
            This implementation probes event first, and if it is set then invokes it, otherwise it uses ClientScript attribute to return its text if it is set, 
            otherwise script text from resource is returned. 
            Override to provide client script programmatically.
            </summary>
            <param name="technology">The name of client-side technology that requests client script, i.e. 'nfx'</param>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.ApplyDefinitionAttributes(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Sets model properties from definition attributes 
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.AttachEvents">
            <summary>
            Override to attach/re-attach events after model gets resurrected from storage
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.CreatePreEditStateCopy">
            <summary>
            Creates a copy of items data state. This is needed for record editing
             so Cancel method may revert to saved copy that was made before any edits were performed
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.DropPreEditStateCopy">
            <summary>
            Deletes a copy of data as it is not needed any more after successful post
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.RevertToPreEditState">
            <summary>
            Reverts this instance to pre edit state by returning to private state values
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.CheckCreateAllowed">
            <summary>
            Checks and throws an exception if Create() operation is not allowed
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.DoCreate">
            <summary>
            Override to implement functionality performed upon Create() 
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.CheckEditAllowed">
            <summary>
            Checks and throws an exception if Edit() operation is not allowed
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.DoEdit">
            <summary>
            Override to implement functionality performed upon Edit() 
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.CheckPostAllowed">
            <summary>
            Checks and throws an exception if Post() operation is not allowed
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.DoPost">
            <summary>
            Override to implement functionality performed upon Post() 
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.CheckCancelAllowed">
            <summary>
            Checks and throws an exception if Cancel() operation is not allowed
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.DoCancel">
            <summary>
            Override to implement functionality performed upon Cancel() 
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.CheckLoadAllowed">
            <summary>
            Checks and throws an exception if BeginLoad() operation is not allowed
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.DoLoad(NFX.RecordModel.DataAccess.IModelDataStore,NFX.DataAccess.IDataStoreKey,System.Object[])">
            <summary>
            Override to implement functionality performed upon BeginLoad() 
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.DoEndLoad">
            <summary>
            Override to implement functionality performed upon EndLoad() after data has been loaded AND validated
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.DoCancelLoad">
            <summary>
            Override to implement functionality performed upon CancelLoad() after load has not succeeded
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.CheckSaveAllowed">
            <summary>
            Checks and throws an exception if Save() operation is not allowed
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.DoSave(NFX.RecordModel.DataAccess.IModelDataStore,NFX.DataAccess.IDataStoreKey,System.Object[])">
            <summary>
            Override to implement functionality performed upon Save() 
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.CheckDeleteAllowed">
            <summary>
            Checks and throws an exception if Save() operation is not allowed
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.DoDelete(NFX.RecordModel.DataAccess.IModelDataStore,NFX.DataAccess.IDataStoreKey,System.Object[])">
            <summary>
            Override to implement functionality performed upon Delete() 
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.PerformValidation(System.Boolean@)">
            <summary>
            Performs item validation, throwing exception when data is not valid
            </summary>
            <param name="couldNotValidate">
            Indicates that validation could not be performed. This may happen when
            an item is being validated prematurely, i.e. when an item's validation
            needs to cross-check its value with some other item that has not yet been 
            entered. This value is ignored on final validations caused by record posts
            as items must be validated then
            </param>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.BeforeOwnedItemAddition(NFX.RecordModel.ModelBase)">
            <summary>
            Called before owned item is added to owner collection. Override this method
            to perform checks before item actually added, such as: ensure unique item identification among siblings, etc.
            Throw exception to prohibit addition
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.AfterOwnedItemAddition(NFX.RecordModel.ModelBase)">
            <summary>
            Called after an item was added to owning object. Exceptions are handled
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.BeforeOwnedItemRemoval(NFX.RecordModel.ModelBase)">
            <summary>
            Called before an item is about to be removed from owning context.
            Throw exception to prohibit deletion
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.AfterOwnedItemRemoval(NFX.RecordModel.ModelBase)">
            <summary>
            Called after an item was removed from owning context. Exceptions are handled
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ModelBase.OnGetClientScriptsEvent(System.String)">
            <summary>
            Invokes event
            </summary>
        </member>
        <member name="P:NFX.RecordModel.ModelBase.SupportsNotificationBinding">
            <summary>
            Determines whether this model supports sending notifications to bindings
            </summary>
        </member>
        <member name="P:NFX.RecordModel.ModelBase.Constructed">
            <summary>
            Indicates whether instance was created and internal data structures constructed
            </summary>
        </member>
        <member name="P:NFX.RecordModel.ModelBase.Owner">
            <summary>
            Provides access to an owner object
            </summary>
        </member>
        <member name="P:NFX.RecordModel.ModelBase.OwnedItems">
            <summary>
            Provides access to items owned by this model instance
            </summary>
        </member>
        <member name="P:NFX.RecordModel.ModelBase.State">
            <summary>
            Returns data state of this model
            </summary>
        </member>
        <member name="P:NFX.RecordModel.ModelBase.StorageOperation">
            <summary>
            Returns ongoing data storage operation
            </summary>
        </member>
        <member name="P:NFX.RecordModel.ModelBase.LastPostedChange">
            <summary>
            Returns a type of the last change posted to model
            </summary>
        </member>
        <member name="P:NFX.RecordModel.ModelBase.DataStoreKey">
            <summary>
            Returns the key that this model was loaded or saved with or null
            </summary>
        </member>
        <member name="P:NFX.RecordModel.ModelBase.PermissionNamespace">
            <summary>
            Establishes permission namespace for an item. Items owned by this item resolve thier permission names through 
             owner's permission namespace, i.e. if permission namespace is set to "CustomerPaymentRecord" in a record,
             then all record's fields will lookup their permission names according to this pattern:
                "CustomerPaymentRecord.[Field.PermissionName]"
            </summary>
        </member>
        <member name="P:NFX.RecordModel.ModelBase.PermissionName">
            <summary>
            Establishes permission name for an item. When checking permissions, items concatenate 
            their owner's permission namespace name with their own permission name to resolve full permission name
             through security provider
            </summary>
        </member>
        <member name="P:NFX.RecordModel.ModelBase.StoreFlag">
            <summary>
            Determines whether this entity should be persisted in a storage (such as a database) or loaded from storage or both.
            Non-stored entities are most commonly used in client-side functionality like temp-calculated values etc.
            </summary>
        </member>
        <member name="P:NFX.RecordModel.ModelBase.DisableBindingsLevel">
            <summary>
            Specifies current nesting level of DisableBindings() call
            </summary>
        </member>
        <member name="P:NFX.RecordModel.ModelBase.ChangeNotifications">
            <summary>
            Provides access to change notifications pending on this model instance.
            Notifications are purged after final EnableBindings() call
            </summary>
        </member>
        <member name="P:NFX.RecordModel.ModelBase.Validated">
            <summary>
            Indicates whether this item was validated. "Validated" is set to false upon any change made to records.
            When field validation is deferred until record "Post()"
            validation on fields is not performed upon field change.
            Not to confuse with "Valid", a field may be validated but not valid because it contains bad value.
            </summary>
        </member>
        <member name="P:NFX.RecordModel.ModelBase.Valid">
            <summary>
            Indicates whether this item was validated and contains no errors.
            "Validated" is set to false upon any change made to records, so is "Valid".
            When field validation is deferred until record "Post()"
            validation on fields is not performed upon field change.
            Not to confuse with "Validated", a field must be validated to be valid.
            </summary>
        </member>
        <member name="P:NFX.RecordModel.ModelBase.ValidationException">
            <summary>
            Provides access to an error (if any) that happened during last field validation
            </summary>
        </member>
        <member name="P:NFX.RecordModel.ModelBase.ThrowOnInitValidation">
            <summary>
            Indicates whether to throw an exception when model is in invalid state upon init
            </summary>
        </member>
        <member name="P:NFX.RecordModel.ModelBase.DeferredValidation">
            <summary>
            Indicates whether this item's validation is delayed until data is posted
            </summary>
        </member>
        <member name="E:NFX.RecordModel.ModelBase.SecurityChanged">
            <summary>
            Invoked after security permission name changes
            </summary>
        </member>
        <member name="E:NFX.RecordModel.ModelBase.PreValidation">
            <summary>
            Invoked before validation starts. Exceptions are not caught
            </summary>
        </member>
        <member name="E:NFX.RecordModel.ModelBase.Validation">
            <summary>
            Invoked during validation. Any exception thrown is caught into ValidationException (and Valid property)
            </summary>
        </member>
        <member name="E:NFX.RecordModel.ModelBase.PostValidation">
            <summary>
            Invoked after all validation is done regardless of the result. Exceptions are not caught
            </summary>
        </member>
        <member name="E:NFX.RecordModel.ModelBase.GetClientScriptsEvent">
            <summary>
            Invoked to get client validation script for specific technology
            </summary>
        </member>
        <member name="F:NFX.RecordModel.Field.__sourceBinding">
            <summary>
            Internal framework member not intended to be used by developers
            </summary>
        </member>
        <member name="M:NFX.RecordModel.Field.SetValueFromGUI(System.Object,NFX.RecordModel.IBinding)">
            <summary>
            Sets value from view binding. This method is used to commit data from view controls into fields
            </summary>
        </member>
        <member name="M:NFX.RecordModel.Field.ClearValueFromGUI(NFX.RecordModel.IBinding)">
            <summary>
            Clears value from view binding. This method is used to commit data from view controls into fields
            </summary>
        </member>
        <member name="M:NFX.RecordModel.Field.Clear">
            <summary>
            Clears field value effectively setting HasValue to false
            </summary>
        </member>
        <member name="M:NFX.RecordModel.Field.Default">
            <summary>
            Sets field value to default value
            </summary>
        </member>
        <member name="M:NFX.RecordModel.Field.ResetModified">
            <summary>
            Resets field modification flag to false
            </summary>
        </member>
        <member name="M:NFX.RecordModel.Field.ResetGUIModified">
            <summary>
            Resets field GUI modified flag to false
            </summary>
        </member>
        <member name="M:NFX.RecordModel.Field.ResetOverridden">
            <summary>
            Resets calculation override flag to false
            </summary>
        </member>
        <member name="M:NFX.RecordModel.Field.ResetValidated">
            <summary>
            Resets validation flag
            </summary>
        </member>
        <member name="M:NFX.RecordModel.Field.GetFieldDataType">
            <summary>
            Returns a type of data stored by field
            </summary>
        </member>
        <member name="M:NFX.RecordModel.Field.GetClientScripts(System.String)">
            <summary>
            Returns client scripts, such as JavaScript for particular client-implementation technology.
            For example, client frameworks/technologies of a different kind may connect to the same record model.
            This implementation probes field-level event first, and if it is set then invokes it, otherwise it uses ClientScript attribute 
            from field-declaration level within record to return its text if it is set, 
            otherwise script text from resource is returned. 
            Override to provide client script programmatically
            </summary>
            <param name="technology">The name of client-side technology that requests client script, i.e. 'nfx'</param>
        </member>
        <member name="M:NFX.RecordModel.Field.PreProcessValueFromGUI(System.Object)">
            <summary>
            Invoked before value gets written into field buff. Override to take actions like re-parsing strings etc..
            </summary>
        </member>
        <member name="M:NFX.RecordModel.Field.OnFieldDataChanging(NFX.RecordModel.FieldDataChangeEventArgs)">
            <summary>
            Triggers field data change event for field and owner record.
            Do not forget to call base implementation when overriding
            </summary>
        </member>
        <member name="M:NFX.RecordModel.Field.OnFieldDataChanged(NFX.RecordModel.FieldDataChangeEventArgs)">
            <summary>
            Triggers field data change event for field and owner record.
            Do not forget to call base implementation when overriding
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Field.Record">
            <summary>
            Providers access to owner record
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Field.State">
            <summary>
            Represents field state. When fields are owned by records, field's states are determined by owner record
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Field.StorageOperation">
            <summary>
            Returns ongoing storage operation. When fields are owned by records, field's states are determined by owner record
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Field.LastPostedChange">
            <summary>
            Returns a type of the last change posted to model
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Field.FieldName">
            <summary>
            Unique data field name, most often used for underlying database column name identification
            Not to be confused with design-time component "Name" property
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Field.Description">
            <summary>
            Provides meaningful field description
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Field.Hint">
            <summary>
            Provides a hint - an example of data stored by field, i.e. may be displayed as watermark
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Field.DisplayWidth">
            <summary>
            Provides suggested default width for GUI
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Field.DisplayTextHAlignment">
            <summary>
            Provides suggested horizontal text alignment for attached view
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Field.DisplayFormat">
            <summary>
            Provides display format string
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Field.KeepInErroredField">
            <summary>
            Indicates whether a user should be kept(not allowed to tab-out) in field-attached control when data is incorrect
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Field.LogicalOrder">
            <summary>
            Defines filed's logical order which may coinside with tab order, this is a hint for automated GUI builders
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Field.Note">
            <summary>
            Attaches a note text to the field (i.e. similar to XL cell comments)
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Field.Marked">
            <summary>
            Indicates whether a field was marked. This property is usually used to implement user-selectable fields 
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Field.LookupDictionary">
            <summary>
            Provides a list of lookup items. Each strings line portion before comma(if any) is treated as an item key.
            Example:  "LPN, LPN Nurse" will be parsed as Key="LPN", Description="LPN Nurse"
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Field.DataEntryType">
            <summary>
            Determines the ways a user can perform data entry through model-attached view
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Field.LookupCommand">
            <summary>
            Specifies lookup command text
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Field.LookupType">
            <summary>
             Determines a type of value lookup used
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Field.HasValue">
            <summary>
            Indicates whether field contains any value 
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Field.HasDefaultValue">
            <summary>
            Indicates whether a field has a default value
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Field.Required">
            <summary>
            Indicates whether field must have a value 
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Field.KeyField">
            <summary>
            Indicates whether field is a(part of) key 
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Field.Modified">
            <summary>
            Indicates whether field value was modified
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Field.GUIModified">
            <summary>
            Indicates whether field value was modified from any of bound GUI controls.
            This property allows to identify fields that have been changed by users
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Field.Calculated">
            <summary>
            Indicates whether this field calculation is enabled
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Field.AllowCalculationOverride">
            <summary>
            Indicates whether this field calculation formula may be overridden by literal value
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Field.Formula">
            <summary>
            Calculation formula
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Field.CalculationError">
            <summary>
            References last raised exception during field formula calculation
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Field.Overridden">
            <summary>
            Indicates whether this field is calculated but value forcefuly overridden 
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Field.IsMutable">
            <summary>
            Indicates whether this field's value can be set right now per current field's state 
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Field.IsGUIMutable">
            <summary>
            Indicates whether this field's value can be set right now from the attached GUI view 
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Field.ValueAsObject">
            <summary>
            Provides access to field data as object 
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Field.ValueAsDisplayString">
            <summary>
            Gets field value as formatted string according to DisplayFormat property
            </summary>
        </member>
        <member name="E:NFX.RecordModel.Field.FieldDataChanging">
            <summary>
            Event fired before field's value is about to change. Throw exceptions to abort the change
            </summary>
        </member>
        <member name="E:NFX.RecordModel.Field.FieldDataChanged">
            <summary>
            Event fired after field's value has changed
            </summary>
        </member>
        <member name="T:NFX.RecordModel.FieldBinding">
            <summary>
            Provides an abstract base for field view bindings. Concrete binding implementations are defined by 
            actual presentation classes that may be (but certainly not limited to) derivatives of standard 
            controls such as WinForms.Textbox, ASPNet.TextBox etc. A field binding derives from record binding and 
            serves two purposes: 
             links a control with a record instance and field name (hence the name)
             and allows control to react to changes in model
            </summary>
        </member>
        <member name="M:NFX.RecordModel.FieldBinding.#ctor(System.Object)">
            <summary>
            Creates an instance of binding, setting an owner reference to an instance of a concrete GUI class
            that is allocating this binding and what this binding provides services for.
            </summary>
        </member>
        <member name="M:NFX.RecordModel.FieldBinding.SetValueFromGUI(System.Object)">
            <summary>
            Sets value from view binding. This method is used to commit data from view controls into fields
            </summary>
        </member>
        <member name="M:NFX.RecordModel.FieldBinding.ClearValue">
            <summary>
            Clears field value effectively setting HasValue to false
            </summary>
        </member>
        <member name="M:NFX.RecordModel.FieldBinding.Attach(NFX.RecordModel.Field)">
            <summary>
            Attaches binding to a particular field
            </summary>
        </member>
        <member name="M:NFX.RecordModel.FieldBinding.Attach(NFX.RecordModel.Record,System.String)">
            <summary>
            Attaches binding to a particular field by name in a particular record
            </summary>
        </member>
        <member name="P:NFX.RecordModel.FieldBinding.Field">
            <summary>
            Represents a field this binding is attached to
            </summary>
        </member>
        <member name="T:NFX.RecordModel.TypedReferenceTypeField`1">
            <summary> Represents fields that store reference types</summary>
        </member>
        <member name="T:NFX.RecordModel.TypedField`1">
            <summary>
            Provides base typed field model functionality. View controls are bound to record fields 
            </summary>
        </member>
        <member name="M:NFX.RecordModel.TypedField`1.op_OnesComplement(NFX.RecordModel.TypedField{`0})">
            <summary>
            Value property shortcut operator
            </summary>
        </member>
        <member name="M:NFX.RecordModel.TypedField`1.Default">
            <summary>
            Sets field to its default value
            </summary>
        </member>
        <member name="M:NFX.RecordModel.TypedField`1.GetFieldDataType">
            <summary>
            Returns type of data stored by field
            </summary>
        </member>
        <member name="M:NFX.RecordModel.TypedField`1.SetInternalValue(`0@)">
            <summary>
            Performs actual write of value into field's memory.
            Always call default parent implementation when overriding
            </summary>
        </member>
        <member name="M:NFX.RecordModel.TypedField`1._setValueTypeHasValue">
            <summary>
            Internal framework method not intended to be called by developers
            </summary>
        </member>
        <member name="P:NFX.RecordModel.TypedField`1.Value">
            <summary>
            Field's data value
            </summary>
        </member>
        <member name="P:NFX.RecordModel.TypedField`1.DefaultValue">
            <summary>
            Field's default data value
            </summary>
        </member>
        <member name="T:NFX.RecordModel.TypedValueTypeField`1">
            <summary> Represents fields that store value types</summary>
        </member>
        <member name="M:NFX.RecordModel.TypedValueTypeField`1._setValueTypeHasValue">
            <summary>
            Internal framework method not intended to be called by developers
            </summary>
        </member>
        <member name="T:NFX.RecordModel.NumericalField`1">
            <summary> Represents fields that store numerical value types such as integers, doubles, etc.</summary>
        </member>
        <member name="P:NFX.RecordModel.NumericalField`1.MinValue">
            <summary>
            Minimum permitted field value
            </summary>
        </member>
        <member name="P:NFX.RecordModel.NumericalField`1.MaxValue">
            <summary>
            Maximum permitted field value
            </summary>
        </member>
        <member name="P:NFX.RecordModel.NumericalField`1.MinMaxChecking">
            <summary>
            Determines whether field value is validated against min/max boundaries
            </summary>
        </member>
        <member name="T:NFX.RecordModel.ObjectField">
            <summary> Represents fields that store objects </summary>
        </member>
        <member name="T:NFX.RecordModel.IField`1">
            <summary>
            Stipulates field contract with value mutability only (metadata read-only),  used for field expositions from records
            </summary>
        </member>
        <member name="T:NFX.RecordModel.IField">
            <summary>
            Stipulates field contract with value mutability only(metadata read-only),  used for field expositions from records
            </summary>
        </member>
        <member name="M:NFX.RecordModel.IField.ResetOverridden">
            <summary>
            Resets calculated value override
            </summary>
        </member>
        <member name="M:NFX.RecordModel.IField.Revert">
            <summary>
            Reverts field value to the one it had before change was made
            </summary>
        </member>
        <member name="M:NFX.RecordModel.IField.Clear">
            <summary>
            Clears field value
            </summary>
        </member>
        <member name="M:NFX.RecordModel.IField.Default">
            <summary>
            Resets value to default one (if field has such a value)
            </summary>
        </member>
        <member name="M:NFX.RecordModel.IField.Validate">
            <summary>
            Causes field validation
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IField.Record">
            <summary>
            Providers access to owner record that has this field declared
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IField.StoreFlag">
            <summary>
            Determines whether field is persisted in a storage (such as a database) or loaded from storage or both.
            Non-stored fields are most commonly used in client-side functionality like temp-calculated values etc.
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IField.FieldName">
            <summary>
            Returns database/storage field name
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IField.Description">
            <summary>
            Provides meaningful field description
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IField.Hint">
            <summary>
            Provides a hint - an example of data stored by field, i.e. may be displayed as watermark
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IField.Applicable">
            <summary>
            Determines whether field applies (can be interacted at all).
            Usually this property is acted upon  by an application business rules
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IField.Visible">
            <summary>
            Determines whether field is shown to the user through views
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IField.Enabled">
            <summary>
            Determines whether field is enabled for user actions
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IField.Readonly">
            <summary>
            Determines whether field is available for data input
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IField.IsApplicable">
            <summary>
            Determines whether field applies (can be interacted at all).
            Usually this property is acted upon  by an application business rules.
            Returns true when both field and it's parent record are Applicable.
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IField.IsVisible">
            <summary>
            Determines whether field is shown to the user through views.
            Returns true when both field and it's parent record are Visible.
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IField.IsEnabled">
            <summary>
            Determines whether field is enabled for user actions.
            Returns true when both field and it's parent record are Enabled.
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IField.IsReadonly">
            <summary>
            Determines whether field is available for data input.
            Returns true when either field or it's parent record is Readonly.
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IField.IsMutable">
            <summary>
            Indicates whether this field's value can be set right now per current field's state 
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IField.IsGUIMutable">
            <summary>
            Indicates whether this field's value can be set from attached view 
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IField.Validated">
            <summary>
            Indicates whether field was validated. This flag is reset by field changes
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IField.Valid">
            <summary>
            Indicates whether field is valid
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IField.ValidationException">
            <summary>
            Returns exception which surfaced during last field validation
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IField.LogicalOrder">
            <summary>
            Returns logical order of field within its record
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IField.Note">
            <summary>
            Returns field notes (similar to MS XL cell comments)
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IField.Marked">
            <summary>
            Indicates whether field is marked
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IField.DisplayWidth">
            <summary>
            Suggested display width for GUI
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IField.DataEntryType">
            <summary>
            Returns type of field data entry
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IField.HasValue">
            <summary>
            Indicates whether field has value
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IField.HasDefaultValue">
            <summary>
            Indicates whether field has default value
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IField.Required">
            <summary>
            Indicates whether field must have value in order to validate
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IField.KeyField">
            <summary>
            Indicates whether a field is a(part of) key field
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IField.Modified">
            <summary>
            Indicates that field value has changed
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IField.GUIModified">
            <summary>
            Indicates that field value has changed through user action in GUI
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IField.Calculated">
            <summary>
            Indicates that the field value is calculated
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IField.AllowCalculationOverride">
            <summary>
            Indicates whether field calculation formula can be overridden
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IField.CalculationError">
            <summary>
            Returns calculation formula error
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IField.Overridden">
            <summary>
            Indicates whether calculation formula was overridden
            </summary>
        </member>
        <member name="P:NFX.RecordModel.IField`1.Value">
            <summary>
            Typed field value
            </summary>
        </member>
        <member name="T:NFX.RecordModel.ObjectField`1">
            <summary> Represents fields that store generic objects </summary>
        </member>
        <member name="T:NFX.RecordModel.StringField">
            <summary> Represents fields that store string </summary>
        </member>
        <member name="P:NFX.RecordModel.StringField.Size">
            <summary>
            Imposes a limit on string field length in characters, 0 = Unlimited
            </summary>
        </member>
        <member name="P:NFX.RecordModel.StringField.FormatRegExp">
            <summary>
            Imposes a regular expression validation on this field
            </summary>
        </member>
        <member name="P:NFX.RecordModel.StringField.FormatRegExpDescription">
            <summary>
            Provides description for format regular expression
            </summary>
        </member>
        <member name="P:NFX.RecordModel.StringField.DataEntryFormat">
            <summary>
            Determines formatting/masking applied during data entry
            </summary>
        </member>
        <member name="P:NFX.RecordModel.StringField.CharCase">
            <summary>
            Determines data entry character casing for string fields
            </summary>
        </member>
        <member name="P:NFX.RecordModel.StringField.Password">
            <summary>
            Determines whether field stores a password value
            </summary>
        </member>
        <member name="T:NFX.RecordModel.DataSetField">
            <summary> Represents fields that store dataset </summary>
        </member>
        <member name="T:NFX.RecordModel.DataTableField">
            <summary> Represents fields that store datatable </summary>
        </member>
        <member name="T:NFX.RecordModel.IntField">
            <summary> Represents fields that store integers </summary>
        </member>
        <member name="T:NFX.RecordModel.LongField">
            <summary> Represents fields that store long integers </summary>
        </member>
        <member name="T:NFX.RecordModel.ShortField">
            <summary> Represents fields that store short integers </summary>
        </member>
        <member name="T:NFX.RecordModel.DecimalField">
            <summary> Represents fields that store decimals </summary>
        </member>
        <member name="T:NFX.RecordModel.DateTimeField">
            <summary> Represents fields that store date and time </summary>
        </member>
        <member name="T:NFX.RecordModel.TimeSpanField">
            <summary> Represents fields that store time span </summary>
        </member>
        <member name="T:NFX.RecordModel.DoubleField">
            <summary> Represents fields that store double </summary>
        </member>
        <member name="T:NFX.RecordModel.FloatField">
            <summary> Represents fields that store float </summary>
        </member>
        <member name="T:NFX.RecordModel.BoolField">
            <summary> Represents fields that store boolean </summary>
        </member>
        <member name="T:NFX.RecordModel.GuidField">
            <summary> Represents fields that store Guid structs </summary>
        </member>
        <member name="T:NFX.RecordModel.FieldPropertyDescriptor">
            <summary>
            Provides component model description for properties of type Field
            </summary>
        </member>
        <member name="T:NFX.RecordModel.GUIDataParser">
            <summary>
            Provides data-entry parsing routines
            </summary>
        </member>
        <member name="M:NFX.RecordModel.GUIDataParser.NormalizeEnteredString(System.String,NFX.RecordModel.DataEntryFormat,System.Globalization.CultureInfo)">
            <summary>
            Normalizes entered string according to supplied format and culture. Normalization is done by
             adding characters so data looks more standard, i.e. adding dashes and hyphens to phone numbers etc.
            May throw exception if normalization is not possible i.e. normalize "uiug" as currency 
            </summary>
        </member>
        <member name="T:NFX.RecordModel.ListOf`1">
            <summary>
            Implements a list of T that is used by ListField class
            </summary>
        </member>
        <member name="T:NFX.RecordModel.ListField`1">
            <summary> Represents fields that maintain list of generic objects </summary>
        </member>
        <member name="P:NFX.RecordModel.ListField`1.List">
            <summary>
            Same as .Value
            </summary>
        </member>
        <member name="T:NFX.RecordModel.LookupDictionary">
            <summary>
            Represents a collection of strings with lookup key/description dictionary functionality
            </summary>
        </member>
        <member name="M:NFX.RecordModel.LookupDictionary.FindKey(System.String)">
            <summary>
            Tries to find a key and returns true if key was found
            </summary>
        </member>
        <member name="M:NFX.RecordModel.LookupDictionary.Add(System.String[])">
            <summary>
            Adds items to dictionary
            </summary>
        </member>
        <member name="M:NFX.RecordModel.LookupDictionary.Include(System.String)">
            <summary>
            Includes choice in dictionary if it was not already included
            </summary>
        </member>
        <member name="M:NFX.RecordModel.LookupDictionary.Exclude(System.String)">
            <summary>
            Excludes choice from dictionary if it was already included 
            </summary>
        </member>
        <member name="P:NFX.RecordModel.LookupDictionary.Separator">
            <summary>
            Separator character that delimits key and description
            </summary>
        </member>
        <member name="P:NFX.RecordModel.LookupDictionary.Item(System.String)">
            <summary>
            Finds description by key or null
            </summary>
        </member>
        <member name="P:NFX.RecordModel.LookupDictionary.Keys">
            <summary>
            Returns all keys enumeration
            </summary>
        </member>
        <member name="T:NFX.RecordModel.ChangeNotifications">
            <summary>
            Represents a list of notifications
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ChangeNotifications.AddNotification(NFX.RecordModel.Notification)">
            <summary>
            Add notification to the list ensuring notification-type uniqueness
            </summary>
        </member>
        <member name="M:NFX.RecordModel.ChangeNotifications.MergeNotifications(NFX.RecordModel.ChangeNotifications)">
            <summary>
            Combines notifications with other source ensuring notification-type uniqueness
            </summary>
        </member>
        <member name="T:NFX.RecordModel.Notification">
            <summary>
            Represents a notification message sent from controllers to views through bindings
            </summary>
        </member>
        <member name="T:NFX.RecordModel.InteractabilityChangeNotification">
            <summary>
            Sent when Enabled/Visible/Readonly/Applicable change
            </summary>
        </member>
        <member name="T:NFX.RecordModel.PresentationChangeNotification">
            <summary>
            Sent when Description, Marked and other change that require presentation change and view repaint
            </summary>
        </member>
        <member name="T:NFX.RecordModel.DataEntryTypeChangeNotification">
            <summary>
            Sent when data-entry method changes and attached view needs to be rebuilt
            </summary>
        </member>
        <member name="T:NFX.RecordModel.ValidationNotification">
            <summary>
            Sent when model was validated, model may or may not be Valid after validation
            </summary>
        </member>
        <member name="T:NFX.RecordModel.Record">
            <summary>
            Provides base record-management model functionality. View controls are bound to records 
            </summary>
        </member>
        <member name="M:NFX.RecordModel.Record.Build``1(``0)">
            <summary>
            Main method for creation of new record instances which is faster than Make&lt;T&gt; 
            </summary>
            <typeparam name="T">A instance of record to build</typeparam>
            <returns>New record instance initialized with default state</returns>
        </member>
        <member name="M:NFX.RecordModel.Record.Make``1">
            <summary>
            Main method for creation of new record instances. 
            2013 Update: for performance use Build(T) instead
            </summary>
            <typeparam name="T">A type of record to create</typeparam>
            <returns>New record instance initialized with default state</returns>
        </member>
        <member name="M:NFX.RecordModel.Record.Make(System.Type)">
            <summary>
            Main method for creation of new record instances
            </summary>
            <param name="type">A type of record to create</param>
            <returns>New record instance initialized with default state</returns>
        </member>
        <member name="M:NFX.RecordModel.Record.Make(System.String)">
            <summary>
            Main method for creation of new record instances
            </summary>
            <param name="typeName">A type name of record to create</param>
            <returns>New record instance initialized with default state</returns>
        </member>
        <member name="F:NFX.RecordModel.Record.NoBuildCrosschecks">
            <summary>
            Suppresses record crosschecks like duplicate field name detection so record construction speed increases significantly.
            Set to true in ConstructFields override while setting field names, or use attribute on Record-derived class
            </summary>
        </member>
        <member name="M:NFX.RecordModel.Record.Load(NFX.DataAccess.IDataStoreKey,System.Object[])">
            <summary>
            Initializes an instance for data loading and loads data from Application model data store.
            </summary>
        </member>
        <member name="M:NFX.RecordModel.Record.Save">
            <summary>
            Saves data into Application model data store under this instance's DataStoreKey
            </summary>
        </member>
        <member name="M:NFX.RecordModel.Record.Save(NFX.DataAccess.IDataStoreKey,System.Object[])">
            <summary>
            Saves data into Application model data store using specified key. If key is null then provider may elect to build key from fields with KeyField attribute set to true
            </summary>
        </member>
        <member name="M:NFX.RecordModel.Record.Delete">
            <summary>
            Deletes data from Application model data store under this instance's DataStoreKey.
            After this call model state is DataState.Uninitialized
            </summary>
        </member>
        <member name="M:NFX.RecordModel.Record.Delete(NFX.DataAccess.IDataStoreKey,System.Object[])">
            <summary>
            Deletes data from Application model data with specified key. When key is omitted instance's DataStoreKey is used.
            After this call model state is DataState.Uninitialized
            </summary>
        </member>
        <member name="M:NFX.RecordModel.Record.Log(NFX.Log.Message)">
            <summary>
            Outputs log message to application log
            </summary>
        </member>
        <member name="M:NFX.RecordModel.Record.Log(NFX.Log.MessageType,System.String)">
            <summary>
            Outputs log message to application log
            </summary>
        </member>
        <member name="M:NFX.RecordModel.Record.FindFieldByName(System.String)">
            <summary>
            Tries to find a field by name or returns null if such named field was not found
            </summary>
        </member>
        <member name="M:NFX.RecordModel.Record.ResetModified">
            <summary>
            Resets Modified flag to false for all fields
            </summary>
        </member>
        <member name="M:NFX.RecordModel.Record.ResetGUIModified">
            <summary>
            Resets Modified flag to false for all fields
            </summary>
        </member>
        <member name="M:NFX.RecordModel.Record.ctor_MakeRecordInstanceFromScratch">
            <summary>
            Normally .ctors should never be overridden.
            This is because records may be rehydrated from some storage (i.e. stream) and only default cotr will be called.
            However, for some records that are not serializable, when parametrized .ctors are needed
             this method should be called as the last .ctor line
            </summary>
        </member>
        <member name="M:NFX.RecordModel.Record.ConstructFields">
            <summary>
            Performs record field construction/allocation. Override to build fields in code
            </summary>
        </member>
        <member name="M:NFX.RecordModel.Record.GetAttributes">
            <summary>
            Implements ICustomTypeDescriptor used by component designers
            </summary>
        </member>
        <member name="M:NFX.RecordModel.Record.GetClassName">
            <summary>
            Implements ICustomTypeDescriptor used by component designers
            </summary>
        </member>
        <member name="M:NFX.RecordModel.Record.GetComponentName">
            <summary>
            Implements ICustomTypeDescriptor used by component designers
            </summary>
        </member>
        <member name="M:NFX.RecordModel.Record.GetConverter">
            <summary>
            Implements ICustomTypeDescriptor used by component designers
            </summary>
        </member>
        <member name="M:NFX.RecordModel.Record.GetDefaultEvent">
            <summary>
            Implements ICustomTypeDescriptor used by component designers
            </summary>
        </member>
        <member name="M:NFX.RecordModel.Record.GetDefaultProperty">
            <summary>
            Implements ICustomTypeDescriptor used by component designers
            </summary>
        </member>
        <member name="M:NFX.RecordModel.Record.GetEditor(System.Type)">
            <summary>
            Implements ICustomTypeDescriptor used by component designers
            </summary>
        </member>
        <member name="M:NFX.RecordModel.Record.GetEvents(System.Attribute[])">
            <summary>
            Implements ICustomTypeDescriptor used by component designers
            </summary>
        </member>
        <member name="M:NFX.RecordModel.Record.GetEvents">
            <summary>
            Implements ICustomTypeDescriptor used by component designers
            </summary>
        </member>
        <member name="M:NFX.RecordModel.Record.GetProperties(System.Attribute[])">
            <summary>
            Implements ICustomTypeDescriptor used by component designers
            </summary>
        </member>
        <member name="M:NFX.RecordModel.Record.GetProperties">
            <summary>
            Implements ICustomTypeDescriptor used by component designers
            </summary>
        </member>
        <member name="M:NFX.RecordModel.Record.GetPropertyOwner(System.ComponentModel.PropertyDescriptor)">
            <summary>
            Implements ICustomTypeDescriptor used by component designers
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Record.RecordName">
            <summary>
            Provides a user-meaningful name for the record
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Record.TableName">
            <summary>
            Provides table name that this record comes/goes from/to
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Record.DesignTimeSurrogate">
            <summary>
            Indicates that this record instance was created in design-time from string type name and does not
             represent a real record instance
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Record.Item(System.String)">
            <summary>
            Provides access to fields by name. Exception is thrown if a field with such a name does not exist in this record
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Record.Fields">
            <summary>
            Provides access to all fields that a record contains
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Record.ModifiedFields">
            <summary>
            Provides access to all record fields that have been modified
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Record.GUIModifiedFields">
            <summary>
            Provides access to all record fields that have been modified through GUI
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Record.HasModifiedFields">
            <summary>
            Returns true when record contains modified fields
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Record.HasGUIModifiedFields">
            <summary>
            Returns true when record contains fields modified from GUI
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Record.InvalidFields">
            <summary>
            Provides access to all record fields that either have not validated yet or could not be validated 
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Record.InvalidValidatedFields">
            <summary>
            Provides access to all record fields that have validated but not valid 
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Record.ValidFields">
            <summary>
            Provides access to all record fields that have passed validation
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Record.FieldValidationExceptionMessages">
            <summary>
            Returns validation exception messages for all fields 
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Record.AllValidationExceptionMessages">
            <summary>
            Returns validation exception messages concatenated into one string 
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Record.FieldValidationSuspended">
            <summary>
            Indicates whether validation was suspended for all fields until record post
            </summary>
        </member>
        <member name="P:NFX.RecordModel.Record.CaseSensitiveFieldBinding">
            <summary>
            Controls whether field search is or is not case sensitive
            </summary>
        </member>
        <member name="E:NFX.RecordModel.Record.FieldDataChanging">
            <summary>
            Event fired before field's value is about to change. Throw exceptions to abort the change
            </summary>
        </member>
        <member name="E:NFX.RecordModel.Record.FieldDataChanged">
            <summary>
            Event fired after field's value has changed
            </summary>
        </member>
        <member name="T:NFX.RecordModel.RecordBinding">
            <summary>
            Provides an abstract base for record view bindings. Concrete binding implementations are defined by 
            actual presentation classes that may be (but certainly not limited to) derivatives of standard 
            controls such as WinForms.PropertyGrid, ASPNet.Grid etc. 
            A binding serves two purposes:
             links a control with a record instance (hence the name)
             and allows control to react to changes in a record (model)
            </summary>
        </member>
        <member name="M:NFX.RecordModel.RecordBinding.#ctor(System.Object)">
            <summary>
            Creates an instance of binding, setting an owner reference to an instance of a concrete GUI class
            that is allocating this binding and what this binding provides services for
            </summary>
        </member>
        <member name="M:NFX.RecordModel.RecordBinding.SetValueFromGUI(System.Object)">
            <summary>
            Sets value from view binding. This method is used to commit data from view controls into fields
            </summary>
        </member>
        <member name="M:NFX.RecordModel.RecordBinding.Attach(NFX.RecordModel.Record)">
            <summary>
            Attaches binding to a particular record
            </summary>
        </member>
        <member name="T:NFX.RecordModel.DesignerRecordBinding">
            <summary>
            Simple record binding used by custom designers
            </summary>
        </member>
        <member name="T:NFX.Security.AccessLevel">
            <summary>
            A level of access granted to user for certain permission, i.e. if (level.Denied).....
            </summary>
        </member>
        <member name="P:NFX.Security.AccessLevel.User">
            <summary>
            Returns user that this access level is for
            </summary>
        </member>
        <member name="P:NFX.Security.AccessLevel.Permission">
            <summary>
            Returns permission that this access level is for
            </summary>
        </member>
        <member name="P:NFX.Security.AccessLevel.Data">
            <summary>
            Returns security data for this level
            </summary>
        </member>
        <member name="P:NFX.Security.AccessLevel.Level">
            <summary>
            Returns security level attribute from Data
            </summary>
        </member>
        <member name="P:NFX.Security.AccessLevel.Denied">
            <summary>
            Indicates whether access is denied
            </summary>
        </member>
        <member name="T:NFX.Security.ConfigSecurityManager">
            <summary>
            Provides security manager implementation that authenticates and authorizes users from configuration
            </summary>
        </member>
        <member name="T:NFX.Security.ISecurityManagerImplementation">
            <summary>
            Represents an implementation of an entity that performs user authentication based on passed credentials and other security-related global tasks
            </summary>
        </member>
        <member name="T:NFX.Security.ISecurityManager">
            <summary>
            Represents an entity that performs user authentication based on passed credentials and other security-related global tasks
            </summary>
        </member>
        <member name="M:NFX.Security.ISecurityManager.Authenticate(NFX.Security.Credentials)">
            <summary>
            Authenticates user by checking the supplied credentials against the
            authentication store that this manager represents.
            If credential are invalid then UserKind.Invalid is returned.
            This method may populate user access rights completely or partially - depending on store implementation.
            If rights are computed on authentication than Authorize() just checks existing in-memory structure, otherwise
             Authorize() may re-fetch permissions from store on every call or cache them for the specified interval in memory
            </summary>
            <param name="credentials">User credentials. 
            Particular manager implementation may elect to support multiple credential types, i.e.
            IdPassword, Twitter, Facebook, OAuth, LegacySystemA/B/C etc.
            </param>
            <returns>
            User object. Check User.Status for UserStatus.Invalid flag to see if authentication succeeded
            </returns>
        </member>
        <member name="M:NFX.Security.ISecurityManager.Authenticate(NFX.Security.AuthenticationToken)">
            <summary>
            Authenticates user by checking the supplied token against the
            authentication store that this manager represents.
            If token is invalid then UserKind.Invalid is returned.
            This method may populate user access rights completely or partially - depending on store implementation.
            If rights are computed on authentication than Authorize() just checks existing in-memory structure, otherwise
             Authorize() may re-fetch permissions from store on every call or cache them for the specified interval in memory
            </summary>
            <param name="token">User authentication token </param>
            <returns>
            User object. Check User.Status for UserStatus.Invalid flag to see if authentication succeeded
            </returns>
        </member>
        <member name="M:NFX.Security.ISecurityManager.Authenticate(NFX.Security.User)">
            <summary>
            Authenticates user by checking the supplied user's token against the
            authentication store that this manager represents.
            This method is called by the framework after User object was deserialized and it's Rights need to be re-fetched.
            If token is invalid then UserStatus.Invalid is set.
            This method may populate user access rights completely or partially - depending on store implementation.
            If rights are computed on authentication than Authorize() just checks existing in-memory structure, otherwise
             Authorize() may re-fetch permissions from store on every call or cache them for the specified interval in memory
            </summary>
            <param name="user">User object which is checked and updated</param>
        </member>
        <member name="M:NFX.Security.ISecurityManager.Authorize(NFX.Security.User,NFX.Security.Permission)">
            <summary>
            Authorizes user by finding appropriate access level to permission by supplied path.
            Depending on particular implementation, rights may be fully or partially cached in memory.
            Note: this authorization call returns AccessLevel object that may contain a complex data structure.
            The final assertion of user's ability to perform a certain action is encapsulated in Permission.Check() method.
            Call Permission.AuthorizeAndGuardAction(MemberInfo, ISession) to guard classes and methods from unauthorized access
            </summary>
            <param name="user">A user to perform authorization for</param>
            <param name="permission">An instance of permission to get</param>
            <returns>AccessLevel granted to specified permission</returns>
        </member>
        <member name="M:NFX.Security.ConfigSecurityManager.#ctor">
            <summary>
            Constructs security manager that authenticates users listed in application configuration
            </summary>
        </member>
        <member name="M:NFX.Security.ConfigSecurityManager.#ctor(NFX.Environment.IConfigSectionNode)">
            <summary>
            Constructs security manager that authenticates users listed in the supplied configuration section
            </summary>
        </member>
        <member name="P:NFX.Security.ConfigSecurityManager.Config">
            <summary>
            Returns config node that this instance is configured from.
            If null is returned then manager performs authentication from application configuration
            </summary>
        </member>
        <member name="T:NFX.Security.AuthenticationToken">
            <summary>
            Represents security provider-internal ID that SecurityManager assigns into User object on authentication.
            These tokens can be used in place of Credentials to re-authenticate users or to requery user rights.
            External parties should never be supplied with this struct as it is backend-internal 
            </summary>
        </member>
        <member name="P:NFX.Security.AuthenticationToken.Realm">
            <summary>
            Provides information about back-end security source (realm) that perfomed authentication, i.e. LDAP instance, Database name etc...
            </summary>
        </member>
        <member name="P:NFX.Security.AuthenticationToken.Data">
            <summary>
            Provides provider-specific key/id that uniquely identifies the user in the realm
            </summary>
        </member>
        <member name="T:NFX.Security.BlankCredentials">
            <summary>
            Represents credentials that are absent. This is a singleton class
            </summary>
        </member>
        <member name="P:NFX.Security.BlankCredentials.Instance">
            <summary>
            Singleton instance of blank credentials
            </summary>
        </member>
        <member name="T:NFX.Security.UserStatus">
            <summary>
            User status enumeration -  super-permission levels
            </summary>
        </member>
        <member name="F:NFX.Security.UserStatus.Invalid">
            <summary>
            Invalid user, not authenticated and not authorized
            </summary>
        </member>
        <member name="F:NFX.Security.UserStatus.User">
            <summary>
            The lowest level of a user, bound by permissions inside their domain and domain section (such as facility)
            </summary>
        </member>
        <member name="F:NFX.Security.UserStatus.Administrator">
            <summary>
            Administrators may run administration console, but always bound by their domain 
            </summary>
        </member>
        <member name="F:NFX.Security.UserStatus.System">
            <summary>
            Cross domain user, all restrictions are lifted
            </summary>
        </member>
        <member name="T:NFX.Security.SecurityException">
            <summary>
            Base exception thrown by the Security framework
            </summary>
        </member>
        <member name="T:NFX.Security.ISecurityException">
            <summary>
            Marker interface for security exceptions
            </summary>
        </member>
        <member name="T:NFX.Security.AuthorizationException">
            <summary>
            Base exception thrown by the security framework
            </summary>
        </member>
        <member name="T:NFX.Security.IDPasswordCredentials">
            <summary>
            Represents simple ID/password textual credentials
            </summary>
        </member>
        <member name="M:NFX.Security.IDPasswordCredentials.Forget">
            <summary>
            Deletes sensitive password information.
            This method is mostly used on client (vs. server) to prevent process memory-inspection attack.
            Its is usually called right after Login() was called.
            Implementers may consider forcing post-factum GC.Collect() on all generations to make sure that orphaned 
            memory buff with sensitive information, that remains in RAM even after all references are killed, gets
            compacted. This class implementation DOES NOT call Gc.Collect();
            </summary>
        </member>
        <member name="T:NFX.Security.NOPSecurityManager">
            <summary>
            Provides security manager implementation that does nothing and always returns fake user instance
            </summary>
        </member>
        <member name="T:NFX.Security.GetSessionFunc">
            <summary>
            Invoked by permission checker to get session
            </summary>
        </member>
        <member name="T:NFX.Security.Permission">
            <summary>
            Represents a general permission abstraction - where permission type represents the path/name of the permission
             in User's rights and .ctor takes specific parameters to check while authorizing user.
             Permission-derived class represents a certain permission type, whereas its instance is a check for particular desired level.
             To authorize certain actions, one creates an instance of Permission-derived class passing in its .ctor required
              access levels, then calls a Check() method that returns true if action is authorized. 
              
            This scheme provides a great deal of flexibility, i.e. for very complex security cases developers may inherit leaf-level permissions from intermediate ones
              that have logic tied to session-level variables, this way user's access may vary by permission/session state, i.e. a user may have 
               "Patient.Master" level 4 access in database "A", while having acess denied to the same named permission in database "B".
            User's database, or system instance is a flag in user-session context   
            </summary>
        </member>
        <member name="M:NFX.Security.Permission.AuthorizeAction(System.Reflection.MemberInfo,NFX.ApplicationModel.ISession,NFX.Security.GetSessionFunc)">
            <summary>
            Checks the action represented by MemberInfo by checking the permission-derived attributes and returns false if 
            any of authorization attributes do not pass
            </summary>
        </member>
        <member name="M:NFX.Security.Permission.FindAuthorizationFailingPermission(System.Reflection.MemberInfo,NFX.ApplicationModel.ISession,NFX.Security.GetSessionFunc)">
            <summary>
            Checks the action represented by MemberInfo by checking the permission-derived attributes and returns false if 
            any of authorization attributes do not pass
            </summary>
        </member>
        <member name="M:NFX.Security.Permission.AuthorizeAndGuardAction(System.Reflection.MemberInfo,NFX.ApplicationModel.ISession,NFX.Security.GetSessionFunc)">
            <summary>
            Guards the action represented by MemberInfo by checking the permission-derived attributes and throwing exception if 
            any of authorization attributes do not pass
            </summary>
        </member>
        <member name="M:NFX.Security.Permission.AuthorizeAndGuardAction(System.Collections.Generic.IEnumerable{NFX.Security.Permission},System.String,NFX.ApplicationModel.ISession,NFX.Security.GetSessionFunc)">
            <summary>
            Guards the action represented by enumerable of permissions by checking all permissions and throwing exception if 
            any of authorization attributes do not pass
            </summary>
        </member>
        <member name="M:NFX.Security.Permission.MultipleFromConf(NFX.Environment.IConfigSectionNode)">
            <summary>
            Makes multiple permissions from conf node
            </summary>
        </member>
        <member name="M:NFX.Security.Permission.#ctor(System.Int32)">
            <summary>
            Creates the check instance against the minimum access level for this permission
            </summary>
        </member>
        <member name="M:NFX.Security.Permission.Check(NFX.ApplicationModel.ISession)">
            <summary>
            Checks the permission for requested action as specified in particular permission .ctor.
            The check is performed in the scope of supplied session, or if no session was supplied then 
             current execution context session is assumed
            </summary>
            <returns>True when action is authorized, false otherwise</returns>
        </member>
        <member name="P:NFX.Security.Permission.Name">
            <summary>
            Returns the permission name - the last segment of the path
            </summary>
        </member>
        <member name="P:NFX.Security.Permission.Description">
            <summary>
            Returns the permission description - base implementation returns permission name
            </summary>
        </member>
        <member name="P:NFX.Security.Permission.Path">
            <summary>
            Returns a top-rooted path to this permission (without name)
            </summary>
        </member>
        <member name="P:NFX.Security.Permission.FullPath">
            <summary>
            Returns full permission path - a concatenation of its path and name
            </summary>
        </member>
        <member name="P:NFX.Security.Permission.Level">
            <summary>
            Specifies the minimum access level for the permission check to pass
            </summary>
        </member>
        <member name="T:NFX.Security.TypedPermission">
            <summary>
            A general ancestor for all typed permissions - the ones declared in code
            </summary>
        </member>
        <member name="M:NFX.Security.TypedPermission.#ctor(System.Int32)">
            <summary>
            Creates the check instance against the minimum access level for this typed permission
            </summary>
        </member>
        <member name="T:NFX.Security.AdHocPermission">
            <summary>
            Represents a permission check instance which is a-typical and is based on string arguments
            </summary>
        </member>
        <member name="P:NFX.Security.AdHocPermission.Name">
            <summary>
            Returns the permission name - the last segment of the path
            </summary>
        </member>
        <member name="P:NFX.Security.AdHocPermission.Path">
            <summary>
            Returns a top-rooted path to this permission (without name)
            </summary>
        </member>
        <member name="T:NFX.Security.Rights">
            <summary>
            User rights contains data about access levels to permissions in the system.
            Use Configuration internally to keep the data organized in hierarchical navigable structure.
            Configuration also allows to cross-link permission levels using vars and make acess level
             dependent on settings on a particular machine using environmental vars
            </summary>
        </member>
        <member name="P:NFX.Security.Rights.None">
            <summary>
            An instance that signifies an absence of any rights at all - complete access denied
            </summary>
        </member>
        <member name="T:NFX.Security.User">
            <summary>
            Provides base user functionality. Particular security manager implementations may return users derived from this class 
            </summary>
        </member>
        <member name="M:NFX.Security.User.Invalidate">
            <summary>
            Makes user invalid
            </summary>
        </member>
        <member name="M:NFX.Security.User.___reset_data(NFX.Security.UserStatus,System.String,System.String,NFX.Security.Rights)">
            <summary>
            Framework-internal. Do not call
            </summary>
        </member>
        <member name="M:NFX.Security.User.IsInRole(System.String)">
            <summary>
            Determines whether the current principal belongs to the specified role.
            This method implements IPrincipal and has little application in NFX framework context
            as NFX permissions are more granular than just boolean. This method really checks user kind (User/Admin/Sys).
            Confusion comes from the fact that what Microsoft calls role really is just a single named permission -
             a role is a named permission set in NFX.
            </summary>
        </member>
        <member name="P:NFX.Security.User.Fake">
            <summary>
            Returns default instance of the fake user that has no rights
            </summary>
        </member>
        <member name="P:NFX.Security.User.Rights">
            <summary>
            Returns data bag that contains user rights. This is a framework-only internal property
             which should not be used by application developers. This bag may get populated fully-or-partially
              by ISecurityManager implementation. Use User[permission] indexer or Application.SecurityManager.Authorize() 
               to obtain AccessLevel
            </summary>
        </member>
        <member name="P:NFX.Security.User.Item(NFX.Security.Permission)">
            <summary>
            Authorizes user to specified permission.
            Note: this authorization call returns AccessLevel object that may contain a complex data structure.
            The final assertion of user's ability to perform a certain action is encapsulated in Permission.Check() method.
            Call Permission.AuthorizeAndGuardAction(MemberInfo, ISession) to guard classes and methods from unauthorized access
            </summary>
        </member>
        <member name="P:NFX.Security.User.AuthenticationType">
            <summary>
            Implementation of IIdentity interface
            </summary>
        </member>
        <member name="P:NFX.Security.User.IsAuthenticated">
            <summary>
            Implementation of IIdentity interface. Checks to see if user is not in invalid status
            </summary>
        </member>
        <member name="P:NFX.Security.User.Identity">
            <summary>
            Implementation of IPrincipal interface
            </summary>
        </member>
        <member name="T:NFX.IO.SlimReader">
            <summary>
            Reads primitives and other supported types from Slim-format stream. Use factory method of SlimFormat intance to create a new instance of SlimReader class
            </summary>
        </member>
        <member name="P:NFX.IO.SlimReader.Format">
            <summary>
            Returns SlimFormat that this reader implements
            </summary>
        </member>
        <member name="T:NFX.Serialization.JSON.JSONException">
            <summary>
            Base exception thrown by the JSON serialization format
            </summary>
        </member>
        <member name="T:NFX.Serialization.NFXSerializationException">
            <summary>
            Base exception thrown by the serialization-related classes 
            </summary>
        </member>
        <member name="T:NFX.Serialization.JSON.JSONSerializationException">
            <summary>
            Base exception thrown by the JSON when serializing objects
            </summary>
        </member>
        <member name="T:NFX.Serialization.JSON.JSONDeserializationException">
            <summary>
            Base exception thrown by the JSON when deserializing objects
            </summary>
        </member>
        <member name="T:NFX.Serialization.JSON.JSONDynamicObjectKind">
            <summary>
            Specifies what kind the dynamic object is - map or array
            </summary>
        </member>
        <member name="T:NFX.Serialization.JSON.JSONDynamicObject">
            <summary>
            Implements a JSON dynamic object that shapes itself at runtime
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONDynamicObject.#ctor(NFX.Serialization.JSON.JSONDynamicObjectKind,System.Boolean)">
            <summary>
            Creates a dynamic wrapper around existing array or map. Optionally specifies map key case sensitivity
            </summary>
        </member>
        <member name="P:NFX.Serialization.JSON.JSONDynamicObject.Data">
            <summary>
            Returns the underlying JSON data
            </summary>
        </member>
        <member name="T:NFX.Serialization.JSON.JSONReader">
            <summary>
            Provides deserialization functionality from JSON format
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONReader.ToRow(System.Type,NFX.Serialization.JSON.JSONDataMap,System.Boolean)">
            <summary>
            Converts JSONMap into typed row of the requested type. 
            The requested type must be derived from NFX.DataAccess.CRUD.TypedRow.
            The extra data found in JSON map will be placed in AmorphousData dictionary if the row implemets IAmorphousData, discarded otherwise.
            Note: This method provides "the best match" and does not guarantee that all data will/can be converted from JSON, i.e.
             it can only convert one dimensional arrays and Lists of either primitive or TypeRow-derived entries
            </summary>
            <param name="type">TypedRow subtype to convert into</param>
            <param name="jsonMap">JSON data to convert into row</param>
            <param name="fromUI">When true indicates that data came from UI, hence NonUI-marked fields should be skipped. True by default</param>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONReader.ToRow``1(NFX.Serialization.JSON.JSONDataMap,System.Boolean)">
            <summary>
            Generic version of 
            <see cref="M:NFX.Serialization.JSON.JSONReader.ToRow(System.Type,NFX.Serialization.JSON.JSONDataMap,System.Boolean)"/>
            </summary>
            <typeparam name="T">TypedRow</typeparam>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONReader.ToRow(NFX.DataAccess.CRUD.Row,NFX.Serialization.JSON.JSONDataMap,System.Boolean)">
            <summary>
            Converts JSONMap into supplied row instance. 
            The extra data found in JSON map will be placed in AmorphousData dictionary if the row implemets IAmorphousData, discarded otherwise.
            Note: This method provides "the best match" and does not guarantee that all data will/can be converted from JSON, i.e.
             it can only convert one dimensional arrays and Lists of either primitive or TypeRow-derived entries
            </summary>
            <param name="row">Row instance to convert into</param>
            <param name="jsonMap">JSON data to convert into row</param>
            <param name="fromUI">When true indicates that data came from UI, hence NonUI-marked fields should be skipped. True by default</param>
        </member>
        <member name="T:NFX.Serialization.JSON.JSONSerializationPurpose">
            <summary>
            Specifies the purpose of JSON serialization so the level of detail may be dynamically adjusted.
            Depending on this parameter IJSONWritable implementors may include additional details
            that are otherwise not needed
            </summary>
        </member>
        <member name="F:NFX.Serialization.JSON.JSONSerializationPurpose.UIFeed">
            <summary>
            UI Interface feeding - include only the data needed to show to the user
            </summary>
        </member>
        <member name="F:NFX.Serialization.JSON.JSONSerializationPurpose.Marshalling">
            <summary>
            Include as much data as possible for remote object reconstruction
            </summary>
        </member>
        <member name="T:NFX.Serialization.JSON.JSONWritingOptions">
            <summary>
            Specifies how JSON should be written as text. Use JSONWritingOptions.Compact or JSONWritingOptions.PrettyPrint
             static properties for typical options
            </summary>
        </member>
        <member name="F:NFX.Serialization.JSON.JSONWritingOptions.IndentWidth">
            <summary>
            Specifies character width of single indent level
            </summary>
        </member>
        <member name="F:NFX.Serialization.JSON.JSONWritingOptions.SpaceSymbols">
            <summary>
            Indicates whether a space must be placed right after the symbol, such as coma in array declaration or colon in member declaration for
             better readability
            </summary>
        </member>
        <member name="F:NFX.Serialization.JSON.JSONWritingOptions.ObjectLineBreak">
            <summary>
            Specifies whether objects need to be separated by line brakes for better readability
            </summary>
        </member>
        <member name="F:NFX.Serialization.JSON.JSONWritingOptions.MemberLineBreak">
            <summary>
            Specifies whether every object member must be placed on a separate line for better readability
            </summary>
        </member>
        <member name="F:NFX.Serialization.JSON.JSONWritingOptions.ASCIITarget">
            <summary>
            Specifies whether the target of serialization only deals with ASCII characeters,
            so any non-ASCII character with code above 127 must be escaped with unicode escape sequence
            </summary>
        </member>
        <member name="F:NFX.Serialization.JSON.JSONWritingOptions.ISODates">
            <summary>
            Specifies whether DateTime must be encoded using ISO8601 format that look like "2011-03-18T14:25:00Z",
            otherwise dates are encoded using "new Date(milliseconds_since_unix_epoch)" which is technically not a valid JSON, however
             most JSON parsers understand it very well
            </summary>
        </member>
        <member name="F:NFX.Serialization.JSON.JSONWritingOptions.MaxNestingLevel">
            <summary>
            Sets a limit of object nesting, i.e. for recursive graph depth. Default is 0xff
            </summary>
        </member>
        <member name="F:NFX.Serialization.JSON.JSONWritingOptions.RowsAsMap">
            <summary>
            When true, writes every row as a map {FieldName: FieldValue,...} instead of array of values
            </summary>
        </member>
        <member name="F:NFX.Serialization.JSON.JSONWritingOptions.RowsetMetadata">
            <summary>
            When true, writes rowset metadata (i.e. schema, intsnace id etc.)
            </summary>
        </member>
        <member name="F:NFX.Serialization.JSON.JSONWritingOptions.Purpose">
            <summary>
            Specifies the purpose of JSON serialization so the level of detail may be dynamically adjusted.
            Depending on this parameter IJSONWritable implementors may include additional details
            that are otherwise not needed
            </summary>
        </member>
        <member name="P:NFX.Serialization.JSON.JSONWritingOptions.Compact">
            <summary>
            Writes JSON without line breaks between members and no indenting. Suitable for data transmission
            </summary>
        </member>
        <member name="P:NFX.Serialization.JSON.JSONWritingOptions.CompactRowsAsMap">
            <summary>
            Writes JSON without line breaks between members and no indenting writing rows as maps(key:values) instead of arrays. Suitable for data transmission
            </summary>
        </member>
        <member name="P:NFX.Serialization.JSON.JSONWritingOptions.CompactASCII">
            <summary>
            Writes JSON without line breaks between members and no indenting escaping any characters 
             with codes above 127 suitable for ASCII transmission
            </summary>
        </member>
        <member name="P:NFX.Serialization.JSON.JSONWritingOptions.PrettyPrint">
            <summary>
            Writes JSON suitable for printing/screen display
            </summary>
        </member>
        <member name="P:NFX.Serialization.JSON.JSONWritingOptions.PrettyPrintRowsAsMap">
            <summary>
            Writes JSON suitable for printing/screen display writing rows as maps(key:values) instead of arrays
            </summary>
        </member>
        <member name="T:NFX.Serialization.MSBinaryFormatter">
            <summary>
            Implements ISerializer with Ms BinaryFormatter
            </summary>
        </member>
        <member name="T:NFX.Serialization.ISerializer">
            <summary>
            Describes an entity that can serialize and deserialize objects
            </summary>
        </member>
        <member name="P:NFX.Serialization.ISerializer.IsThreadSafe">
            <summary>
            Indicates whether Serialize/Deserialize may be called by multiple threads at the same time
            </summary>
        </member>
        <member name="T:NFX.Serialization.POD.CustomTypedEntry">
            <summary>
            Used in custom data bags to specify the type of the object contained in Data property if it is intended to be re-interpreted
            </summary>
        </member>
        <member name="T:NFX.Serialization.POD.CompositeCustomData">
            <summary>
            Represents a composite (non primitive) data stored in Portable Object Document.
            This data is obtained from native types using ISerializable interface or running PortableObjectDocumentTransform attribute.
            This class is NOT used for native types that perform default reflection-based serialization,
             for that CompositeReflectedData is used
            </summary>
        </member>
        <member name="T:NFX.Serialization.POD.CompositeData">
            <summary>
            Represents a composite (non primitive) data stored in Portable Object Document.
            This data is obtained from native types either automatically using reflection or
             from types that perform custom serialization using ISerializable interface
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.CompositeData.Document">
            <summary>                                                             
            Returns document instance that contains this type
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.CompositeData.ExistingReference">
            <summary>
            Returns true when this instance contains a reference to existing object
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.CompositeData.ExistingReferenceIndex">
            <summary>
            Returns either an index that is less than 0 or and index to an existing object which is >=0
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.CompositeData.Referenced">
            <summary>
            Returns another composite data that is referenced, if nothing is referenced, returns null
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.CompositeData.Type">
            <summary>
            Returns type of this data
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.CompositeCustomData.CustomData">
            <summary>                                                             
            Returns custom data that this instance contains, or null if this instance is a reference to another object
            </summary>
        </member>
        <member name="T:NFX.Serialization.POD.CompositeReflectedData">
            <summary>
            Represents a composite (non primitive) data stored in Portable Object Document.
            This data is obtained from native types automatically using reflection.
            This class is NOT used for native types that perform custom serialization using ISerializable interface,
             for that CompositeCustomData is used
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.CompositeReflectedData.FieldData">
            <summary>                                                             
            Returns field data that this instance contains, or null if this instance is a reference to another object
            </summary>
        </member>
        <member name="T:NFX.Serialization.POD.CompositeArrayData">
            <summary>
            Represents a composite (non primitive) array data stored in Portable Object Document.
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.CompositeArrayData.ArrayData">
            <summary>                                                             
            Returns field data that this instance contains, or null if this instance is a reference to another object
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.CompositeArrayData.ArrayDims">
            <summary>                                                             
            Returns array dimensions
            </summary>
        </member>
        <member name="T:NFX.Serialization.POD.PODException">
            <summary>
            Base exception thrown by the Portable Object Document serialization format
            </summary>
        </member>
        <member name="T:NFX.Serialization.POD.PODSerializationException">
            <summary>
            Base exception thrown by the PortableObjectDocument when serializing objects into document
            </summary>
        </member>
        <member name="T:NFX.Serialization.POD.PODDeserializationException">
            <summary>
            Base exception thrown by the PortableObjectDocument when deserializing original objects
            </summary>
        </member>
        <member name="T:NFX.Serialization.POD.ReadingStrategy">
            <summary>
            Represents logic that resolves POD data types and field layouts to CLR types/layouts.
            Extend this type and pass its instance into PortableObjectDocument.ToOriginalObject(ReadingStrategy)
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.ReadingStrategy.ResolveType(NFX.Serialization.POD.MetaType)">
            <summary>
            Resolves a MetaType instance from a particular document into CLR Type, i.e. an obsolete class named "ABC" may be resolved into
             newer class "ABCX"
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.ReadingStrategy.ConstructObject(NFX.Serialization.POD.CompositeData)">
            <summary>
            Constructs object out of CompositeData. This implementation calls ResolveType then tries to invoke attribute constructor first
            then create instance using default ctor
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.ReadingStrategy.MakeNewObjectInstanceUsingDefaultCtor(System.Type)">
            <summary>
            Creates an object using its default .ctor. This implementation uses "magic" to create uninit buffer first
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.ReadingStrategy.MakeNewArrayInstance(NFX.Serialization.POD.CompositeArrayData)">
            <summary>
            Creates an array instance described by the CompositeArrayData instance
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.ReadingStrategy.CompositeToNative(NFX.Serialization.POD.CompositeData)">
            <summary>
            Resolves composite data into CLR object 
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.ReadingStrategy.SetFieldData(System.Object,System.Reflection.FieldInfo,NFX.Serialization.POD.CompositeReflectedData,NFX.Serialization.POD.MetaComplexType.MetaField)">
            <summary>
            Performs the assignment of portable data into native field
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.ReadingStrategy.ResolveField(System.Type,NFX.Serialization.POD.MetaComplexType.MetaField)">
            <summary>
            Resolves a meta field definition into actual native field. Returns null wen resolution is not possible and field should be skipped
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.ReadingStrategy.DeserializeSerializationInfo(System.Type,NFX.Serialization.POD.CompositeCustomData,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Performs deserialization of SerializationInfo from CompositeCustomData bag
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.ReadingStrategy.Default">
            <summary>
            Returns an instance of default strategy
            </summary>
        </member>
        <member name="T:NFX.Serialization.POD.PortableObjectDocumentSerializationTransform">
            <summary>
            Represents an entity that knows how to transform/apply CLR data types to PortableObjectDocument
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.PortableObjectDocumentSerializationTransform.SerializeCustomObjectData(NFX.Serialization.POD.PortableObjectDocument,System.Object,System.Collections.Generic.Dictionary{System.String,NFX.Serialization.POD.CustomTypedEntry})">
            <summary>
            Override to provide custome seriallization of type marked with this attribute into custom name/value bag
            </summary>
            <param name="document">Document context that this operation executes under</param>
            <param name="source">Source native data to serialize / populate data from</param>
            <param name="data">Name/value bag to write data into</param>
        </member>
        <member name="T:NFX.Serialization.POD.PortableObjectDocumentDeserializationTransform">
            <summary>
            Represents an entity that knows how to transform/apply CLR data types from PortableObjectDocument
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.PortableObjectDocumentDeserializationTransform.ConstructObjectInstance(NFX.Serialization.POD.CompositeData)">
            <summary>
            Override to construct new object instance from CompositeData. 
            Return null to let the default implementatiom/ctor be invoked by the framework
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.PortableObjectDocumentDeserializationTransform.DeserializeFromCompositeCustomData(System.Object,NFX.Serialization.POD.CompositeCustomData)">
            <summary>
            Handles the deserialization of the object instance from CompoisteCustomData bag. Returns true to indicate that 
             deserialization was handled completely here and default framework implementation should not be called
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.PortableObjectDocumentDeserializationTransform.DeserializeFromCompositeReflectedData(System.Object,NFX.Serialization.POD.CompositeReflectedData)">
            <summary>
            Handles the deserialization of the object instance from CompoisteReflectedData. Returns a set of fields that were handles by this implementation
             so that framework code can skip them. Return null or empty set when method is not implemented
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.PortableObjectDocumentDeserializationTransform.SetFieldValue(NFX.Serialization.POD.ReadingStrategy,System.Object,System.Reflection.FieldInfo,NFX.Serialization.POD.CompositeReflectedData,NFX.Serialization.POD.MetaComplexType.MetaField)">
            <summary>
            Handles the assignemnt from ReflectedData into CLR fieldInfo. Override to make conversions, i.e. string to bool, int to string etc...
            Return true to indicate that default framework implementation should not be called
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.PortableObjectDocumentDeserializationTransform.ResolveField(System.Type,NFX.Serialization.POD.MetaComplexType.MetaField)">
            <summary>
            Resolves a meta field definition into actual native field. Returns null wen resolution is not possible and field should be skipped
            </summary>
        </member>
        <member name="T:NFX.Serialization.POD.MetaType">
            <summary>
            Provides information about data types stored in Portable Object Document 
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.MetaType.GetExistingOrNewMetaTypeIndex(NFX.Serialization.POD.PortableObjectDocument,System.Type)">
            <summary>
            Obtains new or existing instance of MetaType that represents a Type in the document instance
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.MetaType.Document">
            <summary>
            Returns document instance that contains this type
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.MetaType.Name">
            <summary>
            Returns Type.Name
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.MetaType.Namespace">
            <summary>
            Returns Type.Namespace
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.MetaType.AssemblyQualifiedName">
            <summary>
            Returns Type.AssemblyQualifiedName
            </summary>
        </member>
        <member name="T:NFX.Serialization.POD.MetaPrimitiveType">
            <summary>
            Represents primitive built-in types in the framework that are stored in Portable Object Document
            </summary>
        </member>
        <member name="T:NFX.Serialization.POD.MetaComplexType">
            <summary>
            Represents information about the composite type of data that is stored in Portable Object Document
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.MetaComplexType.BuildInfo">
            <summary>
            Returns assembly build information
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.MetaComplexType.ArrayRank">
            <summary>
            Returns number of dimensions for arrays
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.MetaComplexType.ArrayElementTypeIndex">
            <summary>
            Returns index of the meta type of array element
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.MetaComplexType.ArrayElementType">
            <summary>
            Returns MetaType of array element
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.MetaComplexType.FieldCount">
            <summary>
            Returns the serializable field count described by this type
            </summary>
        </member>
        <member name="T:NFX.Serialization.POD.MetaComplexType.MetaField">
            <summary>
            Represents an information about a field of same type
            </summary>
        </member>
        <member name="T:NFX.Serialization.POD.PortableObjectDocument">
            <summary>
            Represents an graph of arbitrary CLR objects as a graph of well known POD-objects which are based on primitive-only types.
            This class acts as a Document-Object-Model container that hosts comlex CLR types that may change their structure
             but need to be deserialized even if deserialization is partial / requires transform
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.PortableObjectDocument.#ctor(System.Object,System.Nullable{System.DateTime},System.String)">
            <summary>
            Creates a new instance of object document from the graph of arbitrary CLR objects serializing them into well-known POD object types
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.PortableObjectDocument.ToOriginalObject(NFX.Serialization.POD.ReadingStrategy)">
            <summary>
            Deserializes PortableObjectDocument into original graph of arbitrary CLR objects trying to preserve/convert as much data as possible
             using optionally supplied strategy
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.PortableObjectDocument.GetExistingOrNewMetaTypeIndex(System.Type)">
            <summary>
            Obtains new or existing index of MetaType that represents a Type in this document instance.
            If this document instance already has this type registered, then existing index is returned, otherwise
             the new MetaType instance that represents the supplied CLR Type is created and registered under the document-unique index
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.PortableObjectDocument.GetExistingOrNewMetaType(System.Type)">
            <summary>
            Obtains new or existing MetaType instance that represents a Type in this document instance.
            If this document instance already has this type registered, then existing MetaType instance is returned, otherwise
             the new MetaType instance that represents the supplied CLR Type is created and registered under the document-unique index
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.PortableObjectDocument.GetMetaTypeFromIndex(System.Int32)">
            <summary>
            Returns MetaType by index
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.PortableObjectDocument.NativeDataToPortableData(System.Object)">
            <summary>
            Transforms a native value, such as object, primitive, struct etc.. into a value that can be stored in the PortableObjectDocument.
            The complex types are stored as CompositeData, primitives are stored as-is (boxed)
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.PortableObjectDocument.PortableDataToNativeData(NFX.Serialization.POD.ReadingStrategy,System.Object)">
            <summary>
            Transforms a portable data value, such as object, primitive, struct etc.. into a CLR 
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.PortableObjectDocument.BuildInformation">
            <summary>
            Returns build information for framework that contains the PortableObjectDocuemnt type
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.PortableObjectDocument.CreationDate">
            <summary>
            Returns timestamp when this doc was created
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.PortableObjectDocument.Notes">
            <summary>
            Returns notes supplied when document was created
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.PortableObjectDocument.MetaTypes">
            <summary>
            Returns meta types that this document contains
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.PortableObjectDocument.Root">
            <summary>
            Returns graph root potable object that this document represents, not a native object
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.PortableObjectDocument.RootMetaTypeIndex">
            <summary>
            Returns graph root object meta type index, if root data is null then 0 is returned which is an index of MetaCompositeType(Object) type
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.PortableObjectDocument.RootMetaType">
            <summary>
            Returns graph root object meta type index, if root is null them MetaCompositeType(Object) is returned
            </summary>
        </member>
        <member name="T:NFX.Serialization.SerializationUtils">
            <summary>
            Provides misc serialization-related functions that are really low-level and not intended to be used by developers.
            Methods are thread-safe
            </summary>
        </member>
        <member name="M:NFX.Serialization.SerializationUtils.MakeNewObjectInstance(System.Type)">
            <summary>
            Create new object instance for type, calling default ctor
            </summary>
        </member>
        <member name="M:NFX.Serialization.SerializationUtils.GetSerializableFields(System.Type)">
            <summary>
            Gets all serializable fields for type in parent->child declaraion order, sub-ordered by case
             within the segment
            </summary>
        </member>
        <member name="M:NFX.Serialization.SerializationUtils.FindSerializationAttributedMethods(System.Type,System.Type)">
            <summary>
            Finds methods decorated by [On(De)Seriali(zing/zed)]
            </summary>
            <param name="t">A type whose methods to search</param>
            <param name="atype">Attribute type to search</param>
            <returns>List(MethodInfo) that qualifies or NULL if none found</returns>
        </member>
        <member name="M:NFX.Serialization.SerializationUtils.InvokeSerializationAttributedMethods(System.Collections.Generic.List{System.Reflection.MethodInfo},System.Object,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Calls method in the list that was returned by a call to FindSerializationAttributedMethods 
            </summary>
            <param name="methods">list that was returned by a call to FindSerializationAttributedMethods</param>
            <param name="instance">Instance to invoke mathods on</param>
            <param name="streamingContext">Streaming Context</param>
        </member>
        <member name="M:NFX.Serialization.SerializationUtils.WalkArrayWrite(System.Array,System.Action{System.Object})">
            <summary>
            Performs an action on each element of a possibly mutidimensional array
            </summary>
        </member>
        <member name="M:NFX.Serialization.SerializationUtils.WalkArrayRead``1(System.Array,System.Func{``0})">
            <summary>
            Performs an action on each element of a possibly mutidimensional array
            </summary>
        </member>
        <member name="F:NFX.Serialization.Slim.Arrays.MAX_DIM_COUNT">
            <summary>
            Maximum number of supported array dimensions.
            Used for possible stream corruption detection
            </summary>
        </member>
        <member name="F:NFX.Serialization.Slim.Arrays.MAX_ELM_COUNT">
            <summary>
            Maximum number of elements in any array.
            Used for possible stream corruption detection
            </summary>
        </member>
        <member name="T:NFX.Serialization.Slim.TypeRegistryMode">
            <summary>
            Denotes modes of handling type registry by Slim serializer
            </summary>
        </member>
        <member name="F:NFX.Serialization.Slim.TypeRegistryMode.PerCall">
            <summary>
            Type registry object is created for every Serialize/Deserialize call only
            cloning global types. This is the default mode which is thread-safe(many threads can call Serialize/Deserialize at the same time)
            </summary>
        </member>
        <member name="F:NFX.Serialization.Slim.TypeRegistryMode.Batch">
            <summary>
            Type registry object is cloned from global types only once and it is retained after making calls.
            This is not a thread-safe mode, so only one thread may call Serialize/Deserialize at a time.
            This mode is beneficial for cases when many object instances of various types need to be transmitted
            so repeating their type names in every Ser/Deser is not efficient. In batch mode the type name is
             written/read to/from stream only once, then type handles are transmitted instead thus saving space and
             extra allocations
            </summary>
        </member>
        <member name="T:NFX.Serialization.Slim.ISlimSerializer">
            <summary>
            Marker interface for formats based on Slim algorithm family
            </summary>
        </member>
        <member name="M:NFX.Serialization.Slim.ISlimSerializer.ResetCallBatch">
            <summary>
            Resets type registry state to initial state (which is based on global types) for TypeMode = "Batch",
            otherwise does nothing
            </summary>
        </member>
        <member name="P:NFX.Serialization.Slim.ISlimSerializer.TypeMode">
            <summary>
            Gets/sets how serializer handles type information between calls to Serialize/Deserialize.
            This property itself is not thread-safe, that is - it should be only set once by control/initiating thread
            </summary>
        </member>
        <member name="P:NFX.Serialization.Slim.ISlimSerializer.BatchTypesAdded">
            <summary>
            Returns true if last call to Serialize or Deserialize in batch mode added more types to type registry.
            This call is only valid in TypeMode = "Batch" and is inherently not thread-safe
            </summary>
        </member>
        <member name="T:NFX.Serialization.Slim.PODSlimSerializer">
            <summary>
            Serializes CLR object graphs using PortableObjectDocument container and Slim binary serialization algorithm.
            This class is far less performant than SlimSerializer, however it serializes types using document model that
             allows to transform/change data during serialization/deserialization. 
            This class is needed for upgrades, when object metadata may change but need to be read (maybe partially) back into the new type structure 
            </summary>
        </member>
        <member name="M:NFX.Serialization.Slim.PODSlimSerializer.NFX#Serialization#Slim#ISlimSerializer#ResetCallBatch">
            <summary>
            This method does nothig in this class
            </summary>
        </member>
        <member name="M:NFX.Serialization.Slim.PODSlimSerializer.Serialize(System.IO.Stream,System.Object)">
            <summary>
            Serializes a graph of arbitrary CLR objects into stream using PortableObjectDocument container
            </summary>
            <param name="stream">Target stream</param>
            <param name="root">CLR object graph</param>
        </member>
        <member name="M:NFX.Serialization.Slim.PODSlimSerializer.Serialize(System.IO.Stream,System.Object,System.Nullable{System.DateTime},System.String)">
            <summary>
            Serializes a graph of arbitrary CLR objects into stream using PortableObjectDocument container, 
             optionally taking document creation attributes
            </summary>
            <param name="stream">Target stream</param>
            <param name="root">CLR object graph</param>
            <param name="documentCreationDate">Optional document creation attribute</param>
            <param name="documentNotes">Optional document creation attribute</param>
        </member>
        <member name="M:NFX.Serialization.Slim.PODSlimSerializer.Deserialize(System.IO.Stream,NFX.Serialization.POD.ReadingStrategy)">
            <summary>
            Desirializes a graph of arbitrary CLR objects that was serialized before
            </summary>
            <param name="stream">Source data stream in Slim binary format</param>
            <param name="readingStrategy">Optional reading strategy</param>
            <returns>CLR object graph which is deserialized from possibly transformed PortableObjectDocument container</returns>
        </member>
        <member name="M:NFX.Serialization.Slim.PODSlimSerializer.Deserialize(System.IO.Stream)">
            <summary>
            Desirializes a graph of arbitrary CLR objects that was serialized before
            </summary>
            <param name="stream">Source data stream in Slim binary format</param>
            <returns>CLR object graph which is deserialized from possibly transformed PortableObjectDocument container</returns>
        </member>
        <member name="M:NFX.Serialization.Slim.PODSlimSerializer.DeserializeDocument(System.IO.Stream)">
            <summary>
            Deserializes a PortableObjectDocument container instance
            </summary>
            <param name="stream">Source data stream in Slim binary format</param>
            <returns>PortableObjectDocument instance</returns>
        </member>
        <member name="P:NFX.Serialization.Slim.PODSlimSerializer.NFX#Serialization#Slim#ISlimSerializer#TypeMode">
            <summary>
            This serializer always uses "PerCall" setting. Setting this property has no effect
            </summary>
        </member>
        <member name="P:NFX.Serialization.Slim.PODSlimSerializer.NFX#Serialization#ISerializer#IsThreadSafe">
            <summary>
            This serializer is thread-safe
            </summary>
        </member>
        <member name="P:NFX.Serialization.Slim.PODSlimSerializer.NFX#Serialization#Slim#ISlimSerializer#BatchTypesAdded">
            <summary>
            Not supported here
            </summary>
        </member>
        <member name="M:NFX.Serialization.Slim.RefPool.GetHandle(System.Object,NFX.Serialization.Slim.TypeRegistry,NFX.IO.SlimFormat,System.Type@)">
            <summary>
            Emits MetaHandle that contains type handle for reference handle only when this referenced is added to pool for the first time.
            Emits inlined string for strings and inlined value types for boxed objects.
            Emits additional array dimensions info for array refernces who's types are emitted for the first time
            </summary>
        </member>
        <member name="M:NFX.Serialization.Slim.RefPool.HandleToReference(NFX.IO.MetaHandle,NFX.Serialization.Slim.TypeRegistry,NFX.IO.SlimFormat,NFX.IO.SlimReader)">
            <summary>
            Returns object reference for supplied metahandle
            </summary>
        </member>
        <member name="T:NFX.Serialization.Slim.SlimSerializer">
            <summary>
            Implements Slim serialization algorithm that relies on an injectable SlimFormat-derivative (through .ctor) paremeter.
            This class was designed for highly-efficient serialization of types without versioning.
            SlimSerializer supports a concept of "known types" that save space by not emitting their names into stream.
            Performance note:
            This serializer yields on average 1/4 serialization and 1/2 deserialization times while compared to BinaryFormatter.
            Serialization of Record-instances usually takes 1/6 of BinaryFormatter time.
            Format takes 1/10 space for records and 1/2 for general object graphs.
            Such performance is achieved because of dynamic compilation of type-specific serialization/deserialization methods.
            This type is thread-safe for serializations/deserializations when TypeMode is set to "PerCall"
            </summary>
        </member>
        <member name="F:NFX.Serialization.Slim.SlimSerializer.Owner">
            <summary>
            Associates arbitrary owner object with this instance. Slim serializer does not use this field internally for any purpose
            </summary>
        </member>
        <member name="M:NFX.Serialization.Slim.SlimSerializer.ResetCallBatch">
            <summary>
            Resets type registry to initial state (which is based on global types) for TypeMode = "Batch",
            otherwise does nothing. This method is not thread-safe
            </summary>
        </member>
        <member name="P:NFX.Serialization.Slim.SlimSerializer.TypeMode">
            <summary>
            Gets/sets how serializer handles type information between calls to Serialize/Deserialize.
            Setting this to "Batch" makes this serializer instance not thread-safe for calling Serialize/Deserialize.
            This property itself is not thread-safe, that is - it should be only set once by control/initiating thread
            </summary>
        </member>
        <member name="P:NFX.Serialization.Slim.SlimSerializer.IsThreadSafe">
            <summary>
            Returns true when TypeMode is "PerCall"
            </summary>
        </member>
        <member name="P:NFX.Serialization.Slim.SlimSerializer.BatchTypesAdded">
            <summary>
            Returns true if last call to Serialize or Deserialize in batch mode added more types to type registry.
            This call is only valid in TypeMode = "Batch" and is inherently not thread-safe
            </summary>
        </member>
        <member name="P:NFX.Serialization.Slim.SlimSerializer.BatchTypeRegistry">
            <summary>
            ADVANCED FEATURE! Developers do not use. 
            Returns type registry used in batch.
            This call is only valid in TypeMode = "Batch" and is inherently not thread-safe.
            Be careful not to mutate the returned object
            </summary>
        </member>
        <member name="T:NFX.IO.SlimWriter">
            <summary>
            Writes primitives and other supported types to Slim-format stream. Use factory method of SlimFormat intance to create a new instance of SlimWriter class
            </summary>
        </member>
        <member name="P:NFX.IO.SlimWriter.Format">
            <summary>
            Returns SlimFormat that this writer implements
            </summary>
        </member>
        <member name="T:NFX.Serialization.Slim.SlimException">
            <summary>
            Base exception thrown by the Slim serialization format
            </summary>
        </member>
        <member name="T:NFX.Serialization.Slim.SlimSerializationException">
            <summary>
            Base exception thrown by the Slim when serializing objects
            </summary>
        </member>
        <member name="T:NFX.Serialization.Slim.SlimDeserializationException">
            <summary>
            Base exception thrown by the Slim when deserializing objects
            </summary>
        </member>
        <member name="T:NFX.Serialization.Slim.SlimInvalidTypeHandleException">
            <summary>
            Thrown by type registry when supplied type handle is invalid/not found
            </summary>
        </member>
        <member name="T:NFX.Serialization.Slim.TypeRegistry">
            <summary>
            Provides a registry of types, types that do not need to be described in a serialization stream
            </summary>
        </member>
        <member name="F:NFX.Serialization.Slim.TypeRegistry.NULL_HANDLE">
            <summary>
            Denotes a special type which is object==null
            </summary>
        </member>
        <member name="M:NFX.Serialization.Slim.TypeRegistry.#ctor(System.Collections.Generic.IEnumerable{System.Type}[])">
            <summary>
            Initializes TypeRegistry with types from other sources
            </summary>
        </member>
        <member name="M:NFX.Serialization.Slim.TypeRegistry.Add(System.Type)">
            <summary>
            Adds the type if it not already in registry and returns true
            </summary>
        </member>
        <member name="M:NFX.Serialization.Slim.TypeRegistry.GetTypeHandleAsString(System.Type)">
            <summary>
            Returns a string with the type index formatted as handle if type exists in registry, or fully qualified type name otherwise
            </summary>
        </member>
        <member name="M:NFX.Serialization.Slim.TypeRegistry.GetTypeHandle(System.Type)">
            <summary>
            Returns a VarIntStr with the type index formatted as handle if type exists in registry, or fully qualified type name otherwise
            </summary>
        </member>
        <member name="P:NFX.Serialization.Slim.TypeRegistry.RecordModelTypes">
            <summary>
            Returns Record-model specific types
            </summary>
        </member>
        <member name="P:NFX.Serialization.Slim.TypeRegistry.GlueProtocolTypes">
            <summary>
            Returns Glue protocol specific types
            </summary>
        </member>
        <member name="P:NFX.Serialization.Slim.TypeRegistry.DataAccessCRUDTypes">
            <summary>
            Returns common types for DataAccess.CRUD
            </summary>
        </member>
        <member name="P:NFX.Serialization.Slim.TypeRegistry.CommonCollectionTypes">
            <summary>
            Returns frequently-used generic collections
            </summary>
        </member>
        <member name="P:NFX.Serialization.Slim.TypeRegistry.BoxedCommonTypes">
            <summary>
            Returns common primitive types - use when much boxing is expected
            </summary>
        </member>
        <member name="P:NFX.Serialization.Slim.TypeRegistry.BoxedCommonNullableTypes">
            <summary>
            Returns common nullable types - use when much boxing is expected
            </summary>
        </member>
        <member name="P:NFX.Serialization.Slim.TypeRegistry.PODTypes">
            <summary>
            Returns PortableObjectDocument types
            </summary>
        </member>
        <member name="P:NFX.Serialization.Slim.TypeRegistry.Count">
            <summary>
            How many items in the registry
            </summary>
        </member>
        <member name="P:NFX.Serialization.Slim.TypeRegistry.CSum">
            <summary>
            Returns quick checksum of type registry contents.
            It is updated when new types get added into the registry
            </summary>
        </member>
        <member name="P:NFX.Serialization.Slim.TypeRegistry.Item(NFX.IO.VarIntStr)">
            <summary>
            Returns type by handle i.e. VarIntStr(1) or VarIntStr("full name"). Throws in case of error
            </summary>
        </member>
        <member name="P:NFX.Serialization.Slim.TypeRegistry.Item(System.String)">
            <summary>
            Returns type by handle i.e. '$11' or full name. Throws in case of error
            </summary>
        </member>
        <member name="T:NFX.Serialization.Slim.TypeDescriptor">
            <summary>
            Type descriptor dynamicaly compiles serialization/deserialization expressions for a particular type
            </summary>
        </member>
        <member name="T:NFX.Serialization.SerializationOperation">
            <summary>
            Denotes ser/deser operations
            </summary>
        </member>
        <member name="F:NFX.Serialization.SerializationOperation.Serializing">
            <summary>
            Serializing object to stream
            </summary>
        </member>
        <member name="F:NFX.Serialization.SerializationOperation.Deserializing">
            <summary>
            Deserializing object from stream
            </summary>
        </member>
        <member name="T:NFX.Serialization.IDisposableSerializer">
            <summary>
            Describes an entity that can serialize and deserialize objects and can be disposed
            </summary>
        </member>
        <member name="T:NFX.ServiceModel.ChildService">
            <summary>
            Child service entry as managed by CompositeServiceHost class
            </summary>
        </member>
        <member name="T:NFX.ServiceModel.CompositeServiceHost">
            <summary>
            Represents a service that contains other child services.
            Start/Stop commands translate into child sub-commands.
            This class is used to host other services in various job/background process hosts
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.CompositeServiceHost.RegisterService(NFX.ServiceModel.Service,System.Int32,System.Boolean)">
            <summary>
            Returns true if child service was registered, false if it was already registered prior tp this call.
            The method may only be called on stopped (this) service 
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.CompositeServiceHost.UnregisterService(NFX.ServiceModel.Service)">
            <summary>
            Returns true if child service was unregistered, false if it did not exist.
            The method may only be called on stopped (this) service 
            </summary>
        </member>
        <member name="P:NFX.ServiceModel.CompositeServiceHost.ChildServices">
            <summary>
            Returns service registry where services can be looked-up by name
            </summary>
        </member>
        <member name="P:NFX.ServiceModel.CompositeServiceHost.OrderedChildServices">
            <summary>
            Returns services ordered by their order property
            </summary>
        </member>
        <member name="T:NFX.ServiceModel.SvcHostException">
             <summary>
            Thrown by CompositeServiceHost
             </summary>
        </member>
        <member name="T:NFX.ServiceModel.ControlStatus">
            <summary>
            Stipulates control phase statuses like: Active/Inactive etc...
            </summary>
        </member>
        <member name="T:NFX.ServiceModel.IWorkItem`1">
            <summary>
            Defines a base for items executable by WorkQueue
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.IWorkItem`1.PerformWork(`0)">
            <summary>
            Invoked on an item to perform actual work. For example: repaint grid from changed data source, refresh file, send email etc... 
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.IWorkItem`1.WorkSucceeded">
            <summary>
            Invoked after successfull work execution - when no exception happened
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.IWorkItem`1.WorkFailed(System.Boolean,System.Exception)">
            <summary>
            Invoked when either work execution or work success method threw an exception and did not succeed
            </summary>
            <param name="workPerformed">When true indicates that PerformWork() worked without exception but exception happened later</param>
            <param name="error">Exception instance</param>
        </member>
        <member name="T:NFX.ServiceModel.WorkItemAggregationIntervalKind">
            <summary>
            Defines how intervals should be handled. Sliding means that every time message is posted into in queue
             interval starts to count from scratch, periodic counts from the first message post
            </summary>
        </member>
        <member name="T:NFX.ServiceModel.IAggregatableWorkItem">
            <summary>
            Represents an item that may be posted into WorkItemAggregatorService queue
            </summary>
        </member>
        <member name="T:NFX.ServiceModel.WorkItemAggregatorService`1">
            <summary>
            Aggregates same/equal (as defined by item's IAggregatableWorkItem.AggregationKey) work items posted into queue to limit
             the penetration of duplicate work items in destination queue
            </summary>
        </member>
        <member name="T:NFX.ServiceModel.IWorkQueue`1">
            <summary>
            Defines contract for work queue that work items can be posted to
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.IWorkQueue`1.PostItem(NFX.ServiceModel.IWorkItem{`0})">
            <summary>
            Posts work item into the queue in natural queue order (at the end of the queue)
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.WorkItemAggregatorService`1.PostItem(NFX.ServiceModel.IWorkItem{`0})">
            <summary>
            Posts work item in the service. This item may not be posted into destination if the same item was already recently posted
             into destination queue, however if no same work item will come within timeout, then this item will eventually post
            </summary>
        </member>
        <member name="P:NFX.ServiceModel.WorkItemAggregatorService`1.DestinationQueue">
            <summary>
            Returns the destination queue
            </summary>
        </member>
        <member name="P:NFX.ServiceModel.WorkItemAggregatorService`1.DestinationPostInterval">
            <summary>
            Defines an interval measured in milliseconds for posting into destination queue
            </summary>
        </member>
        <member name="T:NFX.ServiceModel.WorkQueue`1">
            <summary>
            Maintains a queue of pending work - every WorkItem posting in the queue will be executed by the host of the queue.
            WorkQueues are useful for coordination of complex data/event flows in multi-threaded/service applications 
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.WorkQueue`1.#ctor(`0)">
            <summary>
            Creates an instance of work queue in particular context
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.WorkQueue`1.#ctor(`0,NFX.ServiceModel.PostItemFilter{`0})">
            <summary>
            Creates an instance of work queue in particular context
             with specific woprk item post filter
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.WorkQueue`1.PostItem(NFX.ServiceModel.IWorkItem{`0})">
            <summary>
            Posts work item into the queue in natural queue order (at the end of the queue)
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.WorkQueue`1.FetchDueItem">
            <summary>
            Takes due item off the queue without executing it and returns it, or returns null when queue is empty.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NFX.ServiceModel.WorkQueue`1.ProcessDueItem">
            <summary>
            Processes item in normal queue order (the item that is due to be processed). Returns true when there was an item in the queue.
            This method does not leak exceptions from work performance unless they are re-thrown by particular work item WorkFailed(error)
            </summary>
        </member>
        <member name="P:NFX.ServiceModel.WorkQueue`1.Context">
            <summary>
            Returns context that work is processed in
            </summary>
        </member>
        <member name="P:NFX.ServiceModel.WorkQueue`1.PendingCount">
            <summary>
            Returns pending number of work items
            </summary>
        </member>
        <member name="P:NFX.ServiceModel.WorkQueue`1.ProcessedSuccessCount">
            <summary>
            Returns total number of work items processed without errors by this queue since its creation
            </summary>
        </member>
        <member name="P:NFX.ServiceModel.WorkQueue`1.ProcessedFailureCount">
            <summary>
            Returns total number of work items processed with errors by this queue since its creation
            </summary>
        </member>
        <member name="P:NFX.ServiceModel.WorkQueue`1.ProcessedTotalCount">
            <summary>
            Returns total number of work items processed with or without errors by this queue since its creation
            </summary>
        </member>
        <member name="T:NFX.ServiceModel.PostItemFilter`1">
            <summary>
            A filter delegate that gets called within PostItem before adding work to this queue.
            This is useful for re-routing work to some other queue/s when needed.
            Return null if work item is going to be processed by some other queue that this delegate should post into.
            Keep in mind that this delegate is invoked by posters thread
            </summary>
        </member>
        <member name="T:NFX.StringConsts">
            <summary>
            A dictionary of framework text messages.
            Localization may be done in this class in future
            </summary>
        </member>
        <member name="T:NFX.StringValueConversion">
            <summary>
            Provides extension methods for converting string values to different scalar types
            </summary>
        </member>
        <member name="M:NFX.StringValueConversion.AsStringWhenNullOrEmpty(System.String,System.String)">
            <summary>
            Used by env var macros evaluator do not remove
            </summary>
        </member>
        <member name="M:NFX.StringValueConversion.AsString(System.String,System.String)">
            <summary>
            Used by env var macros evaluator do not remove
            </summary>
        </member>
        <member name="M:NFX.StringValueConversion.AsType(System.String,System.Type,System.Boolean)">
            <summary>
            Tries to get a string value as specified type.
            When 'strict=false', tries to do some inference like return "true" for numbers that dont equal to zero etc.
            When 'strict=true' throws an exception if deterministic conversion is not possible
            </summary>
        </member>
        <member name="M:NFX.TaskUtils.OnOk(System.Threading.Tasks.Task,System.Action,System.Threading.Tasks.TaskContinuationOptions)">
            <summary>
            Chains task 'first' with 'next' if first is completed, not cancelled and not faulted.
            Returns task that completes when 'next' completes
            </summary>
        </member>
        <member name="M:NFX.TaskUtils.OnOk``1(System.Threading.Tasks.Task{``0},System.Action{``0},System.Threading.Tasks.TaskContinuationOptions)">
            <summary>
            Chains task 'first' with 'next' passing result of 'first' to 'next' if first is completed, not cancelled and not faulted.
            Returns task that completes when 'next' completes
            </summary>
        </member>
        <member name="M:NFX.TaskUtils.OnOk``1(System.Threading.Tasks.Task{``0},System.Func{``0,System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskContinuationOptions)">
            <summary>
            Chains task 'first' with task returned by 'next' passing result of 'first' to 'next' if first is completed, not cancelled and not faulted.
            Returns task that completes after task returned by 'next' completes
            </summary>
        </member>
        <member name="M:NFX.TaskUtils.OnOk``1(System.Threading.Tasks.Task,System.Func{System.Threading.Tasks.Task{``0}},System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskContinuationOptions)">
            <summary>
            Chains task 'first' with task returned by 'next' if first is completed, not cancelled and not faulted.
            Returns task that completes after task returned by 'next' completes with result from 'next' task
            </summary>
        </member>
        <member name="M:NFX.TaskUtils.OnOk``2(System.Threading.Tasks.Task{``0},System.Func{``0,System.Threading.Tasks.Task{``1}},System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskContinuationOptions)">
            <summary>
            Chains task 'first' with task returned by 'next' passing result of 'first' to 'next' if first is completed, not cancelled and not faulted.
            Returns task that completes after task returned by 'next' completes with result from 'next' task
            </summary>
        </member>
        <member name="M:NFX.TaskUtils.OnError(System.Threading.Tasks.Task,System.Action)">
            <summary>
            Registers action executed if task was faulted or cancelled
            </summary>
        </member>
        <member name="M:NFX.TaskUtils.OnOkOrError(System.Threading.Tasks.Task,System.Action{System.Threading.Tasks.Task})">
            <summary>
            Registers action executed disregarding task state
            </summary>
        </member>
        <member name="M:NFX.TaskUtils.OnOkOrError``1(System.Threading.Tasks.Task{``0},System.Action{System.Threading.Tasks.Task})">
            <summary>
            Registers action executed disregarding task state
            </summary>
        </member>
        <member name="M:NFX.TaskUtils.AsCompletedTask(System.Action)">
            <summary>
            Non-generic version of <see cref="M:NFX.TaskUtils.AsCompletedTask``1(System.Func{``0})"/>
            </summary>
            <remarks>
            Because there is no non-generic <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/> version 
            generic version typed by <see cref="T:System.Object"/> is used (<see cref="T:System.Threading.Tasks.Task`1"/> inherits from <see cref="T:System.Threading.Tasks.Task"/>)
            </remarks>
        </member>
        <member name="M:NFX.TaskUtils.AsCompletedTask``1(System.Func{``0})">
            <summary>
            Returns task completed from synchronous functor
            </summary>
        </member>
        <member name="T:NFX.Templatization.ITemplateSource">
            <summary>
            Describes an entity that provides source for template
            </summary>
        </member>
        <member name="M:NFX.Templatization.ITemplateSource.GetSourceContent">
            <summary>
            Returns template source content
            </summary>
        </member>
        <member name="M:NFX.Templatization.ITemplateSource.InferClassName">
            <summary>
            Tries to suggest a class name for this content or null
            </summary>
        </member>
        <member name="M:NFX.Templatization.ITemplateSource.GetName(System.Int32)">
            <summary>
            Gets printable source name
            </summary>
        </member>
        <member name="T:NFX.Templatization.ITemplateSource`1">
            <summary>
            Describes an entity that provides source for templates
            </summary>
        </member>
        <member name="M:NFX.Templatization.ITemplateSource`1.GetSourceContent">
            <summary>
            Returns template source content
            </summary>
        </member>
        <member name="T:NFX.Templatization.FileTemplateStringContentSource">
            <summary>
            Represents a string template source that comes from a file
            </summary>
        </member>
        <member name="M:NFX.Templatization.FileTemplateStringContentSource.InferClassName">
            <summary>
            Returns the name of template class inferred from file name
            </summary>
        </member>
        <member name="M:NFX.Templatization.FileTemplateStringContentSource.GetName(System.Int32)">
            <summary>
            Gets printable source name
            </summary>
        </member>
        <member name="T:NFX.Templatization.TemplateStringContentSource">
            <summary>
            Represents a string template source that comes from a string
            </summary>
        </member>
        <member name="M:NFX.Templatization.TemplateStringContentSource.InferClassName">
            <summary>
            Returns null as class name can not be inferred from string
            </summary>
        </member>
        <member name="M:NFX.Templatization.TemplateStringContentSource.GetName(System.Int32)">
            <summary>
            Gets printable source name
            </summary>
        </member>
        <member name="T:NFX.Templatization.IRenderingTarget">
            <summary>
            Defines an entity that a template can be rendered into.
            Templates are not necessarily text-based, consequently data is supplied as objects
            </summary>
        </member>
        <member name="M:NFX.Templatization.IRenderingTarget.Encode(System.Object)">
            <summary>
            Encodes an object per underlying target specification. For example, a Http-related target may
             encode strings using HttpEncoder. If particular target does not support encoding then this method should just return the argument unmodified
            </summary>
        </member>
        <member name="M:NFX.Templatization.IRenderingTarget.Write(System.Object)">
            <summary>
            Writes a generic object into target. Templates are not necessarily text-based, consequently this method takes an object argument
            </summary>
        </member>
        <member name="M:NFX.Templatization.IRenderingTarget.Flush">
            <summary>
            Flushes writes into underlying target implementation. If target does not support buffering then this call does nothing
            </summary>
        </member>
        <member name="T:NFX.Templatization.TemplatizationException">
            <summary>
            Base exception thrown by the templatization-related functionality
            </summary>
        </member>
        <member name="T:NFX.Templatization.TemplateCompilerException">
            <summary>
            Base exception thrown by the template compilers
            </summary>
        </member>
        <member name="T:NFX.Templatization.TemplateParseException">
            <summary>
            Indicates template source parsing exception 
            </summary>
        </member>
        <member name="T:NFX.Templatization.TemplateCodeCompilerException">
            <summary>
            Thrown by  template code compilers
            </summary>
        </member>
        <member name="T:NFX.Templatization.CompileUnit">
            <summary>
            Represents a compilation unit which is compiled by TemplateCompiler.
            Use TemplateCompiler.IncludeTemplateSource() method or pass sources to .ctor
            </summary>
        </member>
        <member name="P:NFX.Templatization.CompileUnit.TemplateSource">
            <summary>
            References original template source such as a string for text-based templates or an image
            </summary>
        </member>
        <member name="P:NFX.Templatization.CompileUnit.CompiledSource">
            <summary>
            Returns source code in a language that particular TemplateCompiler derivative supports. 
            Use TemplateCompiler.LanguageName to determine language polymorphicaly
            </summary>
        </member>
        <member name="P:NFX.Templatization.CompileUnit.CompiledTemplateType">
            <summary>
            Returns CLR type that compiler produced IF language source compilation was performed
            </summary>
        </member>
        <member name="P:NFX.Templatization.CompileUnit.CompiledTemplateTypeName">
            <summary>
            Returns fully-qualified CLR type name that compiler produced 
            </summary>
        </member>
        <member name="P:NFX.Templatization.CompileUnit.CompilationException">
            <summary>
            Returns an exception that was thrown during compilation
            </summary>
        </member>
        <member name="T:NFX.Templatization.TemplateCompiler">
            <summary>
            Represents abstraction of template compilers. This class is not thread-safe
            </summary>
        </member>
        <member name="M:NFX.Templatization.TemplateCompiler.EnsureNotCompiled">
            <summary>
            Throws an exception if this instance has already been compiled
            </summary>
        </member>
        <member name="M:NFX.Templatization.TemplateCompiler.Compile">
            <summary>
            Performs compilation if it has not already been performed 
            </summary>
        </member>
        <member name="M:NFX.Templatization.TemplateCompiler.IncludeTemplateSource(NFX.Templatization.ITemplateSource)">
            <summary>
            Includes template source into compilation
            </summary>
        </member>
        <member name="M:NFX.Templatization.TemplateCompiler.ExcludeTemplateSource(NFX.Templatization.ITemplateSource)">
            <summary>
            Exclude template source from compilation
            </summary>
        </member>
        <member name="M:NFX.Templatization.TemplateCompiler.ReferenceAssembly(System.String)">
            <summary>
            References assembly by its name if it is already not referenced
            </summary>
        </member>
        <member name="M:NFX.Templatization.TemplateCompiler.UnReferenceAssembly(System.String)">
            <summary>
            Removes assembly reference by its name if it was already referenced
            </summary>
        </member>
        <member name="M:NFX.Templatization.TemplateCompiler.GenerateUniqueName">
            <summary>
            Generates unique identifier suitable for use in code per compiler instance
            </summary>
        </member>
        <member name="M:NFX.Templatization.TemplateCompiler.DoCompileTemplateSource(NFX.Templatization.CompileUnit)">
            <summary>
            Override to perform code generation from template source into code
            </summary>
        </member>
        <member name="M:NFX.Templatization.TemplateCompiler.DoCompileCode">
            <summary>
            Override to perform compilation of code into assembly
            </summary>
        </member>
        <member name="M:NFX.Templatization.TemplateCompiler.DoConfigure(NFX.Environment.IConfigSectionNode)">
            <summary>
            Override to perform custom configuration
            </summary>
        </member>
        <member name="M:NFX.Templatization.TemplateCompiler.RegisterDefaultUsings(System.Collections.Generic.HashSet{System.String})">
            <summary>
            Override to provide default using clauses
            </summary>
        </member>
        <member name="P:NFX.Templatization.TemplateCompiler.LanguageName">
            <summary>
            Gets the name of the language that this compiler supports, i.e. "C#"
            </summary>
        </member>
        <member name="P:NFX.Templatization.TemplateCompiler.LanguageSourceFileExtension">
            <summary>
            Gets the name of the language source code file extension that this compiler supports, i.e. ".cs"
            </summary>
        </member>
        <member name="P:NFX.Templatization.TemplateCompiler.Compiled">
            <summary>
            Indicates whether this instance was compiled
            </summary>
        </member>
        <member name="P:NFX.Templatization.TemplateCompiler.Options">
            <summary>
            Config options section used for compilation
            </summary>
        </member>
        <member name="P:NFX.Templatization.TemplateCompiler.Assembly">
            <summary>
            Returns compiled assembly or null if only source have been compiled when CompileCode=false;
            </summary>
        </member>
        <member name="P:NFX.Templatization.TemplateCompiler.ReferencedAssemblies">
            <summary>
            Returns referenced assemblies
            </summary>
        </member>
        <member name="P:NFX.Templatization.TemplateCompiler.ReferencedAssembliesSearchPath">
            <summary>
            Gets/sets path for referenced assemblies that do not have a path in their names
            </summary>
        </member>
        <member name="P:NFX.Templatization.TemplateCompiler.AssemblyFileName">
            <summary>
            Gets/sets filename for assembly, if null then assembly is created in-memory only
            </summary>
        </member>
        <member name="P:NFX.Templatization.TemplateCompiler.CompileCode">
            <summary>
            Indicates whether language compilation should be performed and Assembly be built
            </summary>
        </member>
        <member name="P:NFX.Templatization.TemplateCompiler.BaseTypeName">
            <summary>
            Sets the name of base type that templates inherit from.
            This type must directly or indirectly inherit from Template 
            </summary>
        </member>
        <member name="P:NFX.Templatization.TemplateCompiler.Namespace">
            <summary>
            Sets the name of namespace that classes compiled into 
            </summary>
        </member>
        <member name="P:NFX.Templatization.TemplateCompiler.Item(NFX.Templatization.ITemplateSource)">
            <summary>
            Returns a compile unit by template source or throws if it does not exist
            </summary>
        </member>
        <member name="P:NFX.Templatization.TemplateCompiler.HasErrors">
            <summary>
            Indicates whether some units have template compilation errors or code compiler errors exist
            </summary>
        </member>
        <member name="P:NFX.Templatization.TemplateCompiler.CodeCompilerErrors">
            <summary>
            Returns code compilation errors
            </summary>
        </member>
        <member name="P:NFX.Templatization.TemplateCompiler.CompileUnitsWithErrors">
            <summary>
            Returns compile units that have errors
            </summary>
        </member>
        <member name="T:NFX.Templatization.CompileUnits">
            <summary>
            Represents a bag of compile units
            </summary>
        </member>
        <member name="T:NFX.Templatization.StringRenderingTarget">
            <summary>
            Renders templates into string
            </summary>
        </member>
        <member name="M:NFX.Templatization.StringRenderingTarget.ToString">
            <summary>
            Returns what has been written
            </summary>
        </member>
        <member name="P:NFX.Templatization.StringRenderingTarget.Value">
            <summary>
            Returns what has been written
            </summary>
        </member>
        <member name="T:NFX.Templatization.ITemplate">
            <summary>
            A general template interface. 
            A template is a class that gets instantiated at some point to Render() its content into IRenderingTarget instance. 
            Templates are not necessarily text-based, i.e. they can be image-based or based on various kinds of binary files
            </summary>
        </member>
        <member name="M:NFX.Templatization.ITemplate.Render(NFX.Templatization.IRenderingTarget,System.Object)">
            <summary>
            Renders template by generating content into target
            </summary>
            <param name="target">A target that rendering is done into</param>
            <param name="renderingContext">A context object for this rendering call</param>
        </member>
        <member name="P:NFX.Templatization.ITemplate.Context">
            <summary>
            Custom context for the lifetime of this template
            </summary>
        </member>
        <member name="P:NFX.Templatization.ITemplate.CanReuseInstance">
            <summary>
            Indicates whether an instance of template class may be reused for invocation of Render() more than once (possibly with different rendering target and/or rendering context)  
            </summary>
        </member>
        <member name="T:NFX.Templatization.Template`3">
            <summary>
            A general ancestor for any template. All templates derive from this class directly or indirectly.
            A template is a class that gets instantiated at some point to Render() its content into IRenderingTarget instance. 
            Templates are not necessarily text-based, i.e. they can be image-based or based on various kinds of binary files
            </summary>
        </member>
        <member name="M:NFX.Templatization.Template`3.Render(`1,`2)">
            <summary>
            Renders template by generating content into target
            </summary>
            <param name="target">A target to render output into</param>
            <param name="renderingContext">A context object for this rendering call</param>
        </member>
        <member name="M:NFX.Templatization.Template`3.BindGlobalContexts(`0)">
            <summary>
            Infrastructure. Sets Context property. Normally this method should never be called by developers
            </summary>
        </member>
        <member name="M:NFX.Templatization.Template`3.DoContextBinding">
            <summary>
            Infrastructure. Override to perform extra steps after Context property gets set. 
            Normally this method should never be called by developers
            </summary>
        </member>
        <member name="M:NFX.Templatization.Template`3.DoPreRender">
            <summary>
            Performs pre-rendering actions
            </summary>
        </member>
        <member name="M:NFX.Templatization.Template`3.DoRender">
            <summary>
            Performs actual rendering
            </summary>
        </member>
        <member name="M:NFX.Templatization.Template`3.DoPostRender(System.Exception)">
            <summary>
            Performs post-rendering actions
            </summary>
        </member>
        <member name="P:NFX.Templatization.Template`3.Context">
            <summary>
            Custom context for the lifetime of this template
            </summary>
        </member>
        <member name="P:NFX.Templatization.Template`3.Target">
            <summary>
            Returns thread-local target which is specific for this call to Render()
            </summary>
        </member>
        <member name="P:NFX.Templatization.Template`3.RenderingContext">
            <summary>
            Returns thread-local rendering context which is specific for this call to Render()
            </summary>
        </member>
        <member name="P:NFX.Templatization.Template`3.CanReuseInstance">
            <summary>
            Indicates whether an instance of template class may be reused for invocation of Render() more than once (possibly with different rendering target and/or rendering context)  
            </summary>
        </member>
        <member name="T:NFX.Templatization.TextCSTemplateCompiler">
             <summary>
             Compiles templates based of text files that use C# language syntax
             </summary>
             <example>
             <code>
              #&lt;conf&gt;
               &lt;compiler base-class-name="NFX.Web.Templatization.SimpleWebTemplate"
                         namespace="TestWebApp.Templates"
                         abstract="true"
                         summary="Test master page"
                /&gt;
             #&lt;/conf&gt;
             #[class]
               
                 public string Title { get {return "aaaaa"; } }
            
            
                 protected abstract void renderHeader();
                 protected abstract void renderBody(bool showDetails);
                 protected abstract void renderFooter();
            
            
             #[render]   
             &lt;html&gt;
              &lt;head&gt;   
                &lt;title&gt;?[Title]&lt;/title&gt;
              &lt;/head&gt;
              &lt;body&gt;
            
               &lt;h1&gt;This is Header&lt;/h1&gt;
                @[renderHeader();]
              
               &lt;h1&gt;This is Body&lt;/h1&gt;
                @[renderBody(true);]
               &lt;p&gt;This is in master page&lt;/p&gt;
            
               &lt;h1&gt;This is Footer&lt;/h1&gt;
                @[renderFooter();]
              
              &lt;/body&gt;
             &lt;/html&gt; 
             </code>
             </example>
        </member>
        <member name="T:NFX.Throttling.NOPThrottle">
            <summary>
            No operation throttle
            </summary>
        </member>
        <member name="T:NFX.Throttling.Throttle">
            <summary>
            Base class defining throttle interface
            </summary>
        </member>
        <member name="M:NFX.Throttling.IThrottle.Try">
            <summary>
            Checks whether the current throttle rate limit has not been reached
            per one unit of measurement.  This method is usually used to throttle based
            on pass count
            </summary>
        </member>
        <member name="M:NFX.Throttling.IThrottle.Try(System.Double)">
            <summary>
            Checks whether the current throttle rate limit has not been reached
            for the provided value.  This method is usually used to throttle based
            on values like financial amounts, data volumes, user counts, etc.
            </summary>
        </member>
        <member name="M:NFX.Throttling.IThrottle.Reset">
            <summary>
            Reset the internal state of the throttle
            </summary>
        </member>
        <member name="M:NFX.Throttling.IThrottle.Register(NFX.Throttling.IThrottling)">
            <summary>
            Register this instance with throttling container
            </summary>
        </member>
        <member name="M:NFX.Throttling.IThrottle.Unregister">
            <summary>
            Unregister this instance from throttling container
            </summary>
        </member>
        <member name="P:NFX.Throttling.IThrottle.Name">
            <summary>
            Returns the unique name of this instance
            </summary>
        </member>
        <member name="P:NFX.Throttling.IThrottle.Unit">
            <summary>
            Returns the name of unit of measurement for this instance
            </summary>
        </member>
        <member name="M:NFX.Throttling.Throttle.#ctor(System.String,System.String)">
            <summary>
            Constructor that identifies throttle by name, and optionally defines the
            unit of measurement for this throttle instance
            </summary>
        </member>
        <member name="M:NFX.Throttling.Throttle.Try">
            <summary>
            Checks whether the current throttle rate limit has not been reached
            per one unit of measurement.  This method is usually used to throttle based
            on pass count
            </summary>
        </member>
        <member name="M:NFX.Throttling.Throttle.Try(System.Double)">
            <summary>
            Checks whether the current throttle rate limit has not been reached
            for the provided value.  This method is usually used to throttle based
            on values like financial amounts, data volumes, user counts, etc.
            </summary>
        </member>
        <member name="M:NFX.Throttling.Throttle.Reset">
            <summary>
            Reset the internal state of the throttle
            </summary>
        </member>
        <member name="M:NFX.Throttling.Throttle.Register(NFX.Throttling.IThrottling)">
            <summary>
            Register this instance with throttling container
            </summary>
        </member>
        <member name="M:NFX.Throttling.Throttle.Unregister">
            <summary>
            Unregister this instance from throttling container
            </summary>
        </member>
        <member name="M:NFX.Throttling.Throttle.Try(System.DateTime,System.Double)">
            <summary>
            Update current throttle timestamp
            </summary>
        </member>
        <member name="P:NFX.Throttling.Throttle.Throttling">
            <summary>
            References the Throttling that this instance is registered with
            </summary>
        </member>
        <member name="P:NFX.Throttling.Throttle.Name">
            <summary>
            Returns the unique name of this instance
            </summary>
        </member>
        <member name="P:NFX.Throttling.Throttle.Unit">
            <summary>
            Returns the name of unit of measurement for this instance
            </summary>
        </member>
        <member name="M:NFX.Throttling.NOPThrottle.Try">
            <summary>
            Checks whether the current throttle rate limit has not been reached
            per one unit of measurement.  This method is usually used to throttle based
            on pass count
            </summary>
        </member>
        <member name="M:NFX.Throttling.NOPThrottle.Try(System.Double)">
            <summary>
            Checks whether the current throttle rate limit has not been reached
            for the provided value.  This method is usually used to throttle based
            on values like financial amounts, data volumes, user counts, etc.
            </summary>
        </member>
        <member name="M:NFX.Throttling.NOPThrottle.Reset">
            <summary>
            Reset the internal state of the throttle
            </summary>
        </member>
        <member name="M:NFX.Throttling.NOPThrottle.Try(System.DateTime,System.Double)">
            <summary>
            Update current throttle timestamp
            </summary>
        </member>
        <member name="P:NFX.Throttling.NOPThrottle.Instance">
            <summary>
            Returns a singlelton instance of the NOPThrottle
            </summary>
        </member>
        <member name="T:NFX.Throttling.IThrottling">
            <summary>
            Defines throttling interface to be implemented by the throttling service
            </summary>
        </member>
        <member name="M:NFX.Throttling.IThrottling.RegisterThrottle(NFX.Throttling.Throttle)">
            <summary>
            Register a throttle with this throttling container
            </summary>
        </member>
        <member name="M:NFX.Throttling.IThrottling.UnregisterThrottle(NFX.Throttling.Throttle)">
            <summary>
            Unregister a throttle from this throttling container
            </summary>
            <returns>True if throttle was successfully unregistered</returns>
        </member>
        <member name="P:NFX.Throttling.IThrottling.Enabled">
            <summary>
            Turns throttling functionality on/off
            </summary>
        </member>
        <member name="P:NFX.Throttling.IThrottling.Item(System.String)">
            <summary>
            Get a throttle by name
            </summary>
        </member>
        <member name="T:NFX.Throttling.IThrottlingImplementation">
            <summary>
            Interface implementing configurable and disposable throttling functionaliry
            </summary>
        </member>
        <member name="T:NFX.Throttling.NOPThrottling">
            <summary>
            Represents throttling implementation that does nothing and
            always returns NOPThrottle
            </summary>
        </member>
        <member name="T:NFX.Throttling.TimeSpacingThrottle">
            <summary>
            Throttle based on space reservation in time. It allows at most Limit
            calls of Try() function per Interval. The calls are assumed to be
            equally spaced within the Interval
            </summary>
        </member>
        <member name="M:NFX.Throttling.TimeSpacingThrottle.#ctor(System.String,System.Int32,System.Int32,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="name">Name of this instance</param>
            <param name="throttleLimit">Throttling limit per throttleInterval</param>
            <param name="throttleInterval">Throttling interval in number of seconds</param>
            <param name="unit">Unit of measurement</param>
        </member>
        <member name="M:NFX.Throttling.TimeSpacingThrottle.Reset">
            <summary>
            Reset the internal state of the throttling strategy
            </summary>
        </member>
        <member name="M:NFX.Throttling.TimeSpacingThrottle.Try(System.DateTime,System.Double)">
            <summary>
            Try to reserve a value of units assuming given time.
            </summary>
            <param name="time">Monotonically increasing time value</param>
            <param name="value">The value of timeslots needed to reserve</param>
            <returns>True if reservation is successful</returns>
        </member>
        <member name="P:NFX.Throttling.TimeSpacingThrottle.Limit">
            <summary>
            Return throttle limit over Interval
            </summary>
        </member>
        <member name="P:NFX.Throttling.TimeSpacingThrottle.Interval">
            <summary>
            Return throttling interval in seconds
            </summary>
        </member>
        <member name="T:NFX.Throttling.SlidingWindowThrottle">
            <summary>
            Efficiently calculates the throttling rate over a number of seconds.
            The algorithm implements a variation of token bucket algorithm that
            doesn't require to add tokens to the bucket on a timer but rather it
            maintains a cirtular buffer of tokens with resolution of 1/BucketsPerSec.
            The Add() function is used to add items to a bucket
            associated with the timestamp passed as the first argument to the
            function. The Sum() returns the total number of
            items over the given interval of seconds. The items automatically expire
            when the time moves on the successive invocations of the Add() method.
            </summary>
        </member>
        <member name="M:NFX.Throttling.SlidingWindowThrottle.#ctor(System.String,System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="name">Name of this instance</param>
            <param name="throttleLimit">Throttling limit per throttleInterval</param>
            <param name="throttleInterval">Throttling interval in number of seconds</param>
            <param name="bucketsPerSecond">Number of buckets per second to calculate internal running sum.
            The greater the value the more precise the avg calculation is and the longer it takes to
            calculate</param>
            <param name="unit">Unit of measurement</param>
        </member>
        <member name="M:NFX.Throttling.SlidingWindowThrottle.Reset">
            <summary>
            Reset the internal state of the throttling strategy
            </summary>
        </member>
        <member name="M:NFX.Throttling.SlidingWindowThrottle.ToString(System.DateTime)">
            <summary>
            Dump the internal state to string
            </summary>
            <param name="time">Time for which to dump internal state to string</param>
        </member>
        <member name="M:NFX.Throttling.SlidingWindowThrottle.Try(System.DateTime,System.Double)">
            <summary>
            Add value to the bucket associated with time
            </summary>
            <param name="time">Monotonically increasing time value</param>
            <param name="value">The value to add to the bucket associated with time</param>
            <returns>Current running sum</returns>
        </member>
        <member name="P:NFX.Throttling.SlidingWindowThrottle.Limit">
            <summary>
            Return throttle limit over Interval
            </summary>
        </member>
        <member name="P:NFX.Throttling.SlidingWindowThrottle.Interval">
            <summary>
            Return throttling interval in seconds
            </summary>
        </member>
        <member name="P:NFX.Throttling.SlidingWindowThrottle.BucketsPerSec">
            <summary>
            Number of measurement buckets per second. The greater the number
            the more accurate throttle rate is calculated and the slower the
            calculation gets
            </summary>
        </member>
        <member name="P:NFX.Throttling.SlidingWindowThrottle.Sum">
            <summary>
            Return current running sum over the throttling interval
            </summary>
        </member>
        <member name="P:NFX.Throttling.SlidingWindowThrottle.Avg">
            <summary>
            Return current running average over the throttling interval
            </summary>
        </member>
        <member name="T:NFX.Throttling.ThrottlingService">
            <summary>
            A service that maintains throttling components in an application and
            allows to turn on/off global throttling functionality
            </summary>
        </member>
        <member name="M:NFX.Throttling.ThrottlingService.Get``1(System.String)">
            <summary>
            Resolve a typed throttle by name
            </summary>
        </member>
        <member name="M:NFX.Throttling.ThrottlingService.RegisterThrottle(NFX.Throttling.Throttle)">
            <summary>
            Register a throttle with this throttling container
            </summary>
        </member>
        <member name="M:NFX.Throttling.ThrottlingService.UnregisterThrottle(NFX.Throttling.Throttle)">
            <summary>
            Unregister a throttle from this throttling container
            </summary>
            <returns>True if throttle was successfully unregistered</returns>
        </member>
        <member name="P:NFX.Throttling.ThrottlingService.Item(System.String)">
            <summary>
            Resolve a throttle instance by name
            </summary>
        </member>
        <member name="T:NFX.Time.DaysOfWeek">
            <summary>
            Days of week bitmask enumeration
            </summary>
        </member>
        <member name="T:NFX.Time.DefaultTimeSource">
            <summary>
            Provides default time source implementation which is build on DateTime local class
            </summary>
        </member>
        <member name="T:NFX.Time.ITimeSourceImplementation">
            <summary>
            Denotes an implementation for an app-global time source - an entity that supplies time in this application instance
            </summary>
        </member>
        <member name="T:NFX.Time.ITimeSource">
            <summary>
            Denotes app-global time source - an entity that supplies time in this application instance
            </summary>
        </member>
        <member name="P:NFX.Time.ITimeSource.Now">
            <summary>
            Returns local time stamp, Alias to this.LocalizedTime
            </summary>
        </member>
        <member name="P:NFX.Time.ITimeSource.UTCNow">
            <summary>
            Returns current UTC time stamp
            </summary>
        </member>
        <member name="M:NFX.Time.DefaultTimeSource.UniversalTimeToLocalizedTime(System.DateTime)">
            <summary>
            Converts universal time to local time as of TimeLocation property
            </summary>
        </member>
        <member name="M:NFX.Time.DefaultTimeSource.LocalizedTimeToUniversalTime(System.DateTime)">
            <summary>
            Converts localized time to UTC time as of TimeLocation property
            </summary>
        </member>
        <member name="P:NFX.Time.DefaultTimeSource.Instance">
            <summary>
            Returns a singleton DefaultTimeSource instance
            </summary>
        </member>
        <member name="P:NFX.Time.DefaultTimeSource.LocalizedTime">
            <summary>
            Returns current time localized per TimeLocation
            </summary>
        </member>
        <member name="T:NFX.Time.EventStatus">
            <summary>
            Denotes statuses that events get transitioned through
            </summary>
        </member>
        <member name="T:NFX.Time.IEventHandler">
            <summary>
            Represents an entity that can handle events.
            This type is used to implement event handlers that get injected via config
            </summary>
        </member>
        <member name="T:NFX.Time.TimerEvent">
            <summary>
            Delegate type for events that get called when timer fires
            </summary>
        </member>
        <member name="T:NFX.Time.TimerEventStatusChange">
            <summary>
            Delegate type for events that get called when timer event status changes
            </summary>
        </member>
        <member name="T:NFX.Time.TimerEventDefinitionChange">
            <summary>
            Delegate type for events that get called when one of timer event definition parameters changes
            </summary>
        </member>
        <member name="T:NFX.Time.Event">
            <summary>
            Represents an event manageable by IEventTimer
            </summary>
        </member>
        <member name="F:NFX.Time.Event.EventHandler">
            <summary>
            References event handler that handles events. If it is null then only delegate events are called
            </summary>
        </member>
        <member name="M:NFX.Time.Event.ResetCallCount">
            <summary>
            Resets call count counter. If this event has expired it will eventually transition to Started state.
            Keep in mind that it may expire again if EndDate is set and past due
            </summary>
        </member>
        <member name="M:NFX.Time.Event.Fire(System.Boolean)">
            <summary>
            Calls event regardless of any constraints.
            Invokes a handler right away if syncInvoke is true, or queues the task on a thread pool
            </summary>
        </member>
        <member name="M:NFX.Time.Event.UniversalTimeToLocalizedTime(System.DateTime)">
            <summary>
            Converts universal time to local time as of TimeLocation property
            </summary>
        </member>
        <member name="M:NFX.Time.Event.LocalizedTimeToUniversalTime(System.DateTime)">
            <summary>
            Converts localized time to UTC time as of TimeLocation property
            </summary>
        </member>
        <member name="M:NFX.Time.Event.ExternalParametersForGroups(System.String[])">
            <summary>
            Returns named parameters that can be used to control this component
            </summary>
        </member>
        <member name="M:NFX.Time.Event.ExternalGetParameter(System.String,System.Object@,System.String[])">
            <summary>
            Gets external parameter value returning true if parameter was found
            </summary>
        </member>
        <member name="M:NFX.Time.Event.ExternalSetParameter(System.String,System.Object,System.String[])">
            <summary>
            Sets external parameter value returning true if parameter was found and set
            </summary>
        </member>
        <member name="M:NFX.Time.Event.AdjustDate(System.Nullable{System.DateTime})">
            <summary>
            Adjusts date time Localized time
            </summary>
        </member>
        <member name="M:NFX.Time.Event.VisitAndCheck(System.DateTime)">
            <summary>
            Invoked by timer, checks all conditions and fires/expires event depending on the status.
            Returns true if event was fired, false otherwise
            </summary>
        </member>
        <member name="M:NFX.Time.Event.DoVisit(System.DateTime)">
            <summary>
            Override to perform extra status checks
            </summary>
        </member>
        <member name="P:NFX.Time.Event.TimeLocation">
            <summary>
            Returns time location that this Event instance operates under.
            </summary>
        </member>
        <member name="P:NFX.Time.Event.LocalizedTime">
            <summary>
            Returns current time localized per TimeLocation
            </summary>
        </member>
        <member name="E:NFX.Time.Event.Body">
            <summary>
            Event body that gets called when the event is due. The body is always invoked ASYNCHRONOUSLY
            unless Fire(syncronous=true) is called in which case it gets called on a thread that called Fire(true)
            </summary>
        </member>
        <member name="E:NFX.Time.Event.StatusChange">
            <summary>
            Invoked when timer event status changes. Always called synchronously by the timer thread. 
            Subscribers should not block for long
            </summary>
        </member>
        <member name="E:NFX.Time.Event.DefinitionChange">
            <summary>
            Invoked when one of timer event definition parameters changes.
            Always called synchronously on the same thread that made a change.
            Subscribers should not block for long
            </summary>
        </member>
        <member name="P:NFX.Time.Event.Enabled">
            <summary>
            Specifies whether this event will fire/participate in timer loop
            </summary>
        </member>
        <member name="P:NFX.Time.Event.StartDate">
            <summary>
            Specifies when this event will start firing in the local event time
            </summary>
        </member>
        <member name="P:NFX.Time.Event.EndDate">
            <summary>
            Specifies when this event will stop firing in the local event time
            </summary>
        </member>
        <member name="P:NFX.Time.Event.Interval">
            <summary>
            Specifies how often event fires
            </summary>
        </member>
        <member name="P:NFX.Time.Event.MaxCount">
            <summary>
            Specifies how many times this event can be called. If less or equal than zero then no limit is set
            </summary>
        </member>
        <member name="P:NFX.Time.Event.Context">
            <summary>
            Adds arbitrary context object to the event
            </summary>
        </member>
        <member name="P:NFX.Time.Event.CallCount">
            <summary>
            Returns how many times this event was called
            </summary>
        </member>
        <member name="P:NFX.Time.Event.LastCall">
            <summary>
            Returns when was this event called for the last time in the local event time
            </summary>
        </member>
        <member name="P:NFX.Time.Event.LastError">
            <summary>
            Returns the last exception thrown from event handler or nul if no error happened
            </summary>
        </member>
        <member name="P:NFX.Time.Event.ExternalParameters">
            <summary>
            Returns named parameters that can be used to control this component
            </summary>
        </member>
        <member name="T:NFX.Time.EventTimer">
            <summary>
            Provides default implementation for IEventTimer
            </summary>
        </member>
        <member name="T:NFX.Time.IEventTimerImplementation">
            <summary>
            Denotes an implementation for an app-global event timer - an entity that fires requested events
            </summary>
        </member>
        <member name="T:NFX.Time.IEventTimer">
            <summary>
            Denotes a contract for an app-global event timer - an entity that fires requested events
            </summary>
        </member>
        <member name="P:NFX.Time.IEventTimer.ResolutionMs">
            <summary>
            Gets the granularity of event firing resolution
            </summary>
        </member>
        <member name="P:NFX.Time.IEventTimer.Events">
            <summary>
            Lists all events in the instance
            </summary>
        </member>
        <member name="M:NFX.Time.IEventTimerImplementation.__InternalRegisterEvent(NFX.Time.Event)">
            <summary>
            Internall call, developers - do not call
            </summary>
        </member>
        <member name="M:NFX.Time.IEventTimerImplementation.__InternalUnRegisterEvent(NFX.Time.Event)">
            <summary>
            Internall call, developers - do not call
            </summary>
        </member>
        <member name="P:NFX.Time.EventTimer.ResolutionMs">
            <summary>
            Timer resolution in milliseconds
            </summary>
        </member>
        <member name="P:NFX.Time.EventTimer.Events">
            <summary>
            Lists all events in the instance
            </summary>
        </member>
        <member name="P:NFX.Time.EventTimer.ExternalParameters">
            <summary>
            Returns named parameters that can be used to control this component
            </summary>
        </member>
        <member name="T:NFX.Time.TimeException">
            <summary>
            Base exception thrown by the Time framework
            </summary>
        </member>
        <member name="T:NFX.Time.TimeLocation">
            <summary>
            Data about location where time is measured relative to UTC
            </summary>
        </member>
        <member name="M:NFX.Time.TimeLocation.#ctor(System.Boolean)">
            <summary>
            Creates instance that uses entity's parent settings. May use TimeLocation.Parent static instance instead
            </summary>
        </member>
        <member name="P:NFX.Time.TimeLocation.Parent">
            <summary>
            Returns a singleton instance of timelocation which uses parent setting
            </summary>
        </member>
        <member name="P:NFX.Time.TimeLocation.UTC">
            <summary>
            Returns a singleton instance of UTC timelocation (zero offset from UTC)
            </summary>
        </member>
        <member name="P:NFX.Time.TimeLocation.UTCOffset">
            <summary>
            Returns UTC offset
            </summary>
        </member>
        <member name="P:NFX.Time.TimeLocation.Description">
            <summary>
            Location description
            </summary>
        </member>
        <member name="P:NFX.Time.TimeLocation.UseParentSetting">
            <summary>
            Returns true when entity's parent settings should be used
            </summary>
        </member>
        <member name="P:NFX.Time.TimeLocation.Immutable">
            <summary>
            Returns true to indicate that the instance can not be mutated with Configure() or property sets
            </summary>
        </member>
        <member name="M:NFX.IntMath.Align8(System.Int32)">
            <summary>
            Returns argument increased to the nearest number divisible by 8
            </summary>
        </member>
        <member name="M:NFX.IntMath.Align16(System.Int32)">
            <summary>
            Returns argument increased to the nearest number divisible by 16
            </summary>
        </member>
        <member name="M:NFX.IntMath.Align8(System.Int64)">
            <summary>
            Returns argument increased to the nearest number divisible by 8
            </summary>
        </member>
        <member name="M:NFX.IntMath.Align16(System.Int64)">
            <summary>
            Returns argument increased to the nearest number divisible by 16
            </summary>
        </member>
        <member name="M:NFX.IntMath.IsPrime(System.Int32)">
            <summary>
            Tests if the number is prime
            </summary>
        </member>
        <member name="M:NFX.IntMath.GetAdjacentPrimeNumberLessThanOrEqualTo(System.Int32)">
            <summary>
            Gets adjacent prime number which is less than or equal to the specified number. Arguments less than 3 yield 2;
            </summary>
        </member>
        <member name="M:NFX.IntMath.GetPrimeCapacityOfAtLeast(System.Int32)">
            <summary>
            Gets the capacity of at least or larger larger than the specified number. For numbers &lt;= 16300007 the function uses lookup table for speed
            </summary>
        </member>
        <member name="M:NFX.IntMath.GetCapacityFactoredToPrime(System.Int32,System.Double)">
            <summary>
            Increases a capacity to a prime number by the factor. Both numbers must be positive
            </summary>
        </member>
    </members>
</doc>
